diff --git a/config.h b/config.h
new file mode 100644
index 0000000..da224eb
--- /dev/null
+++ b/config.h
@@ -0,0 +1,428 @@
+/*
+ * Autogenerated by the Meson build system.
+ * Do not edit, your changes will be lost.
+ */
+
+#pragma once
+
+#define ALIGNOF_GUINT32 4
+
+#define ALIGNOF_GUINT64 8
+
+#ifdef __LP64__
+#define ALIGNOF_UNSIGNED_LONG 8
+
+#define DBL_EXPBIT0_BIT 20
+
+#define DBL_EXPBIT0_WORD 1
+#else
+#define ALIGNOF_UNSIGNED_LONG 4
+#endif
+
+#ifndef OHOS_OPT_COMPAT
+/* ohos.opt.compat.001:
+ * Remove dependency to gettext
+ */
+#define ENABLE_NLS 1
+#endif
+
+#define EXEEXT 
+
+#define GETTEXT_PACKAGE "glib20"
+
+#define GLIB_BINARY_AGE 7202
+
+#define GLIB_INTERFACE_AGE 2
+
+#define GLIB_LOCALE_DIR "/usr/local/share/locale"
+
+#define GLIB_MAJOR_VERSION 2
+
+#define GLIB_MICRO_VERSION 2
+
+#define GLIB_MINOR_VERSION 72
+
+#define G_VA_COPY va_copy
+
+#define G_VA_COPY_AS_ARRAY 1
+
+#define HAVE_ALLOCA_H 1
+
+#define HAVE_BIND_TEXTDOMAIN_CODESET
+
+#undef HAVE_C99_SNPRINTF
+
+#undef HAVE_C99_VSNPRINTF
+
+#define HAVE_CLOCK_GETTIME 1
+
+#define HAVE_CODESET 1
+
+#define HAVE_DCGETTEXT 1
+
+#define HAVE_DIRENT_H 1
+
+#define HAVE_DN_COMP 1
+
+#define HAVE_ENDMNTENT 1
+
+#define HAVE_ENDSERVENT 1
+
+#define HAVE_EPOLL_CREATE 1
+
+#define HAVE_EVENTFD 1
+
+#define HAVE_FALLOCATE 1
+
+#define HAVE_FCHMOD 1
+
+#define HAVE_FCHOWN 1
+
+#define HAVE_FLOAT_H 1
+
+#define HAVE_FSTAB_H 1
+
+#define HAVE_FSYNC 1
+
+#define HAVE_FUTEX 1
+
+#define HAVE_GETAUXVAL 1
+
+#define HAVE_GETC_UNLOCKED 1
+
+#define HAVE_GETGRGID_R 1
+
+#define HAVE_GETMNTENT_R 1
+
+#define HAVE_GETPWUID_R 1
+
+#define HAVE_GETRESUID 1
+
+#define HAVE_GETTEXT 1
+
+#define HAVE_GMTIME_R 1
+
+#define HAVE_GRP_H 1
+
+#define HAVE_HASMNTOPT 1
+
+#define HAVE_IF_INDEXTONAME 1
+
+#define HAVE_IF_NAMETOINDEX 1
+
+#define HAVE_INOTIFY_INIT1 1
+
+#define HAVE_INTMAX_T 1
+
+#define HAVE_INTTYPES_H 1
+
+#define HAVE_INTTYPES_H_WITH_UINTMAX 1
+
+#define HAVE_IPV6
+
+#define HAVE_IP_MREQN 1
+
+#define HAVE_LANGINFO_CODESET 1
+
+#define HAVE_LANGINFO_TIME 1
+
+#define HAVE_LCHOWN 1
+
+#define HAVE_LC_MESSAGES 1
+
+#undef HAVE_LIBMOUNT
+
+#define HAVE_LIMITS_H 1
+
+#define HAVE_LINK 1
+
+#define HAVE_LOCALE_H 1
+
+#define HAVE_LOCALTIME_R 1
+
+#define HAVE_LONG_DOUBLE 1
+
+#define HAVE_LONG_LONG 1
+
+#define HAVE_LSTAT 1
+
+#define HAVE_MALLOC_H 1
+
+#define HAVE_MBRTOWC 1
+
+#define HAVE_MEMALIGN 1
+
+#define HAVE_MEMORY_H 1
+
+#define HAVE_MKOSTEMP 1
+
+#define HAVE_MMAP 1
+
+#define HAVE_MNTENT_H 1
+
+#define HAVE_NETLINK 1
+
+#define HAVE_NEWLOCALE 1
+
+#define HAVE_OPEN_O_DIRECTORY 1
+
+#define HAVE_PIPE2 1
+
+#define HAVE_POLL 1
+
+#define HAVE_POLL_H 1
+
+#define HAVE_POSIX_MEMALIGN 1
+
+#define HAVE_POSIX_SPAWN 1
+
+#define HAVE_PRLIMIT 1
+
+#define HAVE_PROC_SELF_CMDLINE
+
+#define HAVE_PTHREAD_ATTR_SETINHERITSCHED 1
+
+#define HAVE_PTHREAD_ATTR_SETSTACKSIZE 1
+
+#define HAVE_PTHREAD_CONDATTR_SETCLOCK 1
+
+#define HAVE_PTHREAD_GETNAME_NP 1
+
+#define HAVE_PTHREAD_SETNAME_NP_WITH_TID 1
+
+#define HAVE_PTRDIFF_T 1
+
+#define HAVE_PWD_H 1
+
+#define HAVE_READLINK 1
+
+#define HAVE_RECVMMSG 1
+
+#define HAVE_RES_NCLOSE 1
+
+#define HAVE_RES_NINIT 1
+
+#define HAVE_RTLD_GLOBAL 1
+
+#define HAVE_RTLD_LAZY 1
+
+#define HAVE_RTLD_NEXT 1
+
+#define HAVE_RTLD_NOW 1
+
+#define HAVE_SCHED_H 1
+
+#undef HAVE_SELINUX
+
+#define HAVE_SENDMMSG 1
+
+#define HAVE_SETENV 1
+
+#define HAVE_SETMNTENT 1
+
+#define HAVE_SIG_ATOMIC_T 1
+
+#define HAVE_SIOCGIFADDR /**/
+
+#define HAVE_SNPRINTF 1
+
+#define HAVE_SPAWN_H 1
+
+#define HAVE_SPLICE 1
+
+#define HAVE_STATFS 1
+
+#define HAVE_STATVFS 1
+
+#define HAVE_STDATOMIC_H 1
+
+#define HAVE_STDINT_H 1
+
+#define HAVE_STDINT_H_WITH_UINTMAX 1
+
+#define HAVE_STDLIB_H 1
+
+#define HAVE_STPCPY 1
+
+#define HAVE_STRCASECMP 1
+
+#define HAVE_STRERROR_R 1
+
+#define HAVE_STRINGS_H 1
+
+#define HAVE_STRING_H 1
+
+#define HAVE_STRNCASECMP 1
+
+#define HAVE_STRNLEN 1
+
+#define HAVE_STRSIGNAL 1
+
+#define HAVE_STRTOD_L 1
+
+#define HAVE_STRTOLL_L 1
+
+#define HAVE_STRTOULL_L 1
+
+#define HAVE_STRUCT_DIRENT_D_TYPE 1
+
+#define HAVE_STRUCT_STATFS_F_BAVAIL 1
+
+#define HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC 1
+
+#define HAVE_STRUCT_STAT_ST_BLKSIZE 1
+
+#define HAVE_STRUCT_STAT_ST_BLOCKS 1
+
+#define HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC 1
+
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
+
+#define HAVE_STRUCT_TM_TM_GMTOFF 1
+
+#define HAVE_SYMLINK 1
+
+#undef HAVE_SYSPROF
+
+#define HAVE_SYS_AUXV_H 1
+
+#define HAVE_SYS_INOTIFY_H 1
+
+#define HAVE_SYS_MOUNT_H 1
+
+#define HAVE_SYS_PARAM_H 1
+
+#define HAVE_SYS_RESOURCE_H 1
+
+#define HAVE_SYS_SCHED_GETATTR 1
+
+#define HAVE_SYS_SELECT_H 1
+
+#define HAVE_SYS_STATFS_H 1
+
+#define HAVE_SYS_STATVFS_H 1
+
+#define HAVE_SYS_STAT_H 1
+
+#define HAVE_SYS_SYSCTL_H 1
+
+#define HAVE_SYS_TIMES_H 1
+
+#define HAVE_SYS_TIME_H 1
+
+#define HAVE_SYS_TYPES_H 1
+
+#define HAVE_SYS_UIO_H 1
+
+#define HAVE_SYS_VFS_H 1
+
+#define HAVE_SYS_WAIT_H 1
+
+#define HAVE_SYS_XATTR_H 1
+
+#define HAVE_TERMIOS_H 1
+
+#define HAVE_TIMEGM 1
+
+#define HAVE_UINT128_T 1
+
+#define HAVE_UNISTD_H 1
+
+#undef HAVE_UNIX98_PRINTF
+
+#define HAVE_UNSETENV 1
+
+#define HAVE_UTIMES 1
+
+#define HAVE_VALLOC 1
+
+#define HAVE_VALUES_H 1
+
+#define HAVE_VASPRINTF 1
+
+#define HAVE_VSNPRINTF 1
+
+#define HAVE_WCHAR_H 1
+
+#define HAVE_WCHAR_T 1
+
+#define HAVE_WCRTOMB 1
+
+#define HAVE_WCSLEN 1
+
+#define HAVE_WCSNLEN 1
+
+#define HAVE_WINT_T 1
+
+#define HAVE_XATTR 1
+
+#define MAJOR_IN_SYSMACROS 1
+
+#define PACKAGE_BUGREPORT "https://gitlab.gnome.org/GNOME/glib/issues/new"
+
+#define PACKAGE_NAME "glib"
+
+#define PACKAGE_STRING "glib 2.72.2"
+
+#define PACKAGE_TARNAME "glib"
+
+#define PACKAGE_URL ""
+
+#define PACKAGE_VERSION "2.72.2"
+
+#define SIZEOF_CHAR 1
+
+#define SIZEOF_INT 4
+
+#ifdef __LP64__
+#define SIZEOF_LONG 8
+#else
+#define SIZEOF_LONG 4
+#endif
+
+#define SIZEOF_LONG_LONG 8
+
+#define SIZEOF_SHORT 2
+
+#ifdef __LP64__
+#define SIZEOF_SIZE_T 8
+
+#define SIZEOF_SSIZE_T 8
+
+#define SIZEOF_VOID_P 8
+#else
+#define SIZEOF_SIZE_T 4
+
+#define SIZEOF_SSIZE_T 4
+
+#define SIZEOF_VOID_P 4
+#endif
+
+#define SIZEOF_WCHAR_T 4
+
+#define STATFS_ARGS 2
+
+#ifndef OHOS_OPT_COMPAT
+/*
+ * OHOS_OPT_COMPAT.0026
+ * strerror_r return null in RK platform, resulting in abnormal process
+ */
+#define STRERROR_R_CHAR_P 1  // Defined if strerror_r returns char *
+#endif
+
+#define THREADS_POSIX 1
+
+#define USE_STATFS 1
+
+#undef USE_SYSTEM_PCRE
+
+#define USE_SYSTEM_PRINTF
+
+#define _GLIB_EXTERN __attribute__((visibility("default"))) extern
+
+#define _GNU_SOURCE 1
+
+#define gl_extern_inline 
+
+#define gl_unused 
+
diff --git a/gio/gconstructor_as_data.h b/gio/gconstructor_as_data.h
new file mode 100644
index 0000000..b447ff5
--- /dev/null
+++ b/gio/gconstructor_as_data.h
@@ -0,0 +1 @@
+const char gconstructor_code[] = "\x2f\x2a\x20\x47\x4c\x49\x42\x20\x2d\x20\x4c\x69\x62\x72\x61\x72\x79\x20\x6f\x66\x20\x75\x73\x65\x66\x75\x6c\x20\x72\x6f\x75\x74\x69\x6e\x65\x73\x20\x66\x6f\x72\x20\x43\x20\x70\x72\x6f\x67\x72\x61\x6d\x6d\x69\x6e\x67\x0a\x20\x2a\x20\x43\x6f\x70\x79\x72\x69\x67\x68\x74\x20\x28\x43\x29\x20\x31\x39\x39\x35\x2d\x31\x39\x39\x37\x20\x20\x50\x65\x74\x65\x72\x20\x4d\x61\x74\x74\x69\x73\x2c\x20\x53\x70\x65\x6e\x63\x65\x72\x20\x4b\x69\x6d\x62\x61\x6c\x6c\x20\x61\x6e\x64\x20\x4a\x6f\x73\x68\x20\x4d\x61\x63\x44\x6f\x6e\x61\x6c\x64\x0a\x20\x2a\x0a\x20\x2a\x20\x54\x68\x69\x73\x20\x6c\x69\x62\x72\x61\x72\x79\x20\x69\x73\x20\x66\x72\x65\x65\x20\x73\x6f\x66\x74\x77\x61\x72\x65\x3b\x20\x79\x6f\x75\x20\x63\x61\x6e\x20\x72\x65\x64\x69\x73\x74\x72\x69\x62\x75\x74\x65\x20\x69\x74\x20\x61\x6e\x64\x2f\x6f\x72\x0a\x20\x2a\x20\x6d\x6f\x64\x69\x66\x79\x20\x69\x74\x20\x75\x6e\x64\x65\x72\x20\x74\x68\x65\x20\x74\x65\x72\x6d\x73\x20\x6f\x66\x20\x74\x68\x65\x20\x47\x4e\x55\x20\x4c\x65\x73\x73\x65\x72\x20\x47\x65\x6e\x65\x72\x61\x6c\x20\x50\x75\x62\x6c\x69\x63\x0a\x20\x2a\x20\x4c\x69\x63\x65\x6e\x73\x65\x20\x61\x73\x20\x70\x75\x62\x6c\x69\x73\x68\x65\x64\x20\x62\x79\x20\x74\x68\x65\x20\x46\x72\x65\x65\x20\x53\x6f\x66\x74\x77\x61\x72\x65\x20\x46\x6f\x75\x6e\x64\x61\x74\x69\x6f\x6e\x3b\x20\x65\x69\x74\x68\x65\x72\x0a\x20\x2a\x20\x76\x65\x72\x73\x69\x6f\x6e\x20\x32\x2e\x31\x20\x6f\x66\x20\x74\x68\x65\x20\x4c\x69\x63\x65\x6e\x73\x65\x2c\x20\x6f\x72\x20\x28\x61\x74\x20\x79\x6f\x75\x72\x20\x6f\x70\x74\x69\x6f\x6e\x29\x20\x61\x6e\x79\x20\x6c\x61\x74\x65\x72\x20\x76\x65\x72\x73\x69\x6f\x6e\x2e\x0a\x20\x2a\x0a\x20\x2a\x20\x54\x68\x69\x73\x20\x6c\x69\x62\x72\x61\x72\x79\x20\x69\x73\x20\x64\x69\x73\x74\x72\x69\x62\x75\x74\x65\x64\x20\x69\x6e\x20\x74\x68\x65\x20\x68\x6f\x70\x65\x20\x74\x68\x61\x74\x20\x69\x74\x20\x77\x69\x6c\x6c\x20\x62\x65\x20\x75\x73\x65\x66\x75\x6c\x2c\x0a\x20\x2a\x20\x62\x75\x74\x20\x57\x49\x54\x48\x4f\x55\x54\x20\x41\x4e\x59\x20\x57\x41\x52\x52\x41\x4e\x54\x59\x3b\x20\x77\x69\x74\x68\x6f\x75\x74\x20\x65\x76\x65\x6e\x20\x74\x68\x65\x20\x69\x6d\x70\x6c\x69\x65\x64\x20\x77\x61\x72\x72\x61\x6e\x74\x79\x20\x6f\x66\x0a\x20\x2a\x20\x4d\x45\x52\x43\x48\x41\x4e\x54\x41\x42\x49\x4c\x49\x54\x59\x20\x6f\x72\x20\x46\x49\x54\x4e\x45\x53\x53\x20\x46\x4f\x52\x20\x41\x20\x50\x41\x52\x54\x49\x43\x55\x4c\x41\x52\x20\x50\x55\x52\x50\x4f\x53\x45\x2e\x09\x20\x53\x65\x65\x20\x74\x68\x65\x20\x47\x4e\x55\x0a\x20\x2a\x20\x4c\x65\x73\x73\x65\x72\x20\x47\x65\x6e\x65\x72\x61\x6c\x20\x50\x75\x62\x6c\x69\x63\x20\x4c\x69\x63\x65\x6e\x73\x65\x20\x66\x6f\x72\x20\x6d\x6f\x72\x65\x20\x64\x65\x74\x61\x69\x6c\x73\x2e\x0a\x20\x2a\x0a\x20\x2a\x20\x59\x6f\x75\x20\x73\x68\x6f\x75\x6c\x64\x20\x68\x61\x76\x65\x20\x72\x65\x63\x65\x69\x76\x65\x64\x20\x61\x20\x63\x6f\x70\x79\x20\x6f\x66\x20\x74\x68\x65\x20\x47\x4e\x55\x20\x4c\x65\x73\x73\x65\x72\x20\x47\x65\x6e\x65\x72\x61\x6c\x20\x50\x75\x62\x6c\x69\x63\x0a\x20\x2a\x20\x4c\x69\x63\x65\x6e\x73\x65\x20\x61\x6c\x6f\x6e\x67\x20\x77\x69\x74\x68\x20\x74\x68\x69\x73\x20\x6c\x69\x62\x72\x61\x72\x79\x3b\x20\x69\x66\x20\x6e\x6f\x74\x2c\x20\x73\x65\x65\x20\x3c\x68\x74\x74\x70\x3a\x2f\x2f\x77\x77\x77\x2e\x67\x6e\x75\x2e\x6f\x72\x67\x2f\x6c\x69\x63\x65\x6e\x73\x65\x73\x2f\x3e\x2e\x0a\x20\x2a\x2f\x0a\x0a\x2f\x2a\x0a\x20\x2a\x20\x4d\x6f\x64\x69\x66\x69\x65\x64\x20\x62\x79\x20\x74\x68\x65\x20\x47\x4c\x69\x62\x20\x54\x65\x61\x6d\x20\x61\x6e\x64\x20\x6f\x74\x68\x65\x72\x73\x20\x31\x39\x39\x37\x2d\x32\x30\x30\x30\x2e\x20\x20\x53\x65\x65\x20\x74\x68\x65\x20\x41\x55\x54\x48\x4f\x52\x53\x0a\x20\x2a\x20\x66\x69\x6c\x65\x20\x66\x6f\x72\x20\x61\x20\x6c\x69\x73\x74\x20\x6f\x66\x20\x70\x65\x6f\x70\x6c\x65\x20\x6f\x6e\x20\x74\x68\x65\x20\x47\x4c\x69\x62\x20\x54\x65\x61\x6d\x2e\x20\x20\x53\x65\x65\x20\x74\x68\x65\x20\x43\x68\x61\x6e\x67\x65\x4c\x6f\x67\x0a\x20\x2a\x20\x66\x69\x6c\x65\x73\x20\x66\x6f\x72\x20\x61\x20\x6c\x69\x73\x74\x20\x6f\x66\x20\x63\x68\x61\x6e\x67\x65\x73\x2e\x20\x20\x54\x68\x65\x73\x65\x20\x66\x69\x6c\x65\x73\x20\x61\x72\x65\x20\x64\x69\x73\x74\x72\x69\x62\x75\x74\x65\x64\x20\x77\x69\x74\x68\x0a\x20\x2a\x20\x47\x4c\x69\x62\x20\x61\x74\x20\x66\x74\x70\x3a\x2f\x2f\x66\x74\x70\x2e\x67\x74\x6b\x2e\x6f\x72\x67\x2f\x70\x75\x62\x2f\x67\x74\x6b\x2f\x2e\x0a\x20\x2a\x2f\x0a\x0a\x23\x69\x66\x6e\x64\x65\x66\x20\x5f\x5f\x47\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x48\x5f\x5f\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x5f\x5f\x47\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x48\x5f\x5f\x0a\x0a\x2f\x2a\x0a\x20\x20\x49\x66\x20\x47\x5f\x48\x41\x53\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x53\x20\x69\x73\x20\x74\x72\x75\x65\x20\x74\x68\x65\x6e\x20\x74\x68\x65\x20\x63\x6f\x6d\x70\x69\x6c\x65\x72\x20\x73\x75\x70\x70\x6f\x72\x74\x20\x2a\x62\x6f\x74\x68\x2a\x20\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x73\x20\x61\x6e\x64\x0a\x20\x20\x64\x65\x73\x74\x72\x75\x63\x74\x6f\x72\x73\x2c\x20\x69\x6e\x20\x61\x20\x75\x73\x61\x62\x6c\x65\x20\x77\x61\x79\x2c\x20\x69\x6e\x63\x6c\x75\x64\x69\x6e\x67\x20\x65\x2e\x67\x2e\x20\x6f\x6e\x20\x6c\x69\x62\x72\x61\x72\x79\x20\x75\x6e\x6c\x6f\x61\x64\x2e\x20\x49\x66\x20\x6e\x6f\x74\x20\x79\x6f\x75\x27\x72\x65\x20\x6f\x6e\x0a\x20\x20\x79\x6f\x75\x72\x20\x6f\x77\x6e\x2e\x0a\x0a\x20\x20\x53\x6f\x6d\x65\x20\x63\x6f\x6d\x70\x69\x6c\x65\x72\x73\x20\x6e\x65\x65\x64\x20\x23\x70\x72\x61\x67\x6d\x61\x20\x74\x6f\x20\x68\x61\x6e\x64\x6c\x65\x20\x74\x68\x69\x73\x2c\x20\x77\x68\x69\x63\x68\x20\x64\x6f\x65\x73\x20\x6e\x6f\x74\x20\x77\x6f\x72\x6b\x20\x77\x69\x74\x68\x20\x6d\x61\x63\x72\x6f\x73\x2c\x0a\x20\x20\x73\x6f\x20\x74\x68\x65\x20\x77\x61\x79\x20\x79\x6f\x75\x20\x6e\x65\x65\x64\x20\x74\x6f\x20\x75\x73\x65\x20\x74\x68\x69\x73\x20\x69\x73\x20\x28\x66\x6f\x72\x20\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x73\x29\x3a\x0a\x0a\x20\x20\x23\x69\x66\x64\x65\x66\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x4e\x45\x45\x44\x53\x5f\x50\x52\x41\x47\x4d\x41\x0a\x20\x20\x23\x70\x72\x61\x67\x6d\x61\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x50\x52\x41\x47\x4d\x41\x5f\x41\x52\x47\x53\x28\x6d\x79\x5f\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x29\x0a\x20\x20\x23\x65\x6e\x64\x69\x66\x0a\x20\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x28\x6d\x79\x5f\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x29\x0a\x20\x20\x73\x74\x61\x74\x69\x63\x20\x76\x6f\x69\x64\x20\x6d\x79\x5f\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x28\x76\x6f\x69\x64\x29\x20\x7b\x0a\x20\x20\x20\x2e\x2e\x2e\x0a\x20\x20\x7d\x0a\x0a\x2a\x2f\x0a\x0a\x23\x69\x66\x6e\x64\x65\x66\x20\x5f\x5f\x47\x54\x4b\x5f\x44\x4f\x43\x5f\x49\x47\x4e\x4f\x52\x45\x5f\x5f\x0a\x0a\x23\x69\x66\x20\x20\x5f\x5f\x47\x4e\x55\x43\x5f\x5f\x20\x3e\x20\x32\x20\x7c\x7c\x20\x28\x5f\x5f\x47\x4e\x55\x43\x5f\x5f\x20\x3d\x3d\x20\x32\x20\x26\x26\x20\x5f\x5f\x47\x4e\x55\x43\x5f\x4d\x49\x4e\x4f\x52\x5f\x5f\x20\x3e\x3d\x20\x37\x29\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x48\x41\x53\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x53\x20\x31\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x28\x5f\x66\x75\x6e\x63\x29\x20\x73\x74\x61\x74\x69\x63\x20\x76\x6f\x69\x64\x20\x5f\x5f\x61\x74\x74\x72\x69\x62\x75\x74\x65\x5f\x5f\x28\x28\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x29\x29\x20\x5f\x66\x75\x6e\x63\x20\x28\x76\x6f\x69\x64\x29\x3b\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x44\x45\x53\x54\x52\x55\x43\x54\x4f\x52\x28\x5f\x66\x75\x6e\x63\x29\x20\x73\x74\x61\x74\x69\x63\x20\x76\x6f\x69\x64\x20\x5f\x5f\x61\x74\x74\x72\x69\x62\x75\x74\x65\x5f\x5f\x28\x28\x64\x65\x73\x74\x72\x75\x63\x74\x6f\x72\x29\x29\x20\x5f\x66\x75\x6e\x63\x20\x28\x76\x6f\x69\x64\x29\x3b\x0a\x0a\x23\x65\x6c\x69\x66\x20\x64\x65\x66\x69\x6e\x65\x64\x20\x28\x5f\x4d\x53\x43\x5f\x56\x45\x52\x29\x20\x26\x26\x20\x28\x5f\x4d\x53\x43\x5f\x56\x45\x52\x20\x3e\x3d\x20\x31\x35\x30\x30\x29\x0a\x2f\x2a\x20\x56\x69\x73\x75\x61\x6c\x20\x73\x74\x75\x64\x69\x6f\x20\x32\x30\x30\x38\x20\x61\x6e\x64\x20\x6c\x61\x74\x65\x72\x20\x68\x61\x73\x20\x5f\x50\x72\x61\x67\x6d\x61\x20\x2a\x2f\x0a\x0a\x2f\x2a\x0a\x20\x2a\x20\x4f\x6e\x6c\x79\x20\x74\x72\x79\x20\x74\x6f\x20\x69\x6e\x63\x6c\x75\x64\x65\x20\x67\x73\x6c\x69\x73\x74\x2e\x68\x20\x69\x66\x20\x6e\x6f\x74\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x69\x6e\x63\x6c\x75\x64\x65\x64\x20\x76\x69\x61\x20\x67\x6c\x69\x62\x2e\x68\x2c\x0a\x20\x2a\x20\x73\x6f\x20\x74\x68\x61\x74\x20\x69\x74\x65\x6d\x73\x20\x75\x73\x69\x6e\x67\x20\x67\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x2e\x68\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x6f\x66\x20\x47\x4c\x69\x62\x20\x28\x73\x75\x63\x68\x20\x61\x73\x0a\x20\x2a\x20\x47\x52\x65\x73\x6f\x75\x72\x63\x65\x73\x29\x20\x63\x6f\x6e\x74\x69\x6e\x75\x65\x20\x74\x6f\x20\x62\x75\x69\x6c\x64\x20\x70\x72\x6f\x70\x65\x72\x6c\x79\x2e\x0a\x20\x2a\x2f\x0a\x23\x69\x66\x6e\x64\x65\x66\x20\x5f\x5f\x47\x5f\x4c\x49\x42\x5f\x48\x5f\x5f\x0a\x23\x69\x6e\x63\x6c\x75\x64\x65\x20\x22\x67\x73\x6c\x69\x73\x74\x2e\x68\x22\x0a\x23\x65\x6e\x64\x69\x66\x0a\x0a\x23\x69\x6e\x63\x6c\x75\x64\x65\x20\x3c\x73\x74\x64\x6c\x69\x62\x2e\x68\x3e\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x48\x41\x53\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x53\x20\x31\x0a\x0a\x2f\x2a\x20\x57\x65\x20\x64\x6f\x20\x73\x6f\x6d\x65\x20\x77\x65\x69\x72\x64\x20\x74\x68\x69\x6e\x67\x73\x20\x74\x6f\x20\x61\x76\x6f\x69\x64\x20\x74\x68\x65\x20\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x73\x20\x62\x65\x69\x6e\x67\x20\x6f\x70\x74\x69\x6d\x69\x7a\x65\x64\x0a\x20\x2a\x20\x61\x77\x61\x79\x20\x6f\x6e\x20\x56\x53\x32\x30\x31\x35\x20\x69\x66\x20\x57\x68\x6f\x6c\x65\x50\x72\x6f\x67\x72\x61\x6d\x4f\x70\x74\x69\x6d\x69\x7a\x61\x74\x69\x6f\x6e\x20\x69\x73\x20\x65\x6e\x61\x62\x6c\x65\x64\x2e\x20\x46\x69\x72\x73\x74\x20\x77\x65\x0a\x20\x2a\x20\x6d\x61\x6b\x65\x20\x61\x20\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x20\x74\x6f\x20\x74\x68\x65\x20\x61\x72\x72\x61\x79\x20\x66\x72\x6f\x6d\x20\x74\x68\x65\x20\x77\x72\x61\x70\x70\x65\x72\x20\x74\x6f\x20\x6d\x61\x6b\x65\x20\x73\x75\x72\x65\x20\x69\x74\x73\x0a\x20\x2a\x20\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x73\x2e\x20\x54\x68\x65\x6e\x20\x77\x65\x20\x75\x73\x65\x20\x61\x20\x70\x72\x61\x67\x6d\x61\x20\x74\x6f\x20\x6d\x61\x6b\x65\x20\x73\x75\x72\x65\x20\x74\x68\x65\x20\x77\x72\x61\x70\x70\x65\x72\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x0a\x20\x2a\x20\x73\x79\x6d\x62\x6f\x6c\x20\x69\x73\x20\x61\x6c\x77\x61\x79\x73\x20\x69\x6e\x63\x6c\x75\x64\x65\x64\x20\x61\x74\x20\x74\x68\x65\x20\x6c\x69\x6e\x6b\x20\x73\x74\x61\x67\x65\x2e\x20\x41\x6c\x73\x6f\x2c\x20\x74\x68\x65\x20\x73\x79\x6d\x62\x6f\x6c\x73\x0a\x20\x2a\x20\x6e\x65\x65\x64\x20\x74\x6f\x20\x62\x65\x20\x65\x78\x74\x65\x72\x6e\x20\x28\x62\x75\x74\x20\x6e\x6f\x74\x20\x64\x6c\x6c\x65\x78\x70\x6f\x72\x74\x29\x2c\x20\x65\x76\x65\x6e\x20\x74\x68\x6f\x75\x67\x68\x20\x74\x68\x65\x79\x20\x61\x72\x65\x20\x6e\x6f\x74\x0a\x20\x2a\x20\x72\x65\x61\x6c\x6c\x79\x20\x75\x73\x65\x64\x20\x66\x72\x6f\x6d\x20\x61\x6e\x6f\x74\x68\x65\x72\x20\x6f\x62\x6a\x65\x63\x74\x20\x66\x69\x6c\x65\x2e\x0a\x20\x2a\x2f\x0a\x0a\x2f\x2a\x20\x57\x65\x20\x6e\x65\x65\x64\x20\x74\x6f\x20\x61\x63\x63\x6f\x75\x6e\x74\x20\x66\x6f\x72\x20\x64\x69\x66\x66\x65\x72\x65\x6e\x63\x65\x73\x20\x62\x65\x74\x77\x65\x65\x6e\x20\x74\x68\x65\x20\x6d\x61\x6e\x67\x6c\x69\x6e\x67\x20\x6f\x66\x20\x73\x79\x6d\x62\x6f\x6c\x73\x0a\x20\x2a\x20\x66\x6f\x72\x20\x78\x38\x36\x20\x61\x6e\x64\x20\x78\x36\x34\x2f\x41\x52\x4d\x2f\x41\x52\x4d\x36\x34\x20\x70\x72\x6f\x67\x72\x61\x6d\x73\x2c\x20\x61\x73\x20\x73\x79\x6d\x62\x6f\x6c\x73\x20\x6f\x6e\x20\x78\x38\x36\x20\x61\x72\x65\x20\x70\x72\x65\x66\x69\x78\x65\x64\x0a\x20\x2a\x20\x77\x69\x74\x68\x20\x61\x6e\x20\x75\x6e\x64\x65\x72\x73\x63\x6f\x72\x65\x20\x62\x75\x74\x20\x73\x79\x6d\x62\x6f\x6c\x73\x20\x6f\x6e\x20\x78\x36\x34\x2f\x41\x52\x4d\x2f\x41\x52\x4d\x36\x34\x20\x61\x72\x65\x20\x6e\x6f\x74\x2e\x0a\x20\x2a\x2f\x0a\x23\x69\x66\x64\x65\x66\x20\x5f\x4d\x5f\x49\x58\x38\x36\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x4d\x53\x56\x43\x5f\x53\x59\x4d\x42\x4f\x4c\x5f\x50\x52\x45\x46\x49\x58\x20\x22\x5f\x22\x0a\x23\x65\x6c\x73\x65\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x4d\x53\x56\x43\x5f\x53\x59\x4d\x42\x4f\x4c\x5f\x50\x52\x45\x46\x49\x58\x20\x22\x22\x0a\x23\x65\x6e\x64\x69\x66\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x28\x5f\x66\x75\x6e\x63\x29\x20\x47\x5f\x4d\x53\x56\x43\x5f\x43\x54\x4f\x52\x20\x28\x5f\x66\x75\x6e\x63\x2c\x20\x47\x5f\x4d\x53\x56\x43\x5f\x53\x59\x4d\x42\x4f\x4c\x5f\x50\x52\x45\x46\x49\x58\x29\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x44\x45\x53\x54\x52\x55\x43\x54\x4f\x52\x28\x5f\x66\x75\x6e\x63\x29\x20\x47\x5f\x4d\x53\x56\x43\x5f\x44\x54\x4f\x52\x20\x28\x5f\x66\x75\x6e\x63\x2c\x20\x47\x5f\x4d\x53\x56\x43\x5f\x53\x59\x4d\x42\x4f\x4c\x5f\x50\x52\x45\x46\x49\x58\x29\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x4d\x53\x56\x43\x5f\x43\x54\x4f\x52\x28\x5f\x66\x75\x6e\x63\x2c\x5f\x73\x79\x6d\x5f\x70\x72\x65\x66\x69\x78\x29\x20\x5c\x0a\x20\x20\x73\x74\x61\x74\x69\x63\x20\x76\x6f\x69\x64\x20\x5f\x66\x75\x6e\x63\x28\x76\x6f\x69\x64\x29\x3b\x20\x5c\x0a\x20\x20\x65\x78\x74\x65\x72\x6e\x20\x69\x6e\x74\x20\x28\x2a\x20\x5f\x61\x72\x72\x61\x79\x20\x23\x23\x20\x5f\x66\x75\x6e\x63\x29\x28\x76\x6f\x69\x64\x29\x3b\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5c\x0a\x20\x20\x69\x6e\x74\x20\x5f\x66\x75\x6e\x63\x20\x23\x23\x20\x5f\x77\x72\x61\x70\x70\x65\x72\x28\x76\x6f\x69\x64\x29\x20\x7b\x20\x5f\x66\x75\x6e\x63\x28\x29\x3b\x20\x67\x5f\x73\x6c\x69\x73\x74\x5f\x66\x69\x6e\x64\x20\x28\x4e\x55\x4c\x4c\x2c\x20\x20\x5f\x61\x72\x72\x61\x79\x20\x23\x23\x20\x5f\x66\x75\x6e\x63\x29\x3b\x20\x72\x65\x74\x75\x72\x6e\x20\x30\x3b\x20\x7d\x20\x5c\x0a\x20\x20\x5f\x5f\x70\x72\x61\x67\x6d\x61\x28\x63\x6f\x6d\x6d\x65\x6e\x74\x28\x6c\x69\x6e\x6b\x65\x72\x2c\x22\x2f\x69\x6e\x63\x6c\x75\x64\x65\x3a\x22\x20\x5f\x73\x79\x6d\x5f\x70\x72\x65\x66\x69\x78\x20\x23\x20\x5f\x66\x75\x6e\x63\x20\x22\x5f\x77\x72\x61\x70\x70\x65\x72\x22\x29\x29\x20\x5c\x0a\x20\x20\x5f\x5f\x70\x72\x61\x67\x6d\x61\x28\x73\x65\x63\x74\x69\x6f\x6e\x28\x22\x2e\x43\x52\x54\x24\x58\x43\x55\x22\x2c\x72\x65\x61\x64\x29\x29\x20\x5c\x0a\x20\x20\x5f\x5f\x64\x65\x63\x6c\x73\x70\x65\x63\x28\x61\x6c\x6c\x6f\x63\x61\x74\x65\x28\x22\x2e\x43\x52\x54\x24\x58\x43\x55\x22\x29\x29\x20\x69\x6e\x74\x20\x28\x2a\x20\x5f\x61\x72\x72\x61\x79\x20\x23\x23\x20\x5f\x66\x75\x6e\x63\x29\x28\x76\x6f\x69\x64\x29\x20\x3d\x20\x5f\x66\x75\x6e\x63\x20\x23\x23\x20\x5f\x77\x72\x61\x70\x70\x65\x72\x3b\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x4d\x53\x56\x43\x5f\x44\x54\x4f\x52\x28\x5f\x66\x75\x6e\x63\x2c\x5f\x73\x79\x6d\x5f\x70\x72\x65\x66\x69\x78\x29\x20\x5c\x0a\x20\x20\x73\x74\x61\x74\x69\x63\x20\x76\x6f\x69\x64\x20\x5f\x66\x75\x6e\x63\x28\x76\x6f\x69\x64\x29\x3b\x20\x5c\x0a\x20\x20\x65\x78\x74\x65\x72\x6e\x20\x69\x6e\x74\x20\x28\x2a\x20\x5f\x61\x72\x72\x61\x79\x20\x23\x23\x20\x5f\x66\x75\x6e\x63\x29\x28\x76\x6f\x69\x64\x29\x3b\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5c\x0a\x20\x20\x69\x6e\x74\x20\x5f\x66\x75\x6e\x63\x20\x23\x23\x20\x5f\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x28\x76\x6f\x69\x64\x29\x20\x7b\x20\x61\x74\x65\x78\x69\x74\x20\x28\x5f\x66\x75\x6e\x63\x29\x3b\x20\x67\x5f\x73\x6c\x69\x73\x74\x5f\x66\x69\x6e\x64\x20\x28\x4e\x55\x4c\x4c\x2c\x20\x20\x5f\x61\x72\x72\x61\x79\x20\x23\x23\x20\x5f\x66\x75\x6e\x63\x29\x3b\x20\x72\x65\x74\x75\x72\x6e\x20\x30\x3b\x20\x7d\x20\x5c\x0a\x20\x20\x20\x5f\x5f\x70\x72\x61\x67\x6d\x61\x28\x63\x6f\x6d\x6d\x65\x6e\x74\x28\x6c\x69\x6e\x6b\x65\x72\x2c\x22\x2f\x69\x6e\x63\x6c\x75\x64\x65\x3a\x22\x20\x5f\x73\x79\x6d\x5f\x70\x72\x65\x66\x69\x78\x20\x23\x20\x5f\x66\x75\x6e\x63\x20\x22\x5f\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x22\x29\x29\x20\x5c\x0a\x20\x20\x5f\x5f\x70\x72\x61\x67\x6d\x61\x28\x73\x65\x63\x74\x69\x6f\x6e\x28\x22\x2e\x43\x52\x54\x24\x58\x43\x55\x22\x2c\x72\x65\x61\x64\x29\x29\x20\x5c\x0a\x20\x20\x5f\x5f\x64\x65\x63\x6c\x73\x70\x65\x63\x28\x61\x6c\x6c\x6f\x63\x61\x74\x65\x28\x22\x2e\x43\x52\x54\x24\x58\x43\x55\x22\x29\x29\x20\x69\x6e\x74\x20\x28\x2a\x20\x5f\x61\x72\x72\x61\x79\x20\x23\x23\x20\x5f\x66\x75\x6e\x63\x29\x28\x76\x6f\x69\x64\x29\x20\x3d\x20\x5f\x66\x75\x6e\x63\x20\x23\x23\x20\x5f\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x3b\x0a\x0a\x23\x65\x6c\x69\x66\x20\x64\x65\x66\x69\x6e\x65\x64\x20\x28\x5f\x4d\x53\x43\x5f\x56\x45\x52\x29\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x48\x41\x53\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x53\x20\x31\x0a\x0a\x2f\x2a\x20\x50\x72\x65\x20\x56\x69\x73\x75\x61\x6c\x20\x73\x74\x75\x64\x69\x6f\x20\x32\x30\x30\x38\x20\x6d\x75\x73\x74\x20\x75\x73\x65\x20\x23\x70\x72\x61\x67\x6d\x61\x20\x73\x65\x63\x74\x69\x6f\x6e\x20\x2a\x2f\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x4e\x45\x45\x44\x53\x5f\x50\x52\x41\x47\x4d\x41\x20\x31\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x44\x45\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x4e\x45\x45\x44\x53\x5f\x50\x52\x41\x47\x4d\x41\x20\x31\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x50\x52\x41\x47\x4d\x41\x5f\x41\x52\x47\x53\x28\x5f\x66\x75\x6e\x63\x29\x20\x5c\x0a\x20\x20\x73\x65\x63\x74\x69\x6f\x6e\x28\x22\x2e\x43\x52\x54\x24\x58\x43\x55\x22\x2c\x72\x65\x61\x64\x29\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x28\x5f\x66\x75\x6e\x63\x29\x20\x5c\x0a\x20\x20\x73\x74\x61\x74\x69\x63\x20\x76\x6f\x69\x64\x20\x5f\x66\x75\x6e\x63\x28\x76\x6f\x69\x64\x29\x3b\x20\x5c\x0a\x20\x20\x73\x74\x61\x74\x69\x63\x20\x69\x6e\x74\x20\x5f\x66\x75\x6e\x63\x20\x23\x23\x20\x5f\x77\x72\x61\x70\x70\x65\x72\x28\x76\x6f\x69\x64\x29\x20\x7b\x20\x5f\x66\x75\x6e\x63\x28\x29\x3b\x20\x72\x65\x74\x75\x72\x6e\x20\x30\x3b\x20\x7d\x20\x5c\x0a\x20\x20\x5f\x5f\x64\x65\x63\x6c\x73\x70\x65\x63\x28\x61\x6c\x6c\x6f\x63\x61\x74\x65\x28\x22\x2e\x43\x52\x54\x24\x58\x43\x55\x22\x29\x29\x20\x73\x74\x61\x74\x69\x63\x20\x69\x6e\x74\x20\x28\x2a\x70\x29\x28\x76\x6f\x69\x64\x29\x20\x3d\x20\x5f\x66\x75\x6e\x63\x20\x23\x23\x20\x5f\x77\x72\x61\x70\x70\x65\x72\x3b\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x44\x45\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x50\x52\x41\x47\x4d\x41\x5f\x41\x52\x47\x53\x28\x5f\x66\x75\x6e\x63\x29\x20\x5c\x0a\x20\x20\x73\x65\x63\x74\x69\x6f\x6e\x28\x22\x2e\x43\x52\x54\x24\x58\x43\x55\x22\x2c\x72\x65\x61\x64\x29\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x44\x45\x53\x54\x52\x55\x43\x54\x4f\x52\x28\x5f\x66\x75\x6e\x63\x29\x20\x5c\x0a\x20\x20\x73\x74\x61\x74\x69\x63\x20\x76\x6f\x69\x64\x20\x5f\x66\x75\x6e\x63\x28\x76\x6f\x69\x64\x29\x3b\x20\x5c\x0a\x20\x20\x73\x74\x61\x74\x69\x63\x20\x69\x6e\x74\x20\x5f\x66\x75\x6e\x63\x20\x23\x23\x20\x5f\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x28\x76\x6f\x69\x64\x29\x20\x7b\x20\x61\x74\x65\x78\x69\x74\x20\x28\x5f\x66\x75\x6e\x63\x29\x3b\x20\x72\x65\x74\x75\x72\x6e\x20\x30\x3b\x20\x7d\x20\x5c\x0a\x20\x20\x5f\x5f\x64\x65\x63\x6c\x73\x70\x65\x63\x28\x61\x6c\x6c\x6f\x63\x61\x74\x65\x28\x22\x2e\x43\x52\x54\x24\x58\x43\x55\x22\x29\x29\x20\x73\x74\x61\x74\x69\x63\x20\x69\x6e\x74\x20\x28\x2a\x20\x5f\x61\x72\x72\x61\x79\x20\x23\x23\x20\x5f\x66\x75\x6e\x63\x29\x28\x76\x6f\x69\x64\x29\x20\x3d\x20\x5f\x66\x75\x6e\x63\x20\x23\x23\x20\x5f\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x3b\x0a\x0a\x23\x65\x6c\x69\x66\x20\x64\x65\x66\x69\x6e\x65\x64\x28\x5f\x5f\x53\x55\x4e\x50\x52\x4f\x5f\x43\x29\x0a\x0a\x2f\x2a\x20\x54\x68\x69\x73\x20\x69\x73\x20\x6e\x6f\x74\x20\x74\x65\x73\x74\x65\x64\x2c\x20\x62\x75\x74\x20\x69\x20\x62\x65\x6c\x69\x65\x76\x65\x20\x69\x74\x20\x73\x68\x6f\x75\x6c\x64\x20\x77\x6f\x72\x6b\x2c\x20\x62\x61\x73\x65\x64\x20\x6f\x6e\x3a\x0a\x20\x2a\x20\x68\x74\x74\x70\x3a\x2f\x2f\x6f\x70\x65\x6e\x73\x6f\x75\x72\x63\x65\x2e\x61\x70\x70\x6c\x65\x2e\x63\x6f\x6d\x2f\x73\x6f\x75\x72\x63\x65\x2f\x4f\x70\x65\x6e\x53\x53\x4c\x30\x39\x38\x2f\x4f\x70\x65\x6e\x53\x53\x4c\x30\x39\x38\x2d\x33\x35\x2f\x73\x72\x63\x2f\x66\x69\x70\x73\x2f\x66\x69\x70\x73\x5f\x70\x72\x65\x6d\x61\x69\x6e\x2e\x63\x0a\x20\x2a\x2f\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x48\x41\x53\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x53\x20\x31\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x4e\x45\x45\x44\x53\x5f\x50\x52\x41\x47\x4d\x41\x20\x31\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x44\x45\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x4e\x45\x45\x44\x53\x5f\x50\x52\x41\x47\x4d\x41\x20\x31\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x50\x52\x41\x47\x4d\x41\x5f\x41\x52\x47\x53\x28\x5f\x66\x75\x6e\x63\x29\x20\x5c\x0a\x20\x20\x69\x6e\x69\x74\x28\x5f\x66\x75\x6e\x63\x29\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x28\x5f\x66\x75\x6e\x63\x29\x20\x5c\x0a\x20\x20\x73\x74\x61\x74\x69\x63\x20\x76\x6f\x69\x64\x20\x5f\x66\x75\x6e\x63\x28\x76\x6f\x69\x64\x29\x3b\x0a\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x44\x45\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x50\x52\x41\x47\x4d\x41\x5f\x41\x52\x47\x53\x28\x5f\x66\x75\x6e\x63\x29\x20\x5c\x0a\x20\x20\x66\x69\x6e\x69\x28\x5f\x66\x75\x6e\x63\x29\x0a\x23\x64\x65\x66\x69\x6e\x65\x20\x47\x5f\x44\x45\x46\x49\x4e\x45\x5f\x44\x45\x53\x54\x52\x55\x43\x54\x4f\x52\x28\x5f\x66\x75\x6e\x63\x29\x20\x5c\x0a\x20\x20\x73\x74\x61\x74\x69\x63\x20\x76\x6f\x69\x64\x20\x5f\x66\x75\x6e\x63\x28\x76\x6f\x69\x64\x29\x3b\x0a\x0a\x23\x65\x6c\x73\x65\x0a\x0a\x2f\x2a\x20\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72\x73\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x66\x6f\x72\x20\x74\x68\x69\x73\x20\x63\x6f\x6d\x70\x69\x6c\x65\x72\x20\x2a\x2f\x0a\x0a\x23\x65\x6e\x64\x69\x66\x0a\x0a\x23\x65\x6e\x64\x69\x66\x20\x2f\x2a\x20\x5f\x5f\x47\x54\x4b\x5f\x44\x4f\x43\x5f\x49\x47\x4e\x4f\x52\x45\x5f\x5f\x20\x2a\x2f\x0a\x23\x65\x6e\x64\x69\x66\x20\x2f\x2a\x20\x5f\x5f\x47\x5f\x43\x4f\x4e\x53\x54\x52\x55\x43\x54\x4f\x52\x5f\x48\x5f\x5f\x20\x2a\x2f\x0a";
diff --git a/gio/gdbus-daemon-generated.c b/gio/gdbus-daemon-generated.c
new file mode 100644
index 0000000..24706b6
--- /dev/null
+++ b/gio/gdbus-daemon-generated.c
@@ -0,0 +1,4339 @@
+/*
+ * This file is generated by gdbus-codegen, do not modify it.
+ *
+ * The license of this code is the same as for the D-Bus interface description
+ * it was derived from. Note that it links to GLib, so must comply with the
+ * LGPL linking clauses.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "gdbus-daemon-generated.h"
+
+#include <string.h>
+#ifdef G_OS_UNIX
+#  include <gio/gunixfdlist.h>
+#endif
+
+typedef struct
+{
+  GDBusArgInfo parent_struct;
+  gboolean use_gvariant;
+} _ExtendedGDBusArgInfo;
+
+typedef struct
+{
+  GDBusMethodInfo parent_struct;
+  const gchar *signal_name;
+  gboolean pass_fdlist;
+} _ExtendedGDBusMethodInfo;
+
+typedef struct
+{
+  GDBusSignalInfo parent_struct;
+  const gchar *signal_name;
+} _ExtendedGDBusSignalInfo;
+
+typedef struct
+{
+  GDBusPropertyInfo parent_struct;
+  const gchar *hyphen_name;
+  guint use_gvariant : 1;
+  guint emits_changed_signal : 1;
+} _ExtendedGDBusPropertyInfo;
+
+typedef struct
+{
+  GDBusInterfaceInfo parent_struct;
+  const gchar *hyphen_name;
+} _ExtendedGDBusInterfaceInfo;
+
+typedef struct
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  guint prop_id;
+  GValue orig_value; /* the value before the change */
+} ChangedProperty;
+
+static void
+_changed_property_free (ChangedProperty *data)
+{
+  g_value_unset (&data->orig_value);
+  g_free (data);
+}
+
+static gboolean
+_g_strv_equal0 (gchar **a, gchar **b)
+{
+  gboolean ret = FALSE;
+  guint n;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  if (g_strv_length (a) != g_strv_length (b))
+    goto out;
+  for (n = 0; a[n] != NULL; n++)
+    if (g_strcmp0 (a[n], b[n]) != 0)
+      goto out;
+  ret = TRUE;
+out:
+  return ret;
+}
+
+static gboolean
+_g_variant_equal0 (GVariant *a, GVariant *b)
+{
+  gboolean ret = FALSE;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  ret = g_variant_equal (a, b);
+out:
+  return ret;
+}
+
+G_GNUC_UNUSED static gboolean
+_g_value_equal (const GValue *a, const GValue *b)
+{
+  gboolean ret = FALSE;
+  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
+  switch (G_VALUE_TYPE (a))
+    {
+      case G_TYPE_BOOLEAN:
+        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
+        break;
+      case G_TYPE_UCHAR:
+        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
+        break;
+      case G_TYPE_INT:
+        ret = (g_value_get_int (a) == g_value_get_int (b));
+        break;
+      case G_TYPE_UINT:
+        ret = (g_value_get_uint (a) == g_value_get_uint (b));
+        break;
+      case G_TYPE_INT64:
+        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
+        break;
+      case G_TYPE_UINT64:
+        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
+        break;
+      case G_TYPE_DOUBLE:
+        {
+          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
+          gdouble da = g_value_get_double (a);
+          gdouble db = g_value_get_double (b);
+          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
+        }
+        break;
+      case G_TYPE_STRING:
+        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
+        break;
+      case G_TYPE_VARIANT:
+        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
+        break;
+      default:
+        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
+          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
+        else
+          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
+        break;
+    }
+  return ret;
+}
+
+/* ------------------------------------------------------------------------
+ * Code for interface org.freedesktop.DBus
+ * ------------------------------------------------------------------------
+ */
+
+/**
+ * SECTION:_GFreedesktopDBus
+ * @title: _GFreedesktopDBus
+ * @short_description: Generated C code for the org.freedesktop.DBus D-Bus interface
+ *
+ * This section contains code for working with the <link linkend="gdbus-interface-org-freedesktop-DBus.top_of_page">org.freedesktop.DBus</link> D-Bus interface in C.
+ */
+
+/* ---- Introspection data for org.freedesktop.DBus ---- */
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_hello_OUT_ARG_assigned_name =
+{
+  {
+    -1,
+    (gchar *) "assigned_name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_hello_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_hello_OUT_ARG_assigned_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_hello =
+{
+  {
+    -1,
+    (gchar *) "Hello",
+    NULL,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_hello_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-hello",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_request_name_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_request_name_IN_ARG_flags =
+{
+  {
+    -1,
+    (gchar *) "flags",
+    (gchar *) "u",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_request_name_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_request_name_IN_ARG_name.parent_struct,
+  &__g_freedesktop_dbus_method_info_request_name_IN_ARG_flags.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_request_name_OUT_ARG_value =
+{
+  {
+    -1,
+    (gchar *) "value",
+    (gchar *) "u",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_request_name_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_request_name_OUT_ARG_value.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_request_name =
+{
+  {
+    -1,
+    (gchar *) "RequestName",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_request_name_IN_ARG_pointers,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_request_name_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-request-name",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_release_name_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_release_name_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_release_name_IN_ARG_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_release_name_OUT_ARG_value =
+{
+  {
+    -1,
+    (gchar *) "value",
+    (gchar *) "u",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_release_name_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_release_name_OUT_ARG_value.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_release_name =
+{
+  {
+    -1,
+    (gchar *) "ReleaseName",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_release_name_IN_ARG_pointers,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_release_name_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-release-name",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_start_service_by_name_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_start_service_by_name_IN_ARG_flags =
+{
+  {
+    -1,
+    (gchar *) "flags",
+    (gchar *) "u",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_start_service_by_name_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_start_service_by_name_IN_ARG_name.parent_struct,
+  &__g_freedesktop_dbus_method_info_start_service_by_name_IN_ARG_flags.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_start_service_by_name_OUT_ARG_value =
+{
+  {
+    -1,
+    (gchar *) "value",
+    (gchar *) "u",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_start_service_by_name_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_start_service_by_name_OUT_ARG_value.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_start_service_by_name =
+{
+  {
+    -1,
+    (gchar *) "StartServiceByName",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_start_service_by_name_IN_ARG_pointers,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_start_service_by_name_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-start-service-by-name",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_name_has_owner_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_name_has_owner_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_name_has_owner_IN_ARG_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_name_has_owner_OUT_ARG_has_owner =
+{
+  {
+    -1,
+    (gchar *) "has_owner",
+    (gchar *) "b",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_name_has_owner_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_name_has_owner_OUT_ARG_has_owner.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_name_has_owner =
+{
+  {
+    -1,
+    (gchar *) "NameHasOwner",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_name_has_owner_IN_ARG_pointers,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_name_has_owner_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-name-has-owner",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_list_names_OUT_ARG_names =
+{
+  {
+    -1,
+    (gchar *) "names",
+    (gchar *) "as",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_list_names_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_list_names_OUT_ARG_names.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_list_names =
+{
+  {
+    -1,
+    (gchar *) "ListNames",
+    NULL,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_list_names_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-list-names",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_list_activatable_names_OUT_ARG_activatable_names =
+{
+  {
+    -1,
+    (gchar *) "activatable_names",
+    (gchar *) "as",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_list_activatable_names_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_list_activatable_names_OUT_ARG_activatable_names.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_list_activatable_names =
+{
+  {
+    -1,
+    (gchar *) "ListActivatableNames",
+    NULL,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_list_activatable_names_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-list-activatable-names",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_add_match_IN_ARG_rule =
+{
+  {
+    -1,
+    (gchar *) "rule",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_add_match_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_add_match_IN_ARG_rule.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_add_match =
+{
+  {
+    -1,
+    (gchar *) "AddMatch",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_add_match_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-add-match",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_remove_match_IN_ARG_rule =
+{
+  {
+    -1,
+    (gchar *) "rule",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_remove_match_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_remove_match_IN_ARG_rule.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_remove_match =
+{
+  {
+    -1,
+    (gchar *) "RemoveMatch",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_remove_match_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-remove-match",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_get_name_owner_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_get_name_owner_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_get_name_owner_IN_ARG_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_get_name_owner_OUT_ARG_unique_name =
+{
+  {
+    -1,
+    (gchar *) "unique_name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_get_name_owner_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_get_name_owner_OUT_ARG_unique_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_get_name_owner =
+{
+  {
+    -1,
+    (gchar *) "GetNameOwner",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_get_name_owner_IN_ARG_pointers,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_get_name_owner_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-get-name-owner",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_list_queued_owners_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_list_queued_owners_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_list_queued_owners_IN_ARG_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_list_queued_owners_OUT_ARG_queued_owners =
+{
+  {
+    -1,
+    (gchar *) "queued_owners",
+    (gchar *) "as",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_list_queued_owners_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_list_queued_owners_OUT_ARG_queued_owners.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_list_queued_owners =
+{
+  {
+    -1,
+    (gchar *) "ListQueuedOwners",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_list_queued_owners_IN_ARG_pointers,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_list_queued_owners_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-list-queued-owners",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_get_connection_unix_user_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_get_connection_unix_user_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_get_connection_unix_user_IN_ARG_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_get_connection_unix_user_OUT_ARG_uid =
+{
+  {
+    -1,
+    (gchar *) "uid",
+    (gchar *) "u",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_get_connection_unix_user_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_get_connection_unix_user_OUT_ARG_uid.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_get_connection_unix_user =
+{
+  {
+    -1,
+    (gchar *) "GetConnectionUnixUser",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_get_connection_unix_user_IN_ARG_pointers,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_get_connection_unix_user_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-get-connection-unix-user",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_get_connection_unix_process_id_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_get_connection_unix_process_id_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_get_connection_unix_process_id_IN_ARG_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_get_connection_unix_process_id_OUT_ARG_pid =
+{
+  {
+    -1,
+    (gchar *) "pid",
+    (gchar *) "u",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_get_connection_unix_process_id_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_get_connection_unix_process_id_OUT_ARG_pid.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_get_connection_unix_process_id =
+{
+  {
+    -1,
+    (gchar *) "GetConnectionUnixProcessID",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_get_connection_unix_process_id_IN_ARG_pointers,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_get_connection_unix_process_id_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-get-connection-unix-process-id",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_get_connection_selinux_security_context_IN_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_get_connection_selinux_security_context_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_get_connection_selinux_security_context_IN_ARG_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_get_connection_selinux_security_context_OUT_ARG_security_context =
+{
+  {
+    -1,
+    (gchar *) "security_context",
+    (gchar *) "ay",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_get_connection_selinux_security_context_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_get_connection_selinux_security_context_OUT_ARG_security_context.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_get_connection_selinux_security_context =
+{
+  {
+    -1,
+    (gchar *) "GetConnectionSELinuxSecurityContext",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_get_connection_selinux_security_context_IN_ARG_pointers,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_get_connection_selinux_security_context_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-get-connection-selinux-security-context",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_update_activation_environment_IN_ARG_environment =
+{
+  {
+    -1,
+    (gchar *) "environment",
+    (gchar *) "a{ss}",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_update_activation_environment_IN_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_update_activation_environment_IN_ARG_environment.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_update_activation_environment =
+{
+  {
+    -1,
+    (gchar *) "UpdateActivationEnvironment",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_update_activation_environment_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-update-activation-environment",
+  FALSE
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_reload_config =
+{
+  {
+    -1,
+    (gchar *) "ReloadConfig",
+    NULL,
+    NULL,
+    NULL
+  },
+  "handle-reload-config",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_method_info_get_id_OUT_ARG_unique_id =
+{
+  {
+    -1,
+    (gchar *) "unique_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_method_info_get_id_OUT_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_get_id_OUT_ARG_unique_id.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo __g_freedesktop_dbus_method_info_get_id =
+{
+  {
+    -1,
+    (gchar *) "GetId",
+    NULL,
+    (GDBusArgInfo **) &__g_freedesktop_dbus_method_info_get_id_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-get-id",
+  FALSE
+};
+
+static const GDBusMethodInfo * const __g_freedesktop_dbus_method_info_pointers[] =
+{
+  &__g_freedesktop_dbus_method_info_hello.parent_struct,
+  &__g_freedesktop_dbus_method_info_request_name.parent_struct,
+  &__g_freedesktop_dbus_method_info_release_name.parent_struct,
+  &__g_freedesktop_dbus_method_info_start_service_by_name.parent_struct,
+  &__g_freedesktop_dbus_method_info_name_has_owner.parent_struct,
+  &__g_freedesktop_dbus_method_info_list_names.parent_struct,
+  &__g_freedesktop_dbus_method_info_list_activatable_names.parent_struct,
+  &__g_freedesktop_dbus_method_info_add_match.parent_struct,
+  &__g_freedesktop_dbus_method_info_remove_match.parent_struct,
+  &__g_freedesktop_dbus_method_info_get_name_owner.parent_struct,
+  &__g_freedesktop_dbus_method_info_list_queued_owners.parent_struct,
+  &__g_freedesktop_dbus_method_info_get_connection_unix_user.parent_struct,
+  &__g_freedesktop_dbus_method_info_get_connection_unix_process_id.parent_struct,
+  &__g_freedesktop_dbus_method_info_get_connection_selinux_security_context.parent_struct,
+  &__g_freedesktop_dbus_method_info_update_activation_environment.parent_struct,
+  &__g_freedesktop_dbus_method_info_reload_config.parent_struct,
+  &__g_freedesktop_dbus_method_info_get_id.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_signal_info_name_owner_changed_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_signal_info_name_owner_changed_ARG_old_owner =
+{
+  {
+    -1,
+    (gchar *) "old_owner",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_signal_info_name_owner_changed_ARG_new_owner =
+{
+  {
+    -1,
+    (gchar *) "new_owner",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_signal_info_name_owner_changed_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_signal_info_name_owner_changed_ARG_name.parent_struct,
+  &__g_freedesktop_dbus_signal_info_name_owner_changed_ARG_old_owner.parent_struct,
+  &__g_freedesktop_dbus_signal_info_name_owner_changed_ARG_new_owner.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusSignalInfo __g_freedesktop_dbus_signal_info_name_owner_changed =
+{
+  {
+    -1,
+    (gchar *) "NameOwnerChanged",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_signal_info_name_owner_changed_ARG_pointers,
+    NULL
+  },
+  "name-owner-changed"
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_signal_info_name_lost_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_signal_info_name_lost_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_signal_info_name_lost_ARG_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusSignalInfo __g_freedesktop_dbus_signal_info_name_lost =
+{
+  {
+    -1,
+    (gchar *) "NameLost",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_signal_info_name_lost_ARG_pointers,
+    NULL
+  },
+  "name-lost"
+};
+
+static const _ExtendedGDBusArgInfo __g_freedesktop_dbus_signal_info_name_acquired_ARG_name =
+{
+  {
+    -1,
+    (gchar *) "name",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const __g_freedesktop_dbus_signal_info_name_acquired_ARG_pointers[] =
+{
+  &__g_freedesktop_dbus_signal_info_name_acquired_ARG_name.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusSignalInfo __g_freedesktop_dbus_signal_info_name_acquired =
+{
+  {
+    -1,
+    (gchar *) "NameAcquired",
+    (GDBusArgInfo **) &__g_freedesktop_dbus_signal_info_name_acquired_ARG_pointers,
+    NULL
+  },
+  "name-acquired"
+};
+
+static const GDBusSignalInfo * const __g_freedesktop_dbus_signal_info_pointers[] =
+{
+  &__g_freedesktop_dbus_signal_info_name_owner_changed.parent_struct,
+  &__g_freedesktop_dbus_signal_info_name_lost.parent_struct,
+  &__g_freedesktop_dbus_signal_info_name_acquired.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusInterfaceInfo __g_freedesktop_dbus_interface_info =
+{
+  {
+    -1,
+    (gchar *) "org.freedesktop.DBus",
+    (GDBusMethodInfo **) &__g_freedesktop_dbus_method_info_pointers,
+    (GDBusSignalInfo **) &__g_freedesktop_dbus_signal_info_pointers,
+    NULL,
+    NULL
+  },
+  "freedesktop-dbus",
+};
+
+
+/**
+ * _g_freedesktop_dbus_interface_info:
+ *
+ * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-DBus.top_of_page">org.freedesktop.DBus</link> D-Bus interface.
+ *
+ * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
+ */
+GDBusInterfaceInfo *
+_g_freedesktop_dbus_interface_info (void)
+{
+  return (GDBusInterfaceInfo *) &__g_freedesktop_dbus_interface_info.parent_struct;
+}
+
+/**
+ * _g_freedesktop_dbus_override_properties:
+ * @klass: The class structure for a #GObject derived class.
+ * @property_id_begin: The property id to assign to the first overridden property.
+ *
+ * Overrides all #GObject properties in the #_GFreedesktopDBus interface for a concrete class.
+ * The properties are overridden in the order they are defined.
+ *
+ * Returns: The last property id.
+ */
+guint
+_g_freedesktop_dbus_override_properties (GObjectClass *klass G_GNUC_UNUSED, guint property_id_begin)
+{
+  return property_id_begin - 1;
+}
+
+
+
+/**
+ * _GFreedesktopDBus:
+ *
+ * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus.top_of_page">org.freedesktop.DBus</link>.
+ */
+
+/**
+ * _GFreedesktopDBusIface:
+ * @parent_iface: The parent interface.
+ * @handle_add_match: Handler for the #_GFreedesktopDBus::handle-add-match signal.
+ * @handle_get_connection_selinux_security_context: Handler for the #_GFreedesktopDBus::handle-get-connection-selinux-security-context signal.
+ * @handle_get_connection_unix_process_id: Handler for the #_GFreedesktopDBus::handle-get-connection-unix-process-id signal.
+ * @handle_get_connection_unix_user: Handler for the #_GFreedesktopDBus::handle-get-connection-unix-user signal.
+ * @handle_get_id: Handler for the #_GFreedesktopDBus::handle-get-id signal.
+ * @handle_get_name_owner: Handler for the #_GFreedesktopDBus::handle-get-name-owner signal.
+ * @handle_hello: Handler for the #_GFreedesktopDBus::handle-hello signal.
+ * @handle_list_activatable_names: Handler for the #_GFreedesktopDBus::handle-list-activatable-names signal.
+ * @handle_list_names: Handler for the #_GFreedesktopDBus::handle-list-names signal.
+ * @handle_list_queued_owners: Handler for the #_GFreedesktopDBus::handle-list-queued-owners signal.
+ * @handle_name_has_owner: Handler for the #_GFreedesktopDBus::handle-name-has-owner signal.
+ * @handle_release_name: Handler for the #_GFreedesktopDBus::handle-release-name signal.
+ * @handle_reload_config: Handler for the #_GFreedesktopDBus::handle-reload-config signal.
+ * @handle_remove_match: Handler for the #_GFreedesktopDBus::handle-remove-match signal.
+ * @handle_request_name: Handler for the #_GFreedesktopDBus::handle-request-name signal.
+ * @handle_start_service_by_name: Handler for the #_GFreedesktopDBus::handle-start-service-by-name signal.
+ * @handle_update_activation_environment: Handler for the #_GFreedesktopDBus::handle-update-activation-environment signal.
+ * @name_acquired: Handler for the #_GFreedesktopDBus::name-acquired signal.
+ * @name_lost: Handler for the #_GFreedesktopDBus::name-lost signal.
+ * @name_owner_changed: Handler for the #_GFreedesktopDBus::name-owner-changed signal.
+ *
+ * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus.top_of_page">org.freedesktop.DBus</link>.
+ */
+
+typedef _GFreedesktopDBusIface _GFreedesktopDBusInterface;
+G_DEFINE_INTERFACE (_GFreedesktopDBus, _g_freedesktop_dbus, G_TYPE_OBJECT)
+
+static void
+_g_freedesktop_dbus_default_init (_GFreedesktopDBusIface *iface)
+{
+  /* GObject signals for incoming D-Bus method calls: */
+  /**
+   * _GFreedesktopDBus::handle-hello:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.Hello">Hello()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_hello() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-hello",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_hello),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /**
+   * _GFreedesktopDBus::handle-request-name:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   * @arg_flags: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.RequestName">RequestName()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_request_name() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-request-name",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_request_name),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    3,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_UINT);
+
+  /**
+   * _GFreedesktopDBus::handle-release-name:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.ReleaseName">ReleaseName()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_release_name() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-release-name",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_release_name),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::handle-start-service-by-name:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   * @arg_flags: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.StartServiceByName">StartServiceByName()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_start_service_by_name() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-start-service-by-name",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_start_service_by_name),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    3,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_UINT);
+
+  /**
+   * _GFreedesktopDBus::handle-name-has-owner:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.NameHasOwner">NameHasOwner()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_name_has_owner() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-name-has-owner",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_name_has_owner),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::handle-list-names:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.ListNames">ListNames()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_list_names() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-list-names",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_list_names),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /**
+   * _GFreedesktopDBus::handle-list-activatable-names:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.ListActivatableNames">ListActivatableNames()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_list_activatable_names() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-list-activatable-names",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_list_activatable_names),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /**
+   * _GFreedesktopDBus::handle-add-match:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_rule: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.AddMatch">AddMatch()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_add_match() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-add-match",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_add_match),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::handle-remove-match:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_rule: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.RemoveMatch">RemoveMatch()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_remove_match() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-remove-match",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_remove_match),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::handle-get-name-owner:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.GetNameOwner">GetNameOwner()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_get_name_owner() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-get-name-owner",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_get_name_owner),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::handle-list-queued-owners:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.ListQueuedOwners">ListQueuedOwners()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_list_queued_owners() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-list-queued-owners",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_list_queued_owners),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::handle-get-connection-unix-user:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionUnixUser">GetConnectionUnixUser()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_get_connection_unix_user() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-get-connection-unix-user",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_get_connection_unix_user),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::handle-get-connection-unix-process-id:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionUnixProcessID">GetConnectionUnixProcessID()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_get_connection_unix_process_id() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-get-connection-unix-process-id",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_get_connection_unix_process_id),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::handle-get-connection-selinux-security-context:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_name: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionSELinuxSecurityContext">GetConnectionSELinuxSecurityContext()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_get_connection_selinux_security_context() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-get-connection-selinux-security-context",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_get_connection_selinux_security_context),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::handle-update-activation-environment:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_environment: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.UpdateActivationEnvironment">UpdateActivationEnvironment()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_update_activation_environment() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-update-activation-environment",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_update_activation_environment),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);
+
+  /**
+   * _GFreedesktopDBus::handle-reload-config:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.ReloadConfig">ReloadConfig()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_reload_config() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-reload-config",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_reload_config),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /**
+   * _GFreedesktopDBus::handle-get-id:
+   * @object: A #_GFreedesktopDBus.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus.GetId">GetId()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call _g_freedesktop_dbus_complete_get_id() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-get-id",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, handle_get_id),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /* GObject signals for received D-Bus signals: */
+  /**
+   * _GFreedesktopDBus::name-owner-changed:
+   * @object: A #_GFreedesktopDBus.
+   * @arg_name: Argument.
+   * @arg_old_owner: Argument.
+   * @arg_new_owner: Argument.
+   *
+   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-freedesktop-DBus.NameOwnerChanged">"NameOwnerChanged"</link> is received.
+   *
+   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
+   */
+  g_signal_new ("name-owner-changed",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, name_owner_changed),
+    NULL,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_NONE,
+    3, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::name-lost:
+   * @object: A #_GFreedesktopDBus.
+   * @arg_name: Argument.
+   *
+   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-freedesktop-DBus.NameLost">"NameLost"</link> is received.
+   *
+   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
+   */
+  g_signal_new ("name-lost",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, name_lost),
+    NULL,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_NONE,
+    1, G_TYPE_STRING);
+
+  /**
+   * _GFreedesktopDBus::name-acquired:
+   * @object: A #_GFreedesktopDBus.
+   * @arg_name: Argument.
+   *
+   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-freedesktop-DBus.NameAcquired">"NameAcquired"</link> is received.
+   *
+   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
+   */
+  g_signal_new ("name-acquired",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (_GFreedesktopDBusIface, name_acquired),
+    NULL,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_NONE,
+    1, G_TYPE_STRING);
+
+}
+
+/**
+ * _g_freedesktop_dbus_emit_name_owner_changed:
+ * @object: A #_GFreedesktopDBus.
+ * @arg_name: Argument to pass with the signal.
+ * @arg_old_owner: Argument to pass with the signal.
+ * @arg_new_owner: Argument to pass with the signal.
+ *
+ * Emits the <link linkend="gdbus-signal-org-freedesktop-DBus.NameOwnerChanged">"NameOwnerChanged"</link> D-Bus signal.
+ */
+void
+_g_freedesktop_dbus_emit_name_owner_changed (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name,
+    const gchar *arg_old_owner,
+    const gchar *arg_new_owner)
+{
+  g_signal_emit_by_name (object, "name-owner-changed", arg_name, arg_old_owner, arg_new_owner);
+}
+
+/**
+ * _g_freedesktop_dbus_emit_name_lost:
+ * @object: A #_GFreedesktopDBus.
+ * @arg_name: Argument to pass with the signal.
+ *
+ * Emits the <link linkend="gdbus-signal-org-freedesktop-DBus.NameLost">"NameLost"</link> D-Bus signal.
+ */
+void
+_g_freedesktop_dbus_emit_name_lost (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name)
+{
+  g_signal_emit_by_name (object, "name-lost", arg_name);
+}
+
+/**
+ * _g_freedesktop_dbus_emit_name_acquired:
+ * @object: A #_GFreedesktopDBus.
+ * @arg_name: Argument to pass with the signal.
+ *
+ * Emits the <link linkend="gdbus-signal-org-freedesktop-DBus.NameAcquired">"NameAcquired"</link> D-Bus signal.
+ */
+void
+_g_freedesktop_dbus_emit_name_acquired (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name)
+{
+  g_signal_emit_by_name (object, "name-acquired", arg_name);
+}
+
+/**
+ * _g_freedesktop_dbus_call_hello:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.Hello">Hello()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_hello_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_hello_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_hello (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "Hello",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_hello_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_assigned_name: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_hello().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_hello().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_hello_finish (
+    _GFreedesktopDBus *proxy,
+    gchar **out_assigned_name,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_assigned_name);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_hello_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_assigned_name: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.Hello">Hello()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_hello() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_hello_sync (
+    _GFreedesktopDBus *proxy,
+    gchar **out_assigned_name,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "Hello",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_assigned_name);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_request_name:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @arg_flags: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.RequestName">RequestName()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_request_name_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_request_name_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_request_name (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint arg_flags,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "RequestName",
+    g_variant_new ("(su)",
+                   arg_name,
+                   arg_flags),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_request_name_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_value: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_request_name().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_request_name().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_request_name_finish (
+    _GFreedesktopDBus *proxy,
+    guint *out_value,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_value);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_request_name_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @arg_flags: Argument to pass with the method invocation.
+ * @out_value: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.RequestName">RequestName()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_request_name() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_request_name_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint arg_flags,
+    guint *out_value,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "RequestName",
+    g_variant_new ("(su)",
+                   arg_name,
+                   arg_flags),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_value);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_release_name:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.ReleaseName">ReleaseName()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_release_name_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_release_name_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_release_name (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "ReleaseName",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_release_name_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_value: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_release_name().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_release_name().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_release_name_finish (
+    _GFreedesktopDBus *proxy,
+    guint *out_value,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_value);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_release_name_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @out_value: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.ReleaseName">ReleaseName()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_release_name() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_release_name_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint *out_value,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "ReleaseName",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_value);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_start_service_by_name:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @arg_flags: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.StartServiceByName">StartServiceByName()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_start_service_by_name_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_start_service_by_name_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_start_service_by_name (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint arg_flags,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "StartServiceByName",
+    g_variant_new ("(su)",
+                   arg_name,
+                   arg_flags),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_start_service_by_name_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_value: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_start_service_by_name().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_start_service_by_name().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_start_service_by_name_finish (
+    _GFreedesktopDBus *proxy,
+    guint *out_value,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_value);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_start_service_by_name_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @arg_flags: Argument to pass with the method invocation.
+ * @out_value: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.StartServiceByName">StartServiceByName()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_start_service_by_name() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_start_service_by_name_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint arg_flags,
+    guint *out_value,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "StartServiceByName",
+    g_variant_new ("(su)",
+                   arg_name,
+                   arg_flags),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_value);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_name_has_owner:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.NameHasOwner">NameHasOwner()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_name_has_owner_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_name_has_owner_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_name_has_owner (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "NameHasOwner",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_name_has_owner_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_has_owner: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_name_has_owner().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_name_has_owner().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_name_has_owner_finish (
+    _GFreedesktopDBus *proxy,
+    gboolean *out_has_owner,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(b)",
+                 out_has_owner);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_name_has_owner_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @out_has_owner: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.NameHasOwner">NameHasOwner()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_name_has_owner() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_name_has_owner_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    gboolean *out_has_owner,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "NameHasOwner",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(b)",
+                 out_has_owner);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_list_names:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.ListNames">ListNames()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_list_names_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_list_names_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_list_names (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "ListNames",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_list_names_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_names: (out) (optional) (array zero-terminated=1): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_list_names().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_list_names().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_list_names_finish (
+    _GFreedesktopDBus *proxy,
+    gchar ***out_names,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^as)",
+                 out_names);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_list_names_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_names: (out) (optional) (array zero-terminated=1): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.ListNames">ListNames()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_list_names() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_list_names_sync (
+    _GFreedesktopDBus *proxy,
+    gchar ***out_names,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "ListNames",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^as)",
+                 out_names);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_list_activatable_names:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.ListActivatableNames">ListActivatableNames()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_list_activatable_names_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_list_activatable_names_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_list_activatable_names (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "ListActivatableNames",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_list_activatable_names_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_activatable_names: (out) (optional) (array zero-terminated=1): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_list_activatable_names().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_list_activatable_names().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_list_activatable_names_finish (
+    _GFreedesktopDBus *proxy,
+    gchar ***out_activatable_names,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^as)",
+                 out_activatable_names);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_list_activatable_names_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_activatable_names: (out) (optional) (array zero-terminated=1): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.ListActivatableNames">ListActivatableNames()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_list_activatable_names() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_list_activatable_names_sync (
+    _GFreedesktopDBus *proxy,
+    gchar ***out_activatable_names,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "ListActivatableNames",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^as)",
+                 out_activatable_names);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_add_match:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_rule: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.AddMatch">AddMatch()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_add_match_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_add_match_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_add_match (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_rule,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "AddMatch",
+    g_variant_new ("(s)",
+                   arg_rule),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_add_match_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_add_match().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_add_match().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_add_match_finish (
+    _GFreedesktopDBus *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_add_match_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_rule: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.AddMatch">AddMatch()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_add_match() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_add_match_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_rule,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "AddMatch",
+    g_variant_new ("(s)",
+                   arg_rule),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_remove_match:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_rule: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.RemoveMatch">RemoveMatch()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_remove_match_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_remove_match_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_remove_match (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_rule,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "RemoveMatch",
+    g_variant_new ("(s)",
+                   arg_rule),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_remove_match_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_remove_match().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_remove_match().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_remove_match_finish (
+    _GFreedesktopDBus *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_remove_match_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_rule: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.RemoveMatch">RemoveMatch()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_remove_match() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_remove_match_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_rule,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "RemoveMatch",
+    g_variant_new ("(s)",
+                   arg_rule),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_name_owner:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.GetNameOwner">GetNameOwner()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_get_name_owner_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_get_name_owner_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_get_name_owner (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "GetNameOwner",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_name_owner_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_unique_name: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_get_name_owner().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_get_name_owner().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_get_name_owner_finish (
+    _GFreedesktopDBus *proxy,
+    gchar **out_unique_name,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_unique_name);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_name_owner_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @out_unique_name: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.GetNameOwner">GetNameOwner()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_get_name_owner() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_get_name_owner_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    gchar **out_unique_name,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "GetNameOwner",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_unique_name);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_list_queued_owners:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.ListQueuedOwners">ListQueuedOwners()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_list_queued_owners_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_list_queued_owners_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_list_queued_owners (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "ListQueuedOwners",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_list_queued_owners_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_queued_owners: (out) (optional) (array zero-terminated=1): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_list_queued_owners().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_list_queued_owners().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_list_queued_owners_finish (
+    _GFreedesktopDBus *proxy,
+    gchar ***out_queued_owners,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^as)",
+                 out_queued_owners);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_list_queued_owners_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @out_queued_owners: (out) (optional) (array zero-terminated=1): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.ListQueuedOwners">ListQueuedOwners()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_list_queued_owners() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_list_queued_owners_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    gchar ***out_queued_owners,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "ListQueuedOwners",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^as)",
+                 out_queued_owners);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_connection_unix_user:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionUnixUser">GetConnectionUnixUser()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_get_connection_unix_user_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_get_connection_unix_user_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_get_connection_unix_user (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "GetConnectionUnixUser",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_connection_unix_user_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_uid: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_get_connection_unix_user().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_get_connection_unix_user().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_get_connection_unix_user_finish (
+    _GFreedesktopDBus *proxy,
+    guint *out_uid,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_uid);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_connection_unix_user_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @out_uid: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionUnixUser">GetConnectionUnixUser()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_get_connection_unix_user() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_get_connection_unix_user_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint *out_uid,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "GetConnectionUnixUser",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_uid);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_connection_unix_process_id:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionUnixProcessID">GetConnectionUnixProcessID()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_get_connection_unix_process_id_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_get_connection_unix_process_id_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_get_connection_unix_process_id (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "GetConnectionUnixProcessID",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_connection_unix_process_id_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_pid: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_get_connection_unix_process_id().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_get_connection_unix_process_id().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_get_connection_unix_process_id_finish (
+    _GFreedesktopDBus *proxy,
+    guint *out_pid,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_pid);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_connection_unix_process_id_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @out_pid: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionUnixProcessID">GetConnectionUnixProcessID()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_get_connection_unix_process_id() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_get_connection_unix_process_id_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint *out_pid,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "GetConnectionUnixProcessID",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_pid);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_connection_selinux_security_context:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionSELinuxSecurityContext">GetConnectionSELinuxSecurityContext()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_get_connection_selinux_security_context_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_get_connection_selinux_security_context_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_get_connection_selinux_security_context (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "GetConnectionSELinuxSecurityContext",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_connection_selinux_security_context_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_security_context: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_get_connection_selinux_security_context().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_get_connection_selinux_security_context().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_get_connection_selinux_security_context_finish (
+    _GFreedesktopDBus *proxy,
+    gchar **out_security_context,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^ay)",
+                 out_security_context);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_connection_selinux_security_context_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_name: Argument to pass with the method invocation.
+ * @out_security_context: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionSELinuxSecurityContext">GetConnectionSELinuxSecurityContext()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_get_connection_selinux_security_context() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_get_connection_selinux_security_context_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    gchar **out_security_context,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "GetConnectionSELinuxSecurityContext",
+    g_variant_new ("(s)",
+                   arg_name),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^ay)",
+                 out_security_context);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_update_activation_environment:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_environment: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.UpdateActivationEnvironment">UpdateActivationEnvironment()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_update_activation_environment_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_update_activation_environment_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_update_activation_environment (
+    _GFreedesktopDBus *proxy,
+    GVariant *arg_environment,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "UpdateActivationEnvironment",
+    g_variant_new ("(@a{ss})",
+                   arg_environment),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_update_activation_environment_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_update_activation_environment().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_update_activation_environment().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_update_activation_environment_finish (
+    _GFreedesktopDBus *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_update_activation_environment_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @arg_environment: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.UpdateActivationEnvironment">UpdateActivationEnvironment()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_update_activation_environment() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_update_activation_environment_sync (
+    _GFreedesktopDBus *proxy,
+    GVariant *arg_environment,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "UpdateActivationEnvironment",
+    g_variant_new ("(@a{ss})",
+                   arg_environment),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_reload_config:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.ReloadConfig">ReloadConfig()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_reload_config_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_reload_config_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_reload_config (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "ReloadConfig",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_reload_config_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_reload_config().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_reload_config().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_reload_config_finish (
+    _GFreedesktopDBus *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_reload_config_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.ReloadConfig">ReloadConfig()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_reload_config() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_reload_config_sync (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "ReloadConfig",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_id:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.GetId">GetId()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_call_get_id_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_call_get_id_sync() for the synchronous, blocking version of this method.
+ */
+void
+_g_freedesktop_dbus_call_get_id (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "GetId",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_id_finish:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_unique_id: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_call_get_id().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_call_get_id().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_get_id_finish (
+    _GFreedesktopDBus *proxy,
+    gchar **out_unique_id,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_unique_id);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_call_get_id_sync:
+ * @proxy: A #_GFreedesktopDBusProxy.
+ * @out_unique_id: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus.GetId">GetId()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_call_get_id() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+_g_freedesktop_dbus_call_get_id_sync (
+    _GFreedesktopDBus *proxy,
+    gchar **out_unique_id,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "GetId",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_unique_id);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_complete_hello:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @assigned_name: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.Hello">Hello()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_hello (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *assigned_name)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(s)",
+                   assigned_name));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_request_name:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @value: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.RequestName">RequestName()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_request_name (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    guint value)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(u)",
+                   value));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_release_name:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @value: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.ReleaseName">ReleaseName()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_release_name (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    guint value)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(u)",
+                   value));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_start_service_by_name:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @value: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.StartServiceByName">StartServiceByName()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_start_service_by_name (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    guint value)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(u)",
+                   value));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_name_has_owner:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @has_owner: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.NameHasOwner">NameHasOwner()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_name_has_owner (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    gboolean has_owner)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(b)",
+                   has_owner));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_list_names:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @names: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.ListNames">ListNames()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_list_names (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *const *names)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(^as)",
+                   names));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_list_activatable_names:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @activatable_names: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.ListActivatableNames">ListActivatableNames()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_list_activatable_names (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *const *activatable_names)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(^as)",
+                   activatable_names));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_add_match:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.AddMatch">AddMatch()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_add_match (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_remove_match:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.RemoveMatch">RemoveMatch()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_remove_match (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_get_name_owner:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @unique_name: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.GetNameOwner">GetNameOwner()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_get_name_owner (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *unique_name)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(s)",
+                   unique_name));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_list_queued_owners:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @queued_owners: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.ListQueuedOwners">ListQueuedOwners()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_list_queued_owners (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *const *queued_owners)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(^as)",
+                   queued_owners));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_get_connection_unix_user:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @uid: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionUnixUser">GetConnectionUnixUser()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_get_connection_unix_user (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    guint uid)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(u)",
+                   uid));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_get_connection_unix_process_id:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @pid: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionUnixProcessID">GetConnectionUnixProcessID()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_get_connection_unix_process_id (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    guint pid)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(u)",
+                   pid));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_get_connection_selinux_security_context:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @security_context: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.GetConnectionSELinuxSecurityContext">GetConnectionSELinuxSecurityContext()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_get_connection_selinux_security_context (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *security_context)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(^ay)",
+                   security_context));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_update_activation_environment:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.UpdateActivationEnvironment">UpdateActivationEnvironment()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_update_activation_environment (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_reload_config:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.ReloadConfig">ReloadConfig()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_reload_config (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * _g_freedesktop_dbus_complete_get_id:
+ * @object: A #_GFreedesktopDBus.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @unique_id: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus.GetId">GetId()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+_g_freedesktop_dbus_complete_get_id (
+    _GFreedesktopDBus *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *unique_id)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(s)",
+                   unique_id));
+}
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * _GFreedesktopDBusProxy:
+ *
+ * The #_GFreedesktopDBusProxy structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * _GFreedesktopDBusProxyClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #_GFreedesktopDBusProxy.
+ */
+
+struct __GFreedesktopDBusProxyPrivate
+{
+  GData *qdata;
+};
+
+static void _g_freedesktop_dbus_proxy_iface_init (_GFreedesktopDBusIface *iface);
+
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (_GFreedesktopDBusProxy, _g_freedesktop_dbus_proxy, G_TYPE_DBUS_PROXY,
+                         G_ADD_PRIVATE (_GFreedesktopDBusProxy)
+                         G_IMPLEMENT_INTERFACE (_G_TYPE_FREEDESKTOP_DBUS, _g_freedesktop_dbus_proxy_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (_GFreedesktopDBusProxy, _g_freedesktop_dbus_proxy, G_TYPE_DBUS_PROXY,
+                         G_IMPLEMENT_INTERFACE (_G_TYPE_FREEDESKTOP_DBUS, _g_freedesktop_dbus_proxy_iface_init))
+
+#endif
+static void
+_g_freedesktop_dbus_proxy_finalize (GObject *object)
+{
+  _GFreedesktopDBusProxy *proxy = _G_FREEDESKTOP_DBUS_PROXY (object);
+  g_datalist_clear (&proxy->priv->qdata);
+  G_OBJECT_CLASS (_g_freedesktop_dbus_proxy_parent_class)->finalize (object);
+}
+
+static void
+_g_freedesktop_dbus_proxy_get_property (GObject      *object G_GNUC_UNUSED,
+  guint         prop_id G_GNUC_UNUSED,
+  GValue       *value G_GNUC_UNUSED,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+}
+
+static void
+_g_freedesktop_dbus_proxy_set_property (GObject      *object G_GNUC_UNUSED,
+  guint         prop_id G_GNUC_UNUSED,
+  const GValue *value G_GNUC_UNUSED,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+}
+
+static void
+_g_freedesktop_dbus_proxy_g_signal (GDBusProxy *proxy,
+  const gchar *sender_name G_GNUC_UNUSED,
+  const gchar *signal_name,
+  GVariant *parameters)
+{
+  _ExtendedGDBusSignalInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  gsize n;
+  guint signal_id;
+  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &__g_freedesktop_dbus_interface_info.parent_struct, signal_name);
+  if (info == NULL)
+    return;
+  num_params = g_variant_n_children (parameters);
+  paramv = g_new0 (GValue, num_params + 1);
+  g_value_init (&paramv[0], _G_TYPE_FREEDESKTOP_DBUS);
+  g_value_set_object (&paramv[0], proxy);
+  g_variant_iter_init (&iter, parameters);
+  n = 1;
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, _G_TYPE_FREEDESKTOP_DBUS);
+  g_signal_emitv (paramv, signal_id, 0, NULL);
+  for (n = 0; n < num_params + 1; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static void
+_g_freedesktop_dbus_proxy_g_properties_changed (GDBusProxy *_proxy,
+  GVariant *changed_properties,
+  const gchar *const *invalidated_properties)
+{
+  _GFreedesktopDBusProxy *proxy = _G_FREEDESKTOP_DBUS_PROXY (_proxy);
+  guint n;
+  const gchar *key;
+  GVariantIter *iter;
+  _ExtendedGDBusPropertyInfo *info;
+  g_variant_get (changed_properties, "a{sv}", &iter);
+  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &__g_freedesktop_dbus_interface_info.parent_struct, key);
+      g_datalist_remove_data (&proxy->priv->qdata, key);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+  g_variant_iter_free (iter);
+  for (n = 0; invalidated_properties[n] != NULL; n++)
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &__g_freedesktop_dbus_interface_info.parent_struct, invalidated_properties[n]);
+      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+}
+
+static void
+_g_freedesktop_dbus_proxy_init (_GFreedesktopDBusProxy *proxy)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  proxy->priv = _g_freedesktop_dbus_proxy_get_instance_private (proxy);
+#else
+  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, _G_TYPE_FREEDESKTOP_DBUS_PROXY, _GFreedesktopDBusProxyPrivate);
+#endif
+
+  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), _g_freedesktop_dbus_interface_info ());
+}
+
+static void
+_g_freedesktop_dbus_proxy_class_init (_GFreedesktopDBusProxyClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusProxyClass *proxy_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize     = _g_freedesktop_dbus_proxy_finalize;
+  gobject_class->get_property = _g_freedesktop_dbus_proxy_get_property;
+  gobject_class->set_property = _g_freedesktop_dbus_proxy_set_property;
+
+  proxy_class = G_DBUS_PROXY_CLASS (klass);
+  proxy_class->g_signal = _g_freedesktop_dbus_proxy_g_signal;
+  proxy_class->g_properties_changed = _g_freedesktop_dbus_proxy_g_properties_changed;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (_GFreedesktopDBusProxyPrivate));
+#endif
+}
+
+static void
+_g_freedesktop_dbus_proxy_iface_init (_GFreedesktopDBusIface *iface G_GNUC_UNUSED)
+{
+}
+
+/**
+ * _g_freedesktop_dbus_proxy_new:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus.top_of_page">org.freedesktop.DBus</link>. See g_dbus_proxy_new() for more details.
+ *
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_proxy_new_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_proxy_new_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+_g_freedesktop_dbus_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (_G_TYPE_FREEDESKTOP_DBUS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus", NULL);
+}
+
+/**
+ * _g_freedesktop_dbus_proxy_new_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_proxy_new().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_proxy_new().
+ *
+ * Returns: (transfer full) (type _GFreedesktopDBusProxy): The constructed proxy object or %NULL if @error is set.
+ */
+_GFreedesktopDBus *
+_g_freedesktop_dbus_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return _G_FREEDESKTOP_DBUS (ret);
+  else
+    return NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_proxy_new_sync:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus.top_of_page">org.freedesktop.DBus</link>. See g_dbus_proxy_new_sync() for more details.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_proxy_new() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type _GFreedesktopDBusProxy): The constructed proxy object or %NULL if @error is set.
+ */
+_GFreedesktopDBus *
+_g_freedesktop_dbus_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (_G_TYPE_FREEDESKTOP_DBUS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus", NULL);
+  if (ret != NULL)
+    return _G_FREEDESKTOP_DBUS (ret);
+  else
+    return NULL;
+}
+
+
+/**
+ * _g_freedesktop_dbus_proxy_new_for_bus:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Like _g_freedesktop_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call _g_freedesktop_dbus_proxy_new_for_bus_finish() to get the result of the operation.
+ *
+ * See _g_freedesktop_dbus_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+_g_freedesktop_dbus_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (_G_TYPE_FREEDESKTOP_DBUS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus", NULL);
+}
+
+/**
+ * _g_freedesktop_dbus_proxy_new_for_bus_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to _g_freedesktop_dbus_proxy_new_for_bus().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with _g_freedesktop_dbus_proxy_new_for_bus().
+ *
+ * Returns: (transfer full) (type _GFreedesktopDBusProxy): The constructed proxy object or %NULL if @error is set.
+ */
+_GFreedesktopDBus *
+_g_freedesktop_dbus_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return _G_FREEDESKTOP_DBUS (ret);
+  else
+    return NULL;
+}
+
+/**
+ * _g_freedesktop_dbus_proxy_new_for_bus_sync:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Like _g_freedesktop_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See _g_freedesktop_dbus_proxy_new_for_bus() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type _GFreedesktopDBusProxy): The constructed proxy object or %NULL if @error is set.
+ */
+_GFreedesktopDBus *
+_g_freedesktop_dbus_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (_G_TYPE_FREEDESKTOP_DBUS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus", NULL);
+  if (ret != NULL)
+    return _G_FREEDESKTOP_DBUS (ret);
+  else
+    return NULL;
+}
+
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * _GFreedesktopDBusSkeleton:
+ *
+ * The #_GFreedesktopDBusSkeleton structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * _GFreedesktopDBusSkeletonClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #_GFreedesktopDBusSkeleton.
+ */
+
+struct __GFreedesktopDBusSkeletonPrivate
+{
+  GValue *properties;
+  GList *changed_properties;
+  GSource *changed_properties_idle_source;
+  GMainContext *context;
+  GMutex lock;
+};
+
+static void
+__g_freedesktop_dbus_skeleton_handle_method_call (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name,
+  const gchar *method_name,
+  GVariant *parameters,
+  GDBusMethodInvocation *invocation,
+  gpointer user_data)
+{
+  _GFreedesktopDBusSkeleton *skeleton = _G_FREEDESKTOP_DBUS_SKELETON (user_data);
+  _ExtendedGDBusMethodInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  guint num_extra;
+  gsize n;
+  guint signal_id;
+  GValue return_value = G_VALUE_INIT;
+  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
+  g_assert (info != NULL);
+  num_params = g_variant_n_children (parameters);
+  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
+  n = 0;
+  g_value_init (&paramv[n], _G_TYPE_FREEDESKTOP_DBUS);
+  g_value_set_object (&paramv[n++], skeleton);
+  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
+  g_value_set_object (&paramv[n++], invocation);
+  if (info->pass_fdlist)
+    {
+#ifdef G_OS_UNIX
+      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
+      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
+#else
+      g_assert_not_reached ();
+#endif
+    }
+  g_variant_iter_init (&iter, parameters);
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, _G_TYPE_FREEDESKTOP_DBUS);
+  g_value_init (&return_value, G_TYPE_BOOLEAN);
+  g_signal_emitv (paramv, signal_id, 0, &return_value);
+  if (!g_value_get_boolean (&return_value))
+    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
+  g_value_unset (&return_value);
+  for (n = 0; n < num_params + num_extra; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static GVariant *
+__g_freedesktop_dbus_skeleton_handle_get_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GError **error,
+  gpointer user_data)
+{
+  _GFreedesktopDBusSkeleton *skeleton = _G_FREEDESKTOP_DBUS_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  GVariant *ret;
+  ret = NULL;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &__g_freedesktop_dbus_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      g_value_init (&value, pspec->value_type);
+      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
+      g_value_unset (&value);
+    }
+  return ret;
+}
+
+static gboolean
+__g_freedesktop_dbus_skeleton_handle_set_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GVariant *variant,
+  GError **error,
+  gpointer user_data)
+{
+  _GFreedesktopDBusSkeleton *skeleton = _G_FREEDESKTOP_DBUS_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  gboolean ret;
+  ret = FALSE;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &__g_freedesktop_dbus_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      if (info->use_gvariant)
+        g_value_set_variant (&value, variant);
+      else
+        g_dbus_gvariant_to_gvalue (variant, &value);
+      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      g_value_unset (&value);
+      ret = TRUE;
+    }
+  return ret;
+}
+
+static const GDBusInterfaceVTable __g_freedesktop_dbus_skeleton_vtable =
+{
+  __g_freedesktop_dbus_skeleton_handle_method_call,
+  __g_freedesktop_dbus_skeleton_handle_get_property,
+  __g_freedesktop_dbus_skeleton_handle_set_property,
+  {NULL}
+};
+
+static GDBusInterfaceInfo *
+_g_freedesktop_dbus_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return _g_freedesktop_dbus_interface_info ();
+}
+
+static GDBusInterfaceVTable *
+_g_freedesktop_dbus_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return (GDBusInterfaceVTable *) &__g_freedesktop_dbus_skeleton_vtable;
+}
+
+static GVariant *
+_g_freedesktop_dbus_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
+{
+  _GFreedesktopDBusSkeleton *skeleton = _G_FREEDESKTOP_DBUS_SKELETON (_skeleton);
+
+  GVariantBuilder builder;
+  guint n;
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  if (__g_freedesktop_dbus_interface_info.parent_struct.properties == NULL)
+    goto out;
+  for (n = 0; __g_freedesktop_dbus_interface_info.parent_struct.properties[n] != NULL; n++)
+    {
+      GDBusPropertyInfo *info = __g_freedesktop_dbus_interface_info.parent_struct.properties[n];
+      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
+        {
+          GVariant *value;
+          value = __g_freedesktop_dbus_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.DBus", info->name, NULL, skeleton);
+          if (value != NULL)
+            {
+              g_variant_take_ref (value);
+              g_variant_builder_add (&builder, "{sv}", info->name, value);
+              g_variant_unref (value);
+            }
+        }
+    }
+out:
+  return g_variant_builder_end (&builder);
+}
+
+static void
+_g_freedesktop_dbus_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton G_GNUC_UNUSED)
+{
+}
+
+static void
+__g_freedesktop_dbus_on_signal_name_owner_changed (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name,
+    const gchar *arg_old_owner,
+    const gchar *arg_new_owner)
+{
+  _GFreedesktopDBusSkeleton *skeleton = _G_FREEDESKTOP_DBUS_SKELETON (object);
+
+  GList      *connections, *l;
+  GVariant   *signal_variant;
+  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+
+  signal_variant = g_variant_ref_sink (g_variant_new ("(sss)",
+                   arg_name,
+                   arg_old_owner,
+                   arg_new_owner));
+  for (l = connections; l != NULL; l = l->next)
+    {
+      GDBusConnection *connection = l->data;
+      g_dbus_connection_emit_signal (connection,
+        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.DBus", "NameOwnerChanged",
+        signal_variant, NULL);
+    }
+  g_variant_unref (signal_variant);
+  g_list_free_full (connections, g_object_unref);
+}
+
+static void
+__g_freedesktop_dbus_on_signal_name_lost (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name)
+{
+  _GFreedesktopDBusSkeleton *skeleton = _G_FREEDESKTOP_DBUS_SKELETON (object);
+
+  GList      *connections, *l;
+  GVariant   *signal_variant;
+  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+
+  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
+                   arg_name));
+  for (l = connections; l != NULL; l = l->next)
+    {
+      GDBusConnection *connection = l->data;
+      g_dbus_connection_emit_signal (connection,
+        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.DBus", "NameLost",
+        signal_variant, NULL);
+    }
+  g_variant_unref (signal_variant);
+  g_list_free_full (connections, g_object_unref);
+}
+
+static void
+__g_freedesktop_dbus_on_signal_name_acquired (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name)
+{
+  _GFreedesktopDBusSkeleton *skeleton = _G_FREEDESKTOP_DBUS_SKELETON (object);
+
+  GList      *connections, *l;
+  GVariant   *signal_variant;
+  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+
+  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
+                   arg_name));
+  for (l = connections; l != NULL; l = l->next)
+    {
+      GDBusConnection *connection = l->data;
+      g_dbus_connection_emit_signal (connection,
+        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.DBus", "NameAcquired",
+        signal_variant, NULL);
+    }
+  g_variant_unref (signal_variant);
+  g_list_free_full (connections, g_object_unref);
+}
+
+static void _g_freedesktop_dbus_skeleton_iface_init (_GFreedesktopDBusIface *iface);
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (_GFreedesktopDBusSkeleton, _g_freedesktop_dbus_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_ADD_PRIVATE (_GFreedesktopDBusSkeleton)
+                         G_IMPLEMENT_INTERFACE (_G_TYPE_FREEDESKTOP_DBUS, _g_freedesktop_dbus_skeleton_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (_GFreedesktopDBusSkeleton, _g_freedesktop_dbus_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (_G_TYPE_FREEDESKTOP_DBUS, _g_freedesktop_dbus_skeleton_iface_init))
+
+#endif
+static void
+_g_freedesktop_dbus_skeleton_finalize (GObject *object)
+{
+  _GFreedesktopDBusSkeleton *skeleton = _G_FREEDESKTOP_DBUS_SKELETON (object);
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    g_source_destroy (skeleton->priv->changed_properties_idle_source);
+  g_main_context_unref (skeleton->priv->context);
+  g_mutex_clear (&skeleton->priv->lock);
+  G_OBJECT_CLASS (_g_freedesktop_dbus_skeleton_parent_class)->finalize (object);
+}
+
+static void
+_g_freedesktop_dbus_skeleton_init (_GFreedesktopDBusSkeleton *skeleton)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  skeleton->priv = _g_freedesktop_dbus_skeleton_get_instance_private (skeleton);
+#else
+  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, _G_TYPE_FREEDESKTOP_DBUS_SKELETON, _GFreedesktopDBusSkeletonPrivate);
+#endif
+
+  g_mutex_init (&skeleton->priv->lock);
+  skeleton->priv->context = g_main_context_ref_thread_default ();
+}
+
+static void
+_g_freedesktop_dbus_skeleton_class_init (_GFreedesktopDBusSkeletonClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusInterfaceSkeletonClass *skeleton_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = _g_freedesktop_dbus_skeleton_finalize;
+
+  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
+  skeleton_class->get_info = _g_freedesktop_dbus_skeleton_dbus_interface_get_info;
+  skeleton_class->get_properties = _g_freedesktop_dbus_skeleton_dbus_interface_get_properties;
+  skeleton_class->flush = _g_freedesktop_dbus_skeleton_dbus_interface_flush;
+  skeleton_class->get_vtable = _g_freedesktop_dbus_skeleton_dbus_interface_get_vtable;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (_GFreedesktopDBusSkeletonPrivate));
+#endif
+}
+
+static void
+_g_freedesktop_dbus_skeleton_iface_init (_GFreedesktopDBusIface *iface)
+{
+  iface->name_owner_changed = __g_freedesktop_dbus_on_signal_name_owner_changed;
+  iface->name_lost = __g_freedesktop_dbus_on_signal_name_lost;
+  iface->name_acquired = __g_freedesktop_dbus_on_signal_name_acquired;
+}
+
+/**
+ * _g_freedesktop_dbus_skeleton_new:
+ *
+ * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus.top_of_page">org.freedesktop.DBus</link>.
+ *
+ * Returns: (transfer full) (type _GFreedesktopDBusSkeleton): The skeleton object.
+ */
+_GFreedesktopDBus *
+_g_freedesktop_dbus_skeleton_new (void)
+{
+  return _G_FREEDESKTOP_DBUS (g_object_new (_G_TYPE_FREEDESKTOP_DBUS_SKELETON, NULL));
+}
+
diff --git a/gio/gdbus-daemon-generated.h b/gio/gdbus-daemon-generated.h
new file mode 100644
index 0000000..8a99684
--- /dev/null
+++ b/gio/gdbus-daemon-generated.h
@@ -0,0 +1,674 @@
+/*
+ * This file is generated by gdbus-codegen, do not modify it.
+ *
+ * The license of this code is the same as for the D-Bus interface description
+ * it was derived from. Note that it links to GLib, so must comply with the
+ * LGPL linking clauses.
+ */
+
+#ifndef __GDBUS_DAEMON_GENERATED_H__
+#define __GDBUS_DAEMON_GENERATED_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+
+/* ------------------------------------------------------------------------ */
+/* Declarations for org.freedesktop.DBus */
+
+#define _G_TYPE_FREEDESKTOP_DBUS (_g_freedesktop_dbus_get_type ())
+#define _G_FREEDESKTOP_DBUS(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), _G_TYPE_FREEDESKTOP_DBUS, _GFreedesktopDBus))
+#define _G_IS_FREEDESKTOP_DBUS(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), _G_TYPE_FREEDESKTOP_DBUS))
+#define _G_FREEDESKTOP_DBUS_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), _G_TYPE_FREEDESKTOP_DBUS, _GFreedesktopDBusIface))
+
+struct __GFreedesktopDBus;
+typedef struct __GFreedesktopDBus _GFreedesktopDBus;
+typedef struct __GFreedesktopDBusIface _GFreedesktopDBusIface;
+
+struct __GFreedesktopDBusIface
+{
+  GTypeInterface parent_iface;
+
+
+  gboolean (*handle_add_match) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_rule);
+
+  gboolean (*handle_get_connection_selinux_security_context) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_get_connection_unix_process_id) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_get_connection_unix_user) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_get_id) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_get_name_owner) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_hello) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_list_activatable_names) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_list_names) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_list_queued_owners) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_name_has_owner) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_release_name) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name);
+
+  gboolean (*handle_reload_config) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_remove_match) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_rule);
+
+  gboolean (*handle_request_name) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name,
+    guint arg_flags);
+
+  gboolean (*handle_start_service_by_name) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_name,
+    guint arg_flags);
+
+  gboolean (*handle_update_activation_environment) (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    GVariant *arg_environment);
+
+  void (*name_acquired) (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name);
+
+  void (*name_lost) (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name);
+
+  void (*name_owner_changed) (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name,
+    const gchar *arg_old_owner,
+    const gchar *arg_new_owner);
+
+};
+
+GType _g_freedesktop_dbus_get_type (void) G_GNUC_CONST;
+
+GDBusInterfaceInfo *_g_freedesktop_dbus_interface_info (void);
+guint _g_freedesktop_dbus_override_properties (GObjectClass *klass, guint property_id_begin);
+
+
+/* D-Bus method call completion functions: */
+void _g_freedesktop_dbus_complete_hello (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *assigned_name);
+
+void _g_freedesktop_dbus_complete_request_name (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    guint value);
+
+void _g_freedesktop_dbus_complete_release_name (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    guint value);
+
+void _g_freedesktop_dbus_complete_start_service_by_name (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    guint value);
+
+void _g_freedesktop_dbus_complete_name_has_owner (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    gboolean has_owner);
+
+void _g_freedesktop_dbus_complete_list_names (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *const *names);
+
+void _g_freedesktop_dbus_complete_list_activatable_names (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *const *activatable_names);
+
+void _g_freedesktop_dbus_complete_add_match (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation);
+
+void _g_freedesktop_dbus_complete_remove_match (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation);
+
+void _g_freedesktop_dbus_complete_get_name_owner (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *unique_name);
+
+void _g_freedesktop_dbus_complete_list_queued_owners (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *const *queued_owners);
+
+void _g_freedesktop_dbus_complete_get_connection_unix_user (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    guint uid);
+
+void _g_freedesktop_dbus_complete_get_connection_unix_process_id (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    guint pid);
+
+void _g_freedesktop_dbus_complete_get_connection_selinux_security_context (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *security_context);
+
+void _g_freedesktop_dbus_complete_update_activation_environment (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation);
+
+void _g_freedesktop_dbus_complete_reload_config (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation);
+
+void _g_freedesktop_dbus_complete_get_id (
+    _GFreedesktopDBus *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *unique_id);
+
+
+
+/* D-Bus signal emissions functions: */
+void _g_freedesktop_dbus_emit_name_owner_changed (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name,
+    const gchar *arg_old_owner,
+    const gchar *arg_new_owner);
+
+void _g_freedesktop_dbus_emit_name_lost (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name);
+
+void _g_freedesktop_dbus_emit_name_acquired (
+    _GFreedesktopDBus *object,
+    const gchar *arg_name);
+
+
+
+/* D-Bus method calls: */
+void _g_freedesktop_dbus_call_hello (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_hello_finish (
+    _GFreedesktopDBus *proxy,
+    gchar **out_assigned_name,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_hello_sync (
+    _GFreedesktopDBus *proxy,
+    gchar **out_assigned_name,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_request_name (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint arg_flags,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_request_name_finish (
+    _GFreedesktopDBus *proxy,
+    guint *out_value,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_request_name_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint arg_flags,
+    guint *out_value,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_release_name (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_release_name_finish (
+    _GFreedesktopDBus *proxy,
+    guint *out_value,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_release_name_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint *out_value,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_start_service_by_name (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint arg_flags,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_start_service_by_name_finish (
+    _GFreedesktopDBus *proxy,
+    guint *out_value,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_start_service_by_name_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint arg_flags,
+    guint *out_value,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_name_has_owner (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_name_has_owner_finish (
+    _GFreedesktopDBus *proxy,
+    gboolean *out_has_owner,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_name_has_owner_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    gboolean *out_has_owner,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_list_names (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_list_names_finish (
+    _GFreedesktopDBus *proxy,
+    gchar ***out_names,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_list_names_sync (
+    _GFreedesktopDBus *proxy,
+    gchar ***out_names,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_list_activatable_names (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_list_activatable_names_finish (
+    _GFreedesktopDBus *proxy,
+    gchar ***out_activatable_names,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_list_activatable_names_sync (
+    _GFreedesktopDBus *proxy,
+    gchar ***out_activatable_names,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_add_match (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_rule,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_add_match_finish (
+    _GFreedesktopDBus *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_add_match_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_rule,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_remove_match (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_rule,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_remove_match_finish (
+    _GFreedesktopDBus *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_remove_match_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_rule,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_get_name_owner (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_get_name_owner_finish (
+    _GFreedesktopDBus *proxy,
+    gchar **out_unique_name,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_get_name_owner_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    gchar **out_unique_name,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_list_queued_owners (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_list_queued_owners_finish (
+    _GFreedesktopDBus *proxy,
+    gchar ***out_queued_owners,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_list_queued_owners_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    gchar ***out_queued_owners,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_get_connection_unix_user (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_get_connection_unix_user_finish (
+    _GFreedesktopDBus *proxy,
+    guint *out_uid,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_get_connection_unix_user_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint *out_uid,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_get_connection_unix_process_id (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_get_connection_unix_process_id_finish (
+    _GFreedesktopDBus *proxy,
+    guint *out_pid,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_get_connection_unix_process_id_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    guint *out_pid,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_get_connection_selinux_security_context (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_get_connection_selinux_security_context_finish (
+    _GFreedesktopDBus *proxy,
+    gchar **out_security_context,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_get_connection_selinux_security_context_sync (
+    _GFreedesktopDBus *proxy,
+    const gchar *arg_name,
+    gchar **out_security_context,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_update_activation_environment (
+    _GFreedesktopDBus *proxy,
+    GVariant *arg_environment,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_update_activation_environment_finish (
+    _GFreedesktopDBus *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_update_activation_environment_sync (
+    _GFreedesktopDBus *proxy,
+    GVariant *arg_environment,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_reload_config (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_reload_config_finish (
+    _GFreedesktopDBus *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_reload_config_sync (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GError **error);
+
+void _g_freedesktop_dbus_call_get_id (
+    _GFreedesktopDBus *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean _g_freedesktop_dbus_call_get_id_finish (
+    _GFreedesktopDBus *proxy,
+    gchar **out_unique_id,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean _g_freedesktop_dbus_call_get_id_sync (
+    _GFreedesktopDBus *proxy,
+    gchar **out_unique_id,
+    GCancellable *cancellable,
+    GError **error);
+
+
+
+/* ---- */
+
+#define _G_TYPE_FREEDESKTOP_DBUS_PROXY (_g_freedesktop_dbus_proxy_get_type ())
+#define _G_FREEDESKTOP_DBUS_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), _G_TYPE_FREEDESKTOP_DBUS_PROXY, _GFreedesktopDBusProxy))
+#define _G_FREEDESKTOP_DBUS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), _G_TYPE_FREEDESKTOP_DBUS_PROXY, _GFreedesktopDBusProxyClass))
+#define _G_FREEDESKTOP_DBUS_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), _G_TYPE_FREEDESKTOP_DBUS_PROXY, _GFreedesktopDBusProxyClass))
+#define _G_IS_FREEDESKTOP_DBUS_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), _G_TYPE_FREEDESKTOP_DBUS_PROXY))
+#define _G_IS_FREEDESKTOP_DBUS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), _G_TYPE_FREEDESKTOP_DBUS_PROXY))
+
+typedef struct __GFreedesktopDBusProxy _GFreedesktopDBusProxy;
+typedef struct __GFreedesktopDBusProxyClass _GFreedesktopDBusProxyClass;
+typedef struct __GFreedesktopDBusProxyPrivate _GFreedesktopDBusProxyPrivate;
+
+struct __GFreedesktopDBusProxy
+{
+  /*< private >*/
+  GDBusProxy parent_instance;
+  _GFreedesktopDBusProxyPrivate *priv;
+};
+
+struct __GFreedesktopDBusProxyClass
+{
+  GDBusProxyClass parent_class;
+};
+
+GType _g_freedesktop_dbus_proxy_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (_GFreedesktopDBusProxy, g_object_unref)
+#endif
+
+void _g_freedesktop_dbus_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+_GFreedesktopDBus *_g_freedesktop_dbus_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error);
+_GFreedesktopDBus *_g_freedesktop_dbus_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+void _g_freedesktop_dbus_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+_GFreedesktopDBus *_g_freedesktop_dbus_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error);
+_GFreedesktopDBus *_g_freedesktop_dbus_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+
+/* ---- */
+
+#define _G_TYPE_FREEDESKTOP_DBUS_SKELETON (_g_freedesktop_dbus_skeleton_get_type ())
+#define _G_FREEDESKTOP_DBUS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), _G_TYPE_FREEDESKTOP_DBUS_SKELETON, _GFreedesktopDBusSkeleton))
+#define _G_FREEDESKTOP_DBUS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), _G_TYPE_FREEDESKTOP_DBUS_SKELETON, _GFreedesktopDBusSkeletonClass))
+#define _G_FREEDESKTOP_DBUS_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), _G_TYPE_FREEDESKTOP_DBUS_SKELETON, _GFreedesktopDBusSkeletonClass))
+#define _G_IS_FREEDESKTOP_DBUS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), _G_TYPE_FREEDESKTOP_DBUS_SKELETON))
+#define _G_IS_FREEDESKTOP_DBUS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), _G_TYPE_FREEDESKTOP_DBUS_SKELETON))
+
+typedef struct __GFreedesktopDBusSkeleton _GFreedesktopDBusSkeleton;
+typedef struct __GFreedesktopDBusSkeletonClass _GFreedesktopDBusSkeletonClass;
+typedef struct __GFreedesktopDBusSkeletonPrivate _GFreedesktopDBusSkeletonPrivate;
+
+struct __GFreedesktopDBusSkeleton
+{
+  /*< private >*/
+  GDBusInterfaceSkeleton parent_instance;
+  _GFreedesktopDBusSkeletonPrivate *priv;
+};
+
+struct __GFreedesktopDBusSkeletonClass
+{
+  GDBusInterfaceSkeletonClass parent_class;
+};
+
+GType _g_freedesktop_dbus_skeleton_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (_GFreedesktopDBusSkeleton, g_object_unref)
+#endif
+
+_GFreedesktopDBus *_g_freedesktop_dbus_skeleton_new (void);
+
+
+G_END_DECLS
+
+#endif /* __GDBUS_DAEMON_GENERATED_H__ */
diff --git a/gio/gioenumtypes.c b/gio/gioenumtypes.c
new file mode 100644
index 0000000..0ccd900
--- /dev/null
+++ b/gio/gioenumtypes.c
@@ -0,0 +1,1834 @@
+
+/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */
+
+#include "config.h"
+#include "gioenumtypes.h"
+#include <gio.h>
+/* enumerations from "../gio/gioenums.h" */
+GType
+g_app_info_create_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_APP_INFO_CREATE_NONE, "G_APP_INFO_CREATE_NONE", "none" },
+        { G_APP_INFO_CREATE_NEEDS_TERMINAL, "G_APP_INFO_CREATE_NEEDS_TERMINAL", "needs-terminal" },
+        { G_APP_INFO_CREATE_SUPPORTS_URIS, "G_APP_INFO_CREATE_SUPPORTS_URIS", "supports-uris" },
+        { G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION, "G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION", "supports-startup-notification" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GAppInfoCreateFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_converter_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_CONVERTER_NO_FLAGS, "G_CONVERTER_NO_FLAGS", "none" },
+        { G_CONVERTER_INPUT_AT_END, "G_CONVERTER_INPUT_AT_END", "input-at-end" },
+        { G_CONVERTER_FLUSH, "G_CONVERTER_FLUSH", "flush" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GConverterFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_converter_result_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_CONVERTER_ERROR, "G_CONVERTER_ERROR", "error" },
+        { G_CONVERTER_CONVERTED, "G_CONVERTER_CONVERTED", "converted" },
+        { G_CONVERTER_FINISHED, "G_CONVERTER_FINISHED", "finished" },
+        { G_CONVERTER_FLUSHED, "G_CONVERTER_FLUSHED", "flushed" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GConverterResult"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_data_stream_byte_order_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN, "G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN", "big-endian" },
+        { G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN, "G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN", "little-endian" },
+        { G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN, "G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN", "host-endian" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GDataStreamByteOrder"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_data_stream_newline_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_DATA_STREAM_NEWLINE_TYPE_LF, "G_DATA_STREAM_NEWLINE_TYPE_LF", "lf" },
+        { G_DATA_STREAM_NEWLINE_TYPE_CR, "G_DATA_STREAM_NEWLINE_TYPE_CR", "cr" },
+        { G_DATA_STREAM_NEWLINE_TYPE_CR_LF, "G_DATA_STREAM_NEWLINE_TYPE_CR_LF", "cr-lf" },
+        { G_DATA_STREAM_NEWLINE_TYPE_ANY, "G_DATA_STREAM_NEWLINE_TYPE_ANY", "any" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GDataStreamNewlineType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_file_attribute_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_FILE_ATTRIBUTE_TYPE_INVALID, "G_FILE_ATTRIBUTE_TYPE_INVALID", "invalid" },
+        { G_FILE_ATTRIBUTE_TYPE_STRING, "G_FILE_ATTRIBUTE_TYPE_STRING", "string" },
+        { G_FILE_ATTRIBUTE_TYPE_BYTE_STRING, "G_FILE_ATTRIBUTE_TYPE_BYTE_STRING", "byte-string" },
+        { G_FILE_ATTRIBUTE_TYPE_BOOLEAN, "G_FILE_ATTRIBUTE_TYPE_BOOLEAN", "boolean" },
+        { G_FILE_ATTRIBUTE_TYPE_UINT32, "G_FILE_ATTRIBUTE_TYPE_UINT32", "uint32" },
+        { G_FILE_ATTRIBUTE_TYPE_INT32, "G_FILE_ATTRIBUTE_TYPE_INT32", "int32" },
+        { G_FILE_ATTRIBUTE_TYPE_UINT64, "G_FILE_ATTRIBUTE_TYPE_UINT64", "uint64" },
+        { G_FILE_ATTRIBUTE_TYPE_INT64, "G_FILE_ATTRIBUTE_TYPE_INT64", "int64" },
+        { G_FILE_ATTRIBUTE_TYPE_OBJECT, "G_FILE_ATTRIBUTE_TYPE_OBJECT", "object" },
+        { G_FILE_ATTRIBUTE_TYPE_STRINGV, "G_FILE_ATTRIBUTE_TYPE_STRINGV", "stringv" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GFileAttributeType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_file_attribute_info_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_FILE_ATTRIBUTE_INFO_NONE, "G_FILE_ATTRIBUTE_INFO_NONE", "none" },
+        { G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE, "G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE", "copy-with-file" },
+        { G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED, "G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED", "copy-when-moved" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GFileAttributeInfoFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_file_attribute_status_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_FILE_ATTRIBUTE_STATUS_UNSET, "G_FILE_ATTRIBUTE_STATUS_UNSET", "unset" },
+        { G_FILE_ATTRIBUTE_STATUS_SET, "G_FILE_ATTRIBUTE_STATUS_SET", "set" },
+        { G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, "G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING", "error-setting" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GFileAttributeStatus"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_file_query_info_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_FILE_QUERY_INFO_NONE, "G_FILE_QUERY_INFO_NONE", "none" },
+        { G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, "G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS", "nofollow-symlinks" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GFileQueryInfoFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_file_create_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_FILE_CREATE_NONE, "G_FILE_CREATE_NONE", "none" },
+        { G_FILE_CREATE_PRIVATE, "G_FILE_CREATE_PRIVATE", "private" },
+        { G_FILE_CREATE_REPLACE_DESTINATION, "G_FILE_CREATE_REPLACE_DESTINATION", "replace-destination" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GFileCreateFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_file_measure_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_FILE_MEASURE_NONE, "G_FILE_MEASURE_NONE", "none" },
+        { G_FILE_MEASURE_REPORT_ANY_ERROR, "G_FILE_MEASURE_REPORT_ANY_ERROR", "report-any-error" },
+        { G_FILE_MEASURE_APPARENT_SIZE, "G_FILE_MEASURE_APPARENT_SIZE", "apparent-size" },
+        { G_FILE_MEASURE_NO_XDEV, "G_FILE_MEASURE_NO_XDEV", "no-xdev" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GFileMeasureFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_mount_mount_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_MOUNT_MOUNT_NONE, "G_MOUNT_MOUNT_NONE", "none" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GMountMountFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_mount_unmount_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_MOUNT_UNMOUNT_NONE, "G_MOUNT_UNMOUNT_NONE", "none" },
+        { G_MOUNT_UNMOUNT_FORCE, "G_MOUNT_UNMOUNT_FORCE", "force" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GMountUnmountFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_drive_start_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DRIVE_START_NONE, "G_DRIVE_START_NONE", "none" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDriveStartFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_drive_start_stop_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_DRIVE_START_STOP_TYPE_UNKNOWN, "G_DRIVE_START_STOP_TYPE_UNKNOWN", "unknown" },
+        { G_DRIVE_START_STOP_TYPE_SHUTDOWN, "G_DRIVE_START_STOP_TYPE_SHUTDOWN", "shutdown" },
+        { G_DRIVE_START_STOP_TYPE_NETWORK, "G_DRIVE_START_STOP_TYPE_NETWORK", "network" },
+        { G_DRIVE_START_STOP_TYPE_MULTIDISK, "G_DRIVE_START_STOP_TYPE_MULTIDISK", "multidisk" },
+        { G_DRIVE_START_STOP_TYPE_PASSWORD, "G_DRIVE_START_STOP_TYPE_PASSWORD", "password" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GDriveStartStopType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_file_copy_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_FILE_COPY_NONE, "G_FILE_COPY_NONE", "none" },
+        { G_FILE_COPY_OVERWRITE, "G_FILE_COPY_OVERWRITE", "overwrite" },
+        { G_FILE_COPY_BACKUP, "G_FILE_COPY_BACKUP", "backup" },
+        { G_FILE_COPY_NOFOLLOW_SYMLINKS, "G_FILE_COPY_NOFOLLOW_SYMLINKS", "nofollow-symlinks" },
+        { G_FILE_COPY_ALL_METADATA, "G_FILE_COPY_ALL_METADATA", "all-metadata" },
+        { G_FILE_COPY_NO_FALLBACK_FOR_MOVE, "G_FILE_COPY_NO_FALLBACK_FOR_MOVE", "no-fallback-for-move" },
+        { G_FILE_COPY_TARGET_DEFAULT_PERMS, "G_FILE_COPY_TARGET_DEFAULT_PERMS", "target-default-perms" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GFileCopyFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_file_monitor_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_FILE_MONITOR_NONE, "G_FILE_MONITOR_NONE", "none" },
+        { G_FILE_MONITOR_WATCH_MOUNTS, "G_FILE_MONITOR_WATCH_MOUNTS", "watch-mounts" },
+        { G_FILE_MONITOR_SEND_MOVED, "G_FILE_MONITOR_SEND_MOVED", "send-moved" },
+        { G_FILE_MONITOR_WATCH_HARD_LINKS, "G_FILE_MONITOR_WATCH_HARD_LINKS", "watch-hard-links" },
+        { G_FILE_MONITOR_WATCH_MOVES, "G_FILE_MONITOR_WATCH_MOVES", "watch-moves" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GFileMonitorFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_file_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_FILE_TYPE_UNKNOWN, "G_FILE_TYPE_UNKNOWN", "unknown" },
+        { G_FILE_TYPE_REGULAR, "G_FILE_TYPE_REGULAR", "regular" },
+        { G_FILE_TYPE_DIRECTORY, "G_FILE_TYPE_DIRECTORY", "directory" },
+        { G_FILE_TYPE_SYMBOLIC_LINK, "G_FILE_TYPE_SYMBOLIC_LINK", "symbolic-link" },
+        { G_FILE_TYPE_SPECIAL, "G_FILE_TYPE_SPECIAL", "special" },
+        { G_FILE_TYPE_SHORTCUT, "G_FILE_TYPE_SHORTCUT", "shortcut" },
+        { G_FILE_TYPE_MOUNTABLE, "G_FILE_TYPE_MOUNTABLE", "mountable" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GFileType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_filesystem_preview_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS, "G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS", "if-always" },
+        { G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL, "G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL", "if-local" },
+        { G_FILESYSTEM_PREVIEW_TYPE_NEVER, "G_FILESYSTEM_PREVIEW_TYPE_NEVER", "never" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GFilesystemPreviewType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_file_monitor_event_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_FILE_MONITOR_EVENT_CHANGED, "G_FILE_MONITOR_EVENT_CHANGED", "changed" },
+        { G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT, "G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT", "changes-done-hint" },
+        { G_FILE_MONITOR_EVENT_DELETED, "G_FILE_MONITOR_EVENT_DELETED", "deleted" },
+        { G_FILE_MONITOR_EVENT_CREATED, "G_FILE_MONITOR_EVENT_CREATED", "created" },
+        { G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED, "G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED", "attribute-changed" },
+        { G_FILE_MONITOR_EVENT_PRE_UNMOUNT, "G_FILE_MONITOR_EVENT_PRE_UNMOUNT", "pre-unmount" },
+        { G_FILE_MONITOR_EVENT_UNMOUNTED, "G_FILE_MONITOR_EVENT_UNMOUNTED", "unmounted" },
+        { G_FILE_MONITOR_EVENT_MOVED, "G_FILE_MONITOR_EVENT_MOVED", "moved" },
+        { G_FILE_MONITOR_EVENT_RENAMED, "G_FILE_MONITOR_EVENT_RENAMED", "renamed" },
+        { G_FILE_MONITOR_EVENT_MOVED_IN, "G_FILE_MONITOR_EVENT_MOVED_IN", "moved-in" },
+        { G_FILE_MONITOR_EVENT_MOVED_OUT, "G_FILE_MONITOR_EVENT_MOVED_OUT", "moved-out" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GFileMonitorEvent"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_io_error_enum_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_IO_ERROR_FAILED, "G_IO_ERROR_FAILED", "failed" },
+        { G_IO_ERROR_NOT_FOUND, "G_IO_ERROR_NOT_FOUND", "not-found" },
+        { G_IO_ERROR_EXISTS, "G_IO_ERROR_EXISTS", "exists" },
+        { G_IO_ERROR_IS_DIRECTORY, "G_IO_ERROR_IS_DIRECTORY", "is-directory" },
+        { G_IO_ERROR_NOT_DIRECTORY, "G_IO_ERROR_NOT_DIRECTORY", "not-directory" },
+        { G_IO_ERROR_NOT_EMPTY, "G_IO_ERROR_NOT_EMPTY", "not-empty" },
+        { G_IO_ERROR_NOT_REGULAR_FILE, "G_IO_ERROR_NOT_REGULAR_FILE", "not-regular-file" },
+        { G_IO_ERROR_NOT_SYMBOLIC_LINK, "G_IO_ERROR_NOT_SYMBOLIC_LINK", "not-symbolic-link" },
+        { G_IO_ERROR_NOT_MOUNTABLE_FILE, "G_IO_ERROR_NOT_MOUNTABLE_FILE", "not-mountable-file" },
+        { G_IO_ERROR_FILENAME_TOO_LONG, "G_IO_ERROR_FILENAME_TOO_LONG", "filename-too-long" },
+        { G_IO_ERROR_INVALID_FILENAME, "G_IO_ERROR_INVALID_FILENAME", "invalid-filename" },
+        { G_IO_ERROR_TOO_MANY_LINKS, "G_IO_ERROR_TOO_MANY_LINKS", "too-many-links" },
+        { G_IO_ERROR_NO_SPACE, "G_IO_ERROR_NO_SPACE", "no-space" },
+        { G_IO_ERROR_INVALID_ARGUMENT, "G_IO_ERROR_INVALID_ARGUMENT", "invalid-argument" },
+        { G_IO_ERROR_PERMISSION_DENIED, "G_IO_ERROR_PERMISSION_DENIED", "permission-denied" },
+        { G_IO_ERROR_NOT_SUPPORTED, "G_IO_ERROR_NOT_SUPPORTED", "not-supported" },
+        { G_IO_ERROR_NOT_MOUNTED, "G_IO_ERROR_NOT_MOUNTED", "not-mounted" },
+        { G_IO_ERROR_ALREADY_MOUNTED, "G_IO_ERROR_ALREADY_MOUNTED", "already-mounted" },
+        { G_IO_ERROR_CLOSED, "G_IO_ERROR_CLOSED", "closed" },
+        { G_IO_ERROR_CANCELLED, "G_IO_ERROR_CANCELLED", "cancelled" },
+        { G_IO_ERROR_PENDING, "G_IO_ERROR_PENDING", "pending" },
+        { G_IO_ERROR_READ_ONLY, "G_IO_ERROR_READ_ONLY", "read-only" },
+        { G_IO_ERROR_CANT_CREATE_BACKUP, "G_IO_ERROR_CANT_CREATE_BACKUP", "cant-create-backup" },
+        { G_IO_ERROR_WRONG_ETAG, "G_IO_ERROR_WRONG_ETAG", "wrong-etag" },
+        { G_IO_ERROR_TIMED_OUT, "G_IO_ERROR_TIMED_OUT", "timed-out" },
+        { G_IO_ERROR_WOULD_RECURSE, "G_IO_ERROR_WOULD_RECURSE", "would-recurse" },
+        { G_IO_ERROR_BUSY, "G_IO_ERROR_BUSY", "busy" },
+        { G_IO_ERROR_WOULD_BLOCK, "G_IO_ERROR_WOULD_BLOCK", "would-block" },
+        { G_IO_ERROR_HOST_NOT_FOUND, "G_IO_ERROR_HOST_NOT_FOUND", "host-not-found" },
+        { G_IO_ERROR_WOULD_MERGE, "G_IO_ERROR_WOULD_MERGE", "would-merge" },
+        { G_IO_ERROR_FAILED_HANDLED, "G_IO_ERROR_FAILED_HANDLED", "failed-handled" },
+        { G_IO_ERROR_TOO_MANY_OPEN_FILES, "G_IO_ERROR_TOO_MANY_OPEN_FILES", "too-many-open-files" },
+        { G_IO_ERROR_NOT_INITIALIZED, "G_IO_ERROR_NOT_INITIALIZED", "not-initialized" },
+        { G_IO_ERROR_ADDRESS_IN_USE, "G_IO_ERROR_ADDRESS_IN_USE", "address-in-use" },
+        { G_IO_ERROR_PARTIAL_INPUT, "G_IO_ERROR_PARTIAL_INPUT", "partial-input" },
+        { G_IO_ERROR_INVALID_DATA, "G_IO_ERROR_INVALID_DATA", "invalid-data" },
+        { G_IO_ERROR_DBUS_ERROR, "G_IO_ERROR_DBUS_ERROR", "dbus-error" },
+        { G_IO_ERROR_HOST_UNREACHABLE, "G_IO_ERROR_HOST_UNREACHABLE", "host-unreachable" },
+        { G_IO_ERROR_NETWORK_UNREACHABLE, "G_IO_ERROR_NETWORK_UNREACHABLE", "network-unreachable" },
+        { G_IO_ERROR_CONNECTION_REFUSED, "G_IO_ERROR_CONNECTION_REFUSED", "connection-refused" },
+        { G_IO_ERROR_PROXY_FAILED, "G_IO_ERROR_PROXY_FAILED", "proxy-failed" },
+        { G_IO_ERROR_PROXY_AUTH_FAILED, "G_IO_ERROR_PROXY_AUTH_FAILED", "proxy-auth-failed" },
+        { G_IO_ERROR_PROXY_NEED_AUTH, "G_IO_ERROR_PROXY_NEED_AUTH", "proxy-need-auth" },
+        { G_IO_ERROR_PROXY_NOT_ALLOWED, "G_IO_ERROR_PROXY_NOT_ALLOWED", "proxy-not-allowed" },
+        { G_IO_ERROR_BROKEN_PIPE, "G_IO_ERROR_BROKEN_PIPE", "broken-pipe" },
+        { G_IO_ERROR_CONNECTION_CLOSED, "G_IO_ERROR_CONNECTION_CLOSED", "connection-closed" },
+        { G_IO_ERROR_NOT_CONNECTED, "G_IO_ERROR_NOT_CONNECTED", "not-connected" },
+        { G_IO_ERROR_MESSAGE_TOO_LARGE, "G_IO_ERROR_MESSAGE_TOO_LARGE", "message-too-large" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GIOErrorEnum"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_ask_password_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_ASK_PASSWORD_NEED_PASSWORD, "G_ASK_PASSWORD_NEED_PASSWORD", "need-password" },
+        { G_ASK_PASSWORD_NEED_USERNAME, "G_ASK_PASSWORD_NEED_USERNAME", "need-username" },
+        { G_ASK_PASSWORD_NEED_DOMAIN, "G_ASK_PASSWORD_NEED_DOMAIN", "need-domain" },
+        { G_ASK_PASSWORD_SAVING_SUPPORTED, "G_ASK_PASSWORD_SAVING_SUPPORTED", "saving-supported" },
+        { G_ASK_PASSWORD_ANONYMOUS_SUPPORTED, "G_ASK_PASSWORD_ANONYMOUS_SUPPORTED", "anonymous-supported" },
+        { G_ASK_PASSWORD_TCRYPT, "G_ASK_PASSWORD_TCRYPT", "tcrypt" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GAskPasswordFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_password_save_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_PASSWORD_SAVE_NEVER, "G_PASSWORD_SAVE_NEVER", "never" },
+        { G_PASSWORD_SAVE_FOR_SESSION, "G_PASSWORD_SAVE_FOR_SESSION", "for-session" },
+        { G_PASSWORD_SAVE_PERMANENTLY, "G_PASSWORD_SAVE_PERMANENTLY", "permanently" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GPasswordSave"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_mount_operation_result_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_MOUNT_OPERATION_HANDLED, "G_MOUNT_OPERATION_HANDLED", "handled" },
+        { G_MOUNT_OPERATION_ABORTED, "G_MOUNT_OPERATION_ABORTED", "aborted" },
+        { G_MOUNT_OPERATION_UNHANDLED, "G_MOUNT_OPERATION_UNHANDLED", "unhandled" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GMountOperationResult"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_output_stream_splice_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_OUTPUT_STREAM_SPLICE_NONE, "G_OUTPUT_STREAM_SPLICE_NONE", "none" },
+        { G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE, "G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE", "close-source" },
+        { G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET, "G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET", "close-target" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GOutputStreamSpliceFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_io_stream_splice_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_IO_STREAM_SPLICE_NONE, "G_IO_STREAM_SPLICE_NONE", "none" },
+        { G_IO_STREAM_SPLICE_CLOSE_STREAM1, "G_IO_STREAM_SPLICE_CLOSE_STREAM1", "close-stream1" },
+        { G_IO_STREAM_SPLICE_CLOSE_STREAM2, "G_IO_STREAM_SPLICE_CLOSE_STREAM2", "close-stream2" },
+        { G_IO_STREAM_SPLICE_WAIT_FOR_BOTH, "G_IO_STREAM_SPLICE_WAIT_FOR_BOTH", "wait-for-both" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GIOStreamSpliceFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_emblem_origin_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_EMBLEM_ORIGIN_UNKNOWN, "G_EMBLEM_ORIGIN_UNKNOWN", "unknown" },
+        { G_EMBLEM_ORIGIN_DEVICE, "G_EMBLEM_ORIGIN_DEVICE", "device" },
+        { G_EMBLEM_ORIGIN_LIVEMETADATA, "G_EMBLEM_ORIGIN_LIVEMETADATA", "livemetadata" },
+        { G_EMBLEM_ORIGIN_TAG, "G_EMBLEM_ORIGIN_TAG", "tag" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GEmblemOrigin"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_resolver_error_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_RESOLVER_ERROR_NOT_FOUND, "G_RESOLVER_ERROR_NOT_FOUND", "not-found" },
+        { G_RESOLVER_ERROR_TEMPORARY_FAILURE, "G_RESOLVER_ERROR_TEMPORARY_FAILURE", "temporary-failure" },
+        { G_RESOLVER_ERROR_INTERNAL, "G_RESOLVER_ERROR_INTERNAL", "internal" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GResolverError"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_resolver_record_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_RESOLVER_RECORD_SRV, "G_RESOLVER_RECORD_SRV", "srv" },
+        { G_RESOLVER_RECORD_MX, "G_RESOLVER_RECORD_MX", "mx" },
+        { G_RESOLVER_RECORD_TXT, "G_RESOLVER_RECORD_TXT", "txt" },
+        { G_RESOLVER_RECORD_SOA, "G_RESOLVER_RECORD_SOA", "soa" },
+        { G_RESOLVER_RECORD_NS, "G_RESOLVER_RECORD_NS", "ns" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GResolverRecordType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_resource_error_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_RESOURCE_ERROR_NOT_FOUND, "G_RESOURCE_ERROR_NOT_FOUND", "not-found" },
+        { G_RESOURCE_ERROR_INTERNAL, "G_RESOURCE_ERROR_INTERNAL", "internal" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GResourceError"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_resource_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_RESOURCE_FLAGS_NONE, "G_RESOURCE_FLAGS_NONE", "none" },
+        { G_RESOURCE_FLAGS_COMPRESSED, "G_RESOURCE_FLAGS_COMPRESSED", "compressed" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GResourceFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_resource_lookup_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_RESOURCE_LOOKUP_FLAGS_NONE, "G_RESOURCE_LOOKUP_FLAGS_NONE", "none" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GResourceLookupFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_socket_family_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_SOCKET_FAMILY_INVALID, "G_SOCKET_FAMILY_INVALID", "invalid" },
+        { G_SOCKET_FAMILY_UNIX, "G_SOCKET_FAMILY_UNIX", "unix" },
+        { G_SOCKET_FAMILY_IPV4, "G_SOCKET_FAMILY_IPV4", "ipv4" },
+        { G_SOCKET_FAMILY_IPV6, "G_SOCKET_FAMILY_IPV6", "ipv6" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GSocketFamily"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_socket_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_SOCKET_TYPE_INVALID, "G_SOCKET_TYPE_INVALID", "invalid" },
+        { G_SOCKET_TYPE_STREAM, "G_SOCKET_TYPE_STREAM", "stream" },
+        { G_SOCKET_TYPE_DATAGRAM, "G_SOCKET_TYPE_DATAGRAM", "datagram" },
+        { G_SOCKET_TYPE_SEQPACKET, "G_SOCKET_TYPE_SEQPACKET", "seqpacket" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GSocketType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_socket_msg_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_SOCKET_MSG_NONE, "G_SOCKET_MSG_NONE", "none" },
+        { G_SOCKET_MSG_OOB, "G_SOCKET_MSG_OOB", "oob" },
+        { G_SOCKET_MSG_PEEK, "G_SOCKET_MSG_PEEK", "peek" },
+        { G_SOCKET_MSG_DONTROUTE, "G_SOCKET_MSG_DONTROUTE", "dontroute" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GSocketMsgFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_socket_protocol_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_SOCKET_PROTOCOL_UNKNOWN, "G_SOCKET_PROTOCOL_UNKNOWN", "unknown" },
+        { G_SOCKET_PROTOCOL_DEFAULT, "G_SOCKET_PROTOCOL_DEFAULT", "default" },
+        { G_SOCKET_PROTOCOL_TCP, "G_SOCKET_PROTOCOL_TCP", "tcp" },
+        { G_SOCKET_PROTOCOL_UDP, "G_SOCKET_PROTOCOL_UDP", "udp" },
+        { G_SOCKET_PROTOCOL_SCTP, "G_SOCKET_PROTOCOL_SCTP", "sctp" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GSocketProtocol"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_zlib_compressor_format_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_ZLIB_COMPRESSOR_FORMAT_ZLIB, "G_ZLIB_COMPRESSOR_FORMAT_ZLIB", "zlib" },
+        { G_ZLIB_COMPRESSOR_FORMAT_GZIP, "G_ZLIB_COMPRESSOR_FORMAT_GZIP", "gzip" },
+        { G_ZLIB_COMPRESSOR_FORMAT_RAW, "G_ZLIB_COMPRESSOR_FORMAT_RAW", "raw" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GZlibCompressorFormat"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_unix_socket_address_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_UNIX_SOCKET_ADDRESS_INVALID, "G_UNIX_SOCKET_ADDRESS_INVALID", "invalid" },
+        { G_UNIX_SOCKET_ADDRESS_ANONYMOUS, "G_UNIX_SOCKET_ADDRESS_ANONYMOUS", "anonymous" },
+        { G_UNIX_SOCKET_ADDRESS_PATH, "G_UNIX_SOCKET_ADDRESS_PATH", "path" },
+        { G_UNIX_SOCKET_ADDRESS_ABSTRACT, "G_UNIX_SOCKET_ADDRESS_ABSTRACT", "abstract" },
+        { G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED, "G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED", "abstract-padded" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GUnixSocketAddressType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_bus_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_BUS_TYPE_STARTER, "G_BUS_TYPE_STARTER", "starter" },
+        { G_BUS_TYPE_NONE, "G_BUS_TYPE_NONE", "none" },
+        { G_BUS_TYPE_SYSTEM, "G_BUS_TYPE_SYSTEM", "system" },
+        { G_BUS_TYPE_SESSION, "G_BUS_TYPE_SESSION", "session" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GBusType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_bus_name_owner_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_BUS_NAME_OWNER_FLAGS_NONE, "G_BUS_NAME_OWNER_FLAGS_NONE", "none" },
+        { G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, "G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT", "allow-replacement" },
+        { G_BUS_NAME_OWNER_FLAGS_REPLACE, "G_BUS_NAME_OWNER_FLAGS_REPLACE", "replace" },
+        { G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE, "G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE", "do-not-queue" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GBusNameOwnerFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_bus_name_watcher_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_BUS_NAME_WATCHER_FLAGS_NONE, "G_BUS_NAME_WATCHER_FLAGS_NONE", "none" },
+        { G_BUS_NAME_WATCHER_FLAGS_AUTO_START, "G_BUS_NAME_WATCHER_FLAGS_AUTO_START", "auto-start" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GBusNameWatcherFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_proxy_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_PROXY_FLAGS_NONE, "G_DBUS_PROXY_FLAGS_NONE", "none" },
+        { G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES, "G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES", "do-not-load-properties" },
+        { G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS, "G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS", "do-not-connect-signals" },
+        { G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START, "G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START", "do-not-auto-start" },
+        { G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES, "G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES", "get-invalidated-properties" },
+        { G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION, "G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION", "do-not-auto-start-at-construction" },
+        { G_DBUS_PROXY_FLAGS_NO_MATCH_RULE, "G_DBUS_PROXY_FLAGS_NO_MATCH_RULE", "no-match-rule" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusProxyFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_error_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_DBUS_ERROR_FAILED, "G_DBUS_ERROR_FAILED", "failed" },
+        { G_DBUS_ERROR_NO_MEMORY, "G_DBUS_ERROR_NO_MEMORY", "no-memory" },
+        { G_DBUS_ERROR_SERVICE_UNKNOWN, "G_DBUS_ERROR_SERVICE_UNKNOWN", "service-unknown" },
+        { G_DBUS_ERROR_NAME_HAS_NO_OWNER, "G_DBUS_ERROR_NAME_HAS_NO_OWNER", "name-has-no-owner" },
+        { G_DBUS_ERROR_NO_REPLY, "G_DBUS_ERROR_NO_REPLY", "no-reply" },
+        { G_DBUS_ERROR_IO_ERROR, "G_DBUS_ERROR_IO_ERROR", "io-error" },
+        { G_DBUS_ERROR_BAD_ADDRESS, "G_DBUS_ERROR_BAD_ADDRESS", "bad-address" },
+        { G_DBUS_ERROR_NOT_SUPPORTED, "G_DBUS_ERROR_NOT_SUPPORTED", "not-supported" },
+        { G_DBUS_ERROR_LIMITS_EXCEEDED, "G_DBUS_ERROR_LIMITS_EXCEEDED", "limits-exceeded" },
+        { G_DBUS_ERROR_ACCESS_DENIED, "G_DBUS_ERROR_ACCESS_DENIED", "access-denied" },
+        { G_DBUS_ERROR_AUTH_FAILED, "G_DBUS_ERROR_AUTH_FAILED", "auth-failed" },
+        { G_DBUS_ERROR_NO_SERVER, "G_DBUS_ERROR_NO_SERVER", "no-server" },
+        { G_DBUS_ERROR_TIMEOUT, "G_DBUS_ERROR_TIMEOUT", "timeout" },
+        { G_DBUS_ERROR_NO_NETWORK, "G_DBUS_ERROR_NO_NETWORK", "no-network" },
+        { G_DBUS_ERROR_ADDRESS_IN_USE, "G_DBUS_ERROR_ADDRESS_IN_USE", "address-in-use" },
+        { G_DBUS_ERROR_DISCONNECTED, "G_DBUS_ERROR_DISCONNECTED", "disconnected" },
+        { G_DBUS_ERROR_INVALID_ARGS, "G_DBUS_ERROR_INVALID_ARGS", "invalid-args" },
+        { G_DBUS_ERROR_FILE_NOT_FOUND, "G_DBUS_ERROR_FILE_NOT_FOUND", "file-not-found" },
+        { G_DBUS_ERROR_FILE_EXISTS, "G_DBUS_ERROR_FILE_EXISTS", "file-exists" },
+        { G_DBUS_ERROR_UNKNOWN_METHOD, "G_DBUS_ERROR_UNKNOWN_METHOD", "unknown-method" },
+        { G_DBUS_ERROR_TIMED_OUT, "G_DBUS_ERROR_TIMED_OUT", "timed-out" },
+        { G_DBUS_ERROR_MATCH_RULE_NOT_FOUND, "G_DBUS_ERROR_MATCH_RULE_NOT_FOUND", "match-rule-not-found" },
+        { G_DBUS_ERROR_MATCH_RULE_INVALID, "G_DBUS_ERROR_MATCH_RULE_INVALID", "match-rule-invalid" },
+        { G_DBUS_ERROR_SPAWN_EXEC_FAILED, "G_DBUS_ERROR_SPAWN_EXEC_FAILED", "spawn-exec-failed" },
+        { G_DBUS_ERROR_SPAWN_FORK_FAILED, "G_DBUS_ERROR_SPAWN_FORK_FAILED", "spawn-fork-failed" },
+        { G_DBUS_ERROR_SPAWN_CHILD_EXITED, "G_DBUS_ERROR_SPAWN_CHILD_EXITED", "spawn-child-exited" },
+        { G_DBUS_ERROR_SPAWN_CHILD_SIGNALED, "G_DBUS_ERROR_SPAWN_CHILD_SIGNALED", "spawn-child-signaled" },
+        { G_DBUS_ERROR_SPAWN_FAILED, "G_DBUS_ERROR_SPAWN_FAILED", "spawn-failed" },
+        { G_DBUS_ERROR_SPAWN_SETUP_FAILED, "G_DBUS_ERROR_SPAWN_SETUP_FAILED", "spawn-setup-failed" },
+        { G_DBUS_ERROR_SPAWN_CONFIG_INVALID, "G_DBUS_ERROR_SPAWN_CONFIG_INVALID", "spawn-config-invalid" },
+        { G_DBUS_ERROR_SPAWN_SERVICE_INVALID, "G_DBUS_ERROR_SPAWN_SERVICE_INVALID", "spawn-service-invalid" },
+        { G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND, "G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND", "spawn-service-not-found" },
+        { G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID, "G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID", "spawn-permissions-invalid" },
+        { G_DBUS_ERROR_SPAWN_FILE_INVALID, "G_DBUS_ERROR_SPAWN_FILE_INVALID", "spawn-file-invalid" },
+        { G_DBUS_ERROR_SPAWN_NO_MEMORY, "G_DBUS_ERROR_SPAWN_NO_MEMORY", "spawn-no-memory" },
+        { G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN, "G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN", "unix-process-id-unknown" },
+        { G_DBUS_ERROR_INVALID_SIGNATURE, "G_DBUS_ERROR_INVALID_SIGNATURE", "invalid-signature" },
+        { G_DBUS_ERROR_INVALID_FILE_CONTENT, "G_DBUS_ERROR_INVALID_FILE_CONTENT", "invalid-file-content" },
+        { G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN, "G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN", "selinux-security-context-unknown" },
+        { G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN, "G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN", "adt-audit-data-unknown" },
+        { G_DBUS_ERROR_OBJECT_PATH_IN_USE, "G_DBUS_ERROR_OBJECT_PATH_IN_USE", "object-path-in-use" },
+        { G_DBUS_ERROR_UNKNOWN_OBJECT, "G_DBUS_ERROR_UNKNOWN_OBJECT", "unknown-object" },
+        { G_DBUS_ERROR_UNKNOWN_INTERFACE, "G_DBUS_ERROR_UNKNOWN_INTERFACE", "unknown-interface" },
+        { G_DBUS_ERROR_UNKNOWN_PROPERTY, "G_DBUS_ERROR_UNKNOWN_PROPERTY", "unknown-property" },
+        { G_DBUS_ERROR_PROPERTY_READ_ONLY, "G_DBUS_ERROR_PROPERTY_READ_ONLY", "property-read-only" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GDBusError"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_connection_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_CONNECTION_FLAGS_NONE, "G_DBUS_CONNECTION_FLAGS_NONE", "none" },
+        { G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT, "G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT", "authentication-client" },
+        { G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER, "G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER", "authentication-server" },
+        { G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS, "G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS", "authentication-allow-anonymous" },
+        { G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION, "G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION", "message-bus-connection" },
+        { G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, "G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING", "delay-message-processing" },
+        { G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER, "G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER", "authentication-require-same-user" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusConnectionFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_capability_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_CAPABILITY_FLAGS_NONE, "G_DBUS_CAPABILITY_FLAGS_NONE", "none" },
+        { G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING, "G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING", "unix-fd-passing" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusCapabilityFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_call_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_CALL_FLAGS_NONE, "G_DBUS_CALL_FLAGS_NONE", "none" },
+        { G_DBUS_CALL_FLAGS_NO_AUTO_START, "G_DBUS_CALL_FLAGS_NO_AUTO_START", "no-auto-start" },
+        { G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION, "G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION", "allow-interactive-authorization" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusCallFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_message_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_DBUS_MESSAGE_TYPE_INVALID, "G_DBUS_MESSAGE_TYPE_INVALID", "invalid" },
+        { G_DBUS_MESSAGE_TYPE_METHOD_CALL, "G_DBUS_MESSAGE_TYPE_METHOD_CALL", "method-call" },
+        { G_DBUS_MESSAGE_TYPE_METHOD_RETURN, "G_DBUS_MESSAGE_TYPE_METHOD_RETURN", "method-return" },
+        { G_DBUS_MESSAGE_TYPE_ERROR, "G_DBUS_MESSAGE_TYPE_ERROR", "error" },
+        { G_DBUS_MESSAGE_TYPE_SIGNAL, "G_DBUS_MESSAGE_TYPE_SIGNAL", "signal" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GDBusMessageType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_message_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_MESSAGE_FLAGS_NONE, "G_DBUS_MESSAGE_FLAGS_NONE", "none" },
+        { G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED, "G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED", "no-reply-expected" },
+        { G_DBUS_MESSAGE_FLAGS_NO_AUTO_START, "G_DBUS_MESSAGE_FLAGS_NO_AUTO_START", "no-auto-start" },
+        { G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION, "G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION", "allow-interactive-authorization" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusMessageFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_message_header_field_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_DBUS_MESSAGE_HEADER_FIELD_INVALID, "G_DBUS_MESSAGE_HEADER_FIELD_INVALID", "invalid" },
+        { G_DBUS_MESSAGE_HEADER_FIELD_PATH, "G_DBUS_MESSAGE_HEADER_FIELD_PATH", "path" },
+        { G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE, "G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE", "interface" },
+        { G_DBUS_MESSAGE_HEADER_FIELD_MEMBER, "G_DBUS_MESSAGE_HEADER_FIELD_MEMBER", "member" },
+        { G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME, "G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME", "error-name" },
+        { G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL, "G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL", "reply-serial" },
+        { G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION, "G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION", "destination" },
+        { G_DBUS_MESSAGE_HEADER_FIELD_SENDER, "G_DBUS_MESSAGE_HEADER_FIELD_SENDER", "sender" },
+        { G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE, "G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE", "signature" },
+        { G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS, "G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS", "num-unix-fds" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GDBusMessageHeaderField"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_property_info_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_PROPERTY_INFO_FLAGS_NONE, "G_DBUS_PROPERTY_INFO_FLAGS_NONE", "none" },
+        { G_DBUS_PROPERTY_INFO_FLAGS_READABLE, "G_DBUS_PROPERTY_INFO_FLAGS_READABLE", "readable" },
+        { G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE, "G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE", "writable" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusPropertyInfoFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_subtree_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_SUBTREE_FLAGS_NONE, "G_DBUS_SUBTREE_FLAGS_NONE", "none" },
+        { G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES, "G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES", "dispatch-to-unenumerated-nodes" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusSubtreeFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_server_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_SERVER_FLAGS_NONE, "G_DBUS_SERVER_FLAGS_NONE", "none" },
+        { G_DBUS_SERVER_FLAGS_RUN_IN_THREAD, "G_DBUS_SERVER_FLAGS_RUN_IN_THREAD", "run-in-thread" },
+        { G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS, "G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS", "authentication-allow-anonymous" },
+        { G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER, "G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER", "authentication-require-same-user" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusServerFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_signal_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_SIGNAL_FLAGS_NONE, "G_DBUS_SIGNAL_FLAGS_NONE", "none" },
+        { G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE, "G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE", "no-match-rule" },
+        { G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE, "G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE", "match-arg0-namespace" },
+        { G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH, "G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH", "match-arg0-path" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusSignalFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_send_message_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_SEND_MESSAGE_FLAGS_NONE, "G_DBUS_SEND_MESSAGE_FLAGS_NONE", "none" },
+        { G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL, "G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL", "preserve-serial" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusSendMessageFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_credentials_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_CREDENTIALS_TYPE_INVALID, "G_CREDENTIALS_TYPE_INVALID", "invalid" },
+        { G_CREDENTIALS_TYPE_LINUX_UCRED, "G_CREDENTIALS_TYPE_LINUX_UCRED", "linux-ucred" },
+        { G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED, "G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED", "freebsd-cmsgcred" },
+        { G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED, "G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED", "openbsd-sockpeercred" },
+        { G_CREDENTIALS_TYPE_SOLARIS_UCRED, "G_CREDENTIALS_TYPE_SOLARIS_UCRED", "solaris-ucred" },
+        { G_CREDENTIALS_TYPE_NETBSD_UNPCBID, "G_CREDENTIALS_TYPE_NETBSD_UNPCBID", "netbsd-unpcbid" },
+        { G_CREDENTIALS_TYPE_APPLE_XUCRED, "G_CREDENTIALS_TYPE_APPLE_XUCRED", "apple-xucred" },
+        { G_CREDENTIALS_TYPE_WIN32_PID, "G_CREDENTIALS_TYPE_WIN32_PID", "win32-pid" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GCredentialsType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_message_byte_order_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN, "G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN", "big-endian" },
+        { G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN, "G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN", "little-endian" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GDBusMessageByteOrder"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_application_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_APPLICATION_FLAGS_NONE, "G_APPLICATION_FLAGS_NONE", "flags-none" },
+        { G_APPLICATION_IS_SERVICE, "G_APPLICATION_IS_SERVICE", "is-service" },
+        { G_APPLICATION_IS_LAUNCHER, "G_APPLICATION_IS_LAUNCHER", "is-launcher" },
+        { G_APPLICATION_HANDLES_OPEN, "G_APPLICATION_HANDLES_OPEN", "handles-open" },
+        { G_APPLICATION_HANDLES_COMMAND_LINE, "G_APPLICATION_HANDLES_COMMAND_LINE", "handles-command-line" },
+        { G_APPLICATION_SEND_ENVIRONMENT, "G_APPLICATION_SEND_ENVIRONMENT", "send-environment" },
+        { G_APPLICATION_NON_UNIQUE, "G_APPLICATION_NON_UNIQUE", "non-unique" },
+        { G_APPLICATION_CAN_OVERRIDE_APP_ID, "G_APPLICATION_CAN_OVERRIDE_APP_ID", "can-override-app-id" },
+        { G_APPLICATION_ALLOW_REPLACEMENT, "G_APPLICATION_ALLOW_REPLACEMENT", "allow-replacement" },
+        { G_APPLICATION_REPLACE, "G_APPLICATION_REPLACE", "replace" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GApplicationFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_error_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_TLS_ERROR_UNAVAILABLE, "G_TLS_ERROR_UNAVAILABLE", "unavailable" },
+        { G_TLS_ERROR_MISC, "G_TLS_ERROR_MISC", "misc" },
+        { G_TLS_ERROR_BAD_CERTIFICATE, "G_TLS_ERROR_BAD_CERTIFICATE", "bad-certificate" },
+        { G_TLS_ERROR_NOT_TLS, "G_TLS_ERROR_NOT_TLS", "not-tls" },
+        { G_TLS_ERROR_HANDSHAKE, "G_TLS_ERROR_HANDSHAKE", "handshake" },
+        { G_TLS_ERROR_CERTIFICATE_REQUIRED, "G_TLS_ERROR_CERTIFICATE_REQUIRED", "certificate-required" },
+        { G_TLS_ERROR_EOF, "G_TLS_ERROR_EOF", "eof" },
+        { G_TLS_ERROR_INAPPROPRIATE_FALLBACK, "G_TLS_ERROR_INAPPROPRIATE_FALLBACK", "inappropriate-fallback" },
+        { G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD, "G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD", "bad-certificate-password" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GTlsError"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_certificate_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_TLS_CERTIFICATE_FLAGS_NONE, "G_TLS_CERTIFICATE_FLAGS_NONE", "flags-none" },
+        { G_TLS_CERTIFICATE_UNKNOWN_CA, "G_TLS_CERTIFICATE_UNKNOWN_CA", "unknown-ca" },
+        { G_TLS_CERTIFICATE_BAD_IDENTITY, "G_TLS_CERTIFICATE_BAD_IDENTITY", "bad-identity" },
+        { G_TLS_CERTIFICATE_NOT_ACTIVATED, "G_TLS_CERTIFICATE_NOT_ACTIVATED", "not-activated" },
+        { G_TLS_CERTIFICATE_EXPIRED, "G_TLS_CERTIFICATE_EXPIRED", "expired" },
+        { G_TLS_CERTIFICATE_REVOKED, "G_TLS_CERTIFICATE_REVOKED", "revoked" },
+        { G_TLS_CERTIFICATE_INSECURE, "G_TLS_CERTIFICATE_INSECURE", "insecure" },
+        { G_TLS_CERTIFICATE_GENERIC_ERROR, "G_TLS_CERTIFICATE_GENERIC_ERROR", "generic-error" },
+        { G_TLS_CERTIFICATE_VALIDATE_ALL, "G_TLS_CERTIFICATE_VALIDATE_ALL", "validate-all" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GTlsCertificateFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_authentication_mode_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_TLS_AUTHENTICATION_NONE, "G_TLS_AUTHENTICATION_NONE", "none" },
+        { G_TLS_AUTHENTICATION_REQUESTED, "G_TLS_AUTHENTICATION_REQUESTED", "requested" },
+        { G_TLS_AUTHENTICATION_REQUIRED, "G_TLS_AUTHENTICATION_REQUIRED", "required" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GTlsAuthenticationMode"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_channel_binding_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_TLS_CHANNEL_BINDING_TLS_UNIQUE, "G_TLS_CHANNEL_BINDING_TLS_UNIQUE", "unique" },
+        { G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT, "G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT", "server-end-point" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GTlsChannelBindingType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_channel_binding_error_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED, "G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED", "not-implemented" },
+        { G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE, "G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE", "invalid-state" },
+        { G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE, "G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE", "not-available" },
+        { G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED, "G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED", "not-supported" },
+        { G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR, "G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR", "general-error" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GTlsChannelBindingError"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_rehandshake_mode_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_TLS_REHANDSHAKE_NEVER, "G_TLS_REHANDSHAKE_NEVER", "never" },
+        { G_TLS_REHANDSHAKE_SAFELY, "G_TLS_REHANDSHAKE_SAFELY", "safely" },
+        { G_TLS_REHANDSHAKE_UNSAFELY, "G_TLS_REHANDSHAKE_UNSAFELY", "unsafely" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GTlsRehandshakeMode"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_password_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_TLS_PASSWORD_NONE, "G_TLS_PASSWORD_NONE", "none" },
+        { G_TLS_PASSWORD_RETRY, "G_TLS_PASSWORD_RETRY", "retry" },
+        { G_TLS_PASSWORD_MANY_TRIES, "G_TLS_PASSWORD_MANY_TRIES", "many-tries" },
+        { G_TLS_PASSWORD_FINAL_TRY, "G_TLS_PASSWORD_FINAL_TRY", "final-try" },
+        { G_TLS_PASSWORD_PKCS11_USER, "G_TLS_PASSWORD_PKCS11_USER", "pkcs11-user" },
+        { G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER, "G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER", "pkcs11-security-officer" },
+        { G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC, "G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC", "pkcs11-context-specific" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GTlsPasswordFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_interaction_result_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_TLS_INTERACTION_UNHANDLED, "G_TLS_INTERACTION_UNHANDLED", "unhandled" },
+        { G_TLS_INTERACTION_HANDLED, "G_TLS_INTERACTION_HANDLED", "handled" },
+        { G_TLS_INTERACTION_FAILED, "G_TLS_INTERACTION_FAILED", "failed" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GTlsInteractionResult"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_interface_skeleton_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_INTERFACE_SKELETON_FLAGS_NONE, "G_DBUS_INTERFACE_SKELETON_FLAGS_NONE", "none" },
+        { G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD, "G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD", "handle-method-invocations-in-thread" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusInterfaceSkeletonFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_dbus_object_manager_client_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE, "G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE", "none" },
+        { G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START, "G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START", "do-not-auto-start" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GDBusObjectManagerClientFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_database_verify_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_TLS_DATABASE_VERIFY_NONE, "G_TLS_DATABASE_VERIFY_NONE", "none" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GTlsDatabaseVerifyFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_database_lookup_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_TLS_DATABASE_LOOKUP_NONE, "G_TLS_DATABASE_LOOKUP_NONE", "none" },
+        { G_TLS_DATABASE_LOOKUP_KEYPAIR, "G_TLS_DATABASE_LOOKUP_KEYPAIR", "keypair" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GTlsDatabaseLookupFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_certificate_request_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_TLS_CERTIFICATE_REQUEST_NONE, "G_TLS_CERTIFICATE_REQUEST_NONE", "none" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GTlsCertificateRequestFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_tls_protocol_version_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_TLS_PROTOCOL_VERSION_UNKNOWN, "G_TLS_PROTOCOL_VERSION_UNKNOWN", "unknown" },
+        { G_TLS_PROTOCOL_VERSION_SSL_3_0, "G_TLS_PROTOCOL_VERSION_SSL_3_0", "ssl-3-0" },
+        { G_TLS_PROTOCOL_VERSION_TLS_1_0, "G_TLS_PROTOCOL_VERSION_TLS_1_0", "tls-1-0" },
+        { G_TLS_PROTOCOL_VERSION_TLS_1_1, "G_TLS_PROTOCOL_VERSION_TLS_1_1", "tls-1-1" },
+        { G_TLS_PROTOCOL_VERSION_TLS_1_2, "G_TLS_PROTOCOL_VERSION_TLS_1_2", "tls-1-2" },
+        { G_TLS_PROTOCOL_VERSION_TLS_1_3, "G_TLS_PROTOCOL_VERSION_TLS_1_3", "tls-1-3" },
+        { G_TLS_PROTOCOL_VERSION_DTLS_1_0, "G_TLS_PROTOCOL_VERSION_DTLS_1_0", "dtls-1-0" },
+        { G_TLS_PROTOCOL_VERSION_DTLS_1_2, "G_TLS_PROTOCOL_VERSION_DTLS_1_2", "dtls-1-2" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GTlsProtocolVersion"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_io_module_scope_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_IO_MODULE_SCOPE_NONE, "G_IO_MODULE_SCOPE_NONE", "none" },
+        { G_IO_MODULE_SCOPE_BLOCK_DUPLICATES, "G_IO_MODULE_SCOPE_BLOCK_DUPLICATES", "block-duplicates" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GIOModuleScopeFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_socket_client_event_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_SOCKET_CLIENT_RESOLVING, "G_SOCKET_CLIENT_RESOLVING", "resolving" },
+        { G_SOCKET_CLIENT_RESOLVED, "G_SOCKET_CLIENT_RESOLVED", "resolved" },
+        { G_SOCKET_CLIENT_CONNECTING, "G_SOCKET_CLIENT_CONNECTING", "connecting" },
+        { G_SOCKET_CLIENT_CONNECTED, "G_SOCKET_CLIENT_CONNECTED", "connected" },
+        { G_SOCKET_CLIENT_PROXY_NEGOTIATING, "G_SOCKET_CLIENT_PROXY_NEGOTIATING", "proxy-negotiating" },
+        { G_SOCKET_CLIENT_PROXY_NEGOTIATED, "G_SOCKET_CLIENT_PROXY_NEGOTIATED", "proxy-negotiated" },
+        { G_SOCKET_CLIENT_TLS_HANDSHAKING, "G_SOCKET_CLIENT_TLS_HANDSHAKING", "tls-handshaking" },
+        { G_SOCKET_CLIENT_TLS_HANDSHAKED, "G_SOCKET_CLIENT_TLS_HANDSHAKED", "tls-handshaked" },
+        { G_SOCKET_CLIENT_COMPLETE, "G_SOCKET_CLIENT_COMPLETE", "complete" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GSocketClientEvent"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_socket_listener_event_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_SOCKET_LISTENER_BINDING, "G_SOCKET_LISTENER_BINDING", "binding" },
+        { G_SOCKET_LISTENER_BOUND, "G_SOCKET_LISTENER_BOUND", "bound" },
+        { G_SOCKET_LISTENER_LISTENING, "G_SOCKET_LISTENER_LISTENING", "listening" },
+        { G_SOCKET_LISTENER_LISTENED, "G_SOCKET_LISTENER_LISTENED", "listened" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GSocketListenerEvent"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_test_dbus_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_TEST_DBUS_NONE, "G_TEST_DBUS_NONE", "none" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GTestDBusFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_subprocess_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_SUBPROCESS_FLAGS_NONE, "G_SUBPROCESS_FLAGS_NONE", "none" },
+        { G_SUBPROCESS_FLAGS_STDIN_PIPE, "G_SUBPROCESS_FLAGS_STDIN_PIPE", "stdin-pipe" },
+        { G_SUBPROCESS_FLAGS_STDIN_INHERIT, "G_SUBPROCESS_FLAGS_STDIN_INHERIT", "stdin-inherit" },
+        { G_SUBPROCESS_FLAGS_STDOUT_PIPE, "G_SUBPROCESS_FLAGS_STDOUT_PIPE", "stdout-pipe" },
+        { G_SUBPROCESS_FLAGS_STDOUT_SILENCE, "G_SUBPROCESS_FLAGS_STDOUT_SILENCE", "stdout-silence" },
+        { G_SUBPROCESS_FLAGS_STDERR_PIPE, "G_SUBPROCESS_FLAGS_STDERR_PIPE", "stderr-pipe" },
+        { G_SUBPROCESS_FLAGS_STDERR_SILENCE, "G_SUBPROCESS_FLAGS_STDERR_SILENCE", "stderr-silence" },
+        { G_SUBPROCESS_FLAGS_STDERR_MERGE, "G_SUBPROCESS_FLAGS_STDERR_MERGE", "stderr-merge" },
+        { G_SUBPROCESS_FLAGS_INHERIT_FDS, "G_SUBPROCESS_FLAGS_INHERIT_FDS", "inherit-fds" },
+        { G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP, "G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP", "search-path-from-envp" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GSubprocessFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_notification_priority_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_NOTIFICATION_PRIORITY_NORMAL, "G_NOTIFICATION_PRIORITY_NORMAL", "normal" },
+        { G_NOTIFICATION_PRIORITY_LOW, "G_NOTIFICATION_PRIORITY_LOW", "low" },
+        { G_NOTIFICATION_PRIORITY_HIGH, "G_NOTIFICATION_PRIORITY_HIGH", "high" },
+        { G_NOTIFICATION_PRIORITY_URGENT, "G_NOTIFICATION_PRIORITY_URGENT", "urgent" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GNotificationPriority"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_network_connectivity_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_NETWORK_CONNECTIVITY_LOCAL, "G_NETWORK_CONNECTIVITY_LOCAL", "local" },
+        { G_NETWORK_CONNECTIVITY_LIMITED, "G_NETWORK_CONNECTIVITY_LIMITED", "limited" },
+        { G_NETWORK_CONNECTIVITY_PORTAL, "G_NETWORK_CONNECTIVITY_PORTAL", "portal" },
+        { G_NETWORK_CONNECTIVITY_FULL, "G_NETWORK_CONNECTIVITY_FULL", "full" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GNetworkConnectivity"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_pollable_return_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_POLLABLE_RETURN_FAILED, "G_POLLABLE_RETURN_FAILED", "failed" },
+        { G_POLLABLE_RETURN_OK, "G_POLLABLE_RETURN_OK", "ok" },
+        { G_POLLABLE_RETURN_WOULD_BLOCK, "G_POLLABLE_RETURN_WOULD_BLOCK", "would-block" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GPollableReturn"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_memory_monitor_warning_level_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_MEMORY_MONITOR_WARNING_LEVEL_LOW, "G_MEMORY_MONITOR_WARNING_LEVEL_LOW", "low" },
+        { G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM, "G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM", "medium" },
+        { G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL, "G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL", "critical" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GMemoryMonitorWarningLevel"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+/* enumerations from "../gio/gresolver.h" */
+GType
+g_resolver_name_lookup_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT, "G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT", "default" },
+        { G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY, "G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY", "ipv4-only" },
+        { G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY, "G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY", "ipv6-only" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GResolverNameLookupFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+/* enumerations from "../gio/gsettings.h" */
+GType
+g_settings_bind_flags_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GFlagsValue values[] = {
+        { G_SETTINGS_BIND_DEFAULT, "G_SETTINGS_BIND_DEFAULT", "default" },
+        { G_SETTINGS_BIND_GET, "G_SETTINGS_BIND_GET", "get" },
+        { G_SETTINGS_BIND_SET, "G_SETTINGS_BIND_SET", "set" },
+        { G_SETTINGS_BIND_NO_SENSITIVITY, "G_SETTINGS_BIND_NO_SENSITIVITY", "no-sensitivity" },
+        { G_SETTINGS_BIND_GET_NO_CHANGES, "G_SETTINGS_BIND_GET_NO_CHANGES", "get-no-changes" },
+        { G_SETTINGS_BIND_INVERT_BOOLEAN, "G_SETTINGS_BIND_INVERT_BOOLEAN", "invert-boolean" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("GSettingsBindFlags"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+
+/* Generated data ends here */
+
diff --git a/gio/gioenumtypes.h b/gio/gioenumtypes.h
new file mode 100644
index 0000000..dd4e2c1
--- /dev/null
+++ b/gio/gioenumtypes.h
@@ -0,0 +1,185 @@
+
+/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */
+
+#ifndef __GIO_ENUM_TYPES_H__
+#define __GIO_ENUM_TYPES_H__
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+/* enumerations from "../gio/gioenums.h" */
+GLIB_AVAILABLE_IN_ALL GType g_app_info_create_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_APP_INFO_CREATE_FLAGS (g_app_info_create_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_converter_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_CONVERTER_FLAGS (g_converter_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_converter_result_get_type (void) G_GNUC_CONST;
+#define G_TYPE_CONVERTER_RESULT (g_converter_result_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_data_stream_byte_order_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DATA_STREAM_BYTE_ORDER (g_data_stream_byte_order_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_data_stream_newline_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DATA_STREAM_NEWLINE_TYPE (g_data_stream_newline_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_file_attribute_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILE_ATTRIBUTE_TYPE (g_file_attribute_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_file_attribute_info_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILE_ATTRIBUTE_INFO_FLAGS (g_file_attribute_info_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_file_attribute_status_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILE_ATTRIBUTE_STATUS (g_file_attribute_status_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_file_query_info_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILE_QUERY_INFO_FLAGS (g_file_query_info_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_file_create_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILE_CREATE_FLAGS (g_file_create_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_file_measure_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILE_MEASURE_FLAGS (g_file_measure_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_mount_mount_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_MOUNT_MOUNT_FLAGS (g_mount_mount_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_mount_unmount_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_MOUNT_UNMOUNT_FLAGS (g_mount_unmount_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_drive_start_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DRIVE_START_FLAGS (g_drive_start_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_drive_start_stop_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DRIVE_START_STOP_TYPE (g_drive_start_stop_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_file_copy_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILE_COPY_FLAGS (g_file_copy_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_file_monitor_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILE_MONITOR_FLAGS (g_file_monitor_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_file_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILE_TYPE (g_file_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_filesystem_preview_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILESYSTEM_PREVIEW_TYPE (g_filesystem_preview_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_file_monitor_event_get_type (void) G_GNUC_CONST;
+#define G_TYPE_FILE_MONITOR_EVENT (g_file_monitor_event_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_io_error_enum_get_type (void) G_GNUC_CONST;
+#define G_TYPE_IO_ERROR_ENUM (g_io_error_enum_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_ask_password_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_ASK_PASSWORD_FLAGS (g_ask_password_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_password_save_get_type (void) G_GNUC_CONST;
+#define G_TYPE_PASSWORD_SAVE (g_password_save_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_mount_operation_result_get_type (void) G_GNUC_CONST;
+#define G_TYPE_MOUNT_OPERATION_RESULT (g_mount_operation_result_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_output_stream_splice_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_OUTPUT_STREAM_SPLICE_FLAGS (g_output_stream_splice_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_io_stream_splice_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_IO_STREAM_SPLICE_FLAGS (g_io_stream_splice_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_emblem_origin_get_type (void) G_GNUC_CONST;
+#define G_TYPE_EMBLEM_ORIGIN (g_emblem_origin_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_resolver_error_get_type (void) G_GNUC_CONST;
+#define G_TYPE_RESOLVER_ERROR (g_resolver_error_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_resolver_record_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_RESOLVER_RECORD_TYPE (g_resolver_record_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_resource_error_get_type (void) G_GNUC_CONST;
+#define G_TYPE_RESOURCE_ERROR (g_resource_error_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_resource_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_RESOURCE_FLAGS (g_resource_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_resource_lookup_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_RESOURCE_LOOKUP_FLAGS (g_resource_lookup_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_socket_family_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SOCKET_FAMILY (g_socket_family_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_socket_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SOCKET_TYPE (g_socket_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_socket_msg_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SOCKET_MSG_FLAGS (g_socket_msg_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_socket_protocol_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SOCKET_PROTOCOL (g_socket_protocol_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_zlib_compressor_format_get_type (void) G_GNUC_CONST;
+#define G_TYPE_ZLIB_COMPRESSOR_FORMAT (g_zlib_compressor_format_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_unix_socket_address_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_UNIX_SOCKET_ADDRESS_TYPE (g_unix_socket_address_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_bus_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_BUS_TYPE (g_bus_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_bus_name_owner_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_BUS_NAME_OWNER_FLAGS (g_bus_name_owner_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_bus_name_watcher_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_BUS_NAME_WATCHER_FLAGS (g_bus_name_watcher_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_proxy_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_PROXY_FLAGS (g_dbus_proxy_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_error_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_ERROR (g_dbus_error_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_connection_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_CONNECTION_FLAGS (g_dbus_connection_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_capability_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_CAPABILITY_FLAGS (g_dbus_capability_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_call_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_CALL_FLAGS (g_dbus_call_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_message_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_MESSAGE_TYPE (g_dbus_message_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_message_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_MESSAGE_FLAGS (g_dbus_message_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_message_header_field_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_MESSAGE_HEADER_FIELD (g_dbus_message_header_field_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_property_info_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_PROPERTY_INFO_FLAGS (g_dbus_property_info_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_subtree_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_SUBTREE_FLAGS (g_dbus_subtree_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_server_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_SERVER_FLAGS (g_dbus_server_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_signal_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_SIGNAL_FLAGS (g_dbus_signal_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_send_message_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_SEND_MESSAGE_FLAGS (g_dbus_send_message_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_credentials_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_CREDENTIALS_TYPE (g_credentials_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_message_byte_order_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_MESSAGE_BYTE_ORDER (g_dbus_message_byte_order_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_application_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_APPLICATION_FLAGS (g_application_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_error_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_ERROR (g_tls_error_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_certificate_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_CERTIFICATE_FLAGS (g_tls_certificate_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_authentication_mode_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_AUTHENTICATION_MODE (g_tls_authentication_mode_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_channel_binding_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_CHANNEL_BINDING_TYPE (g_tls_channel_binding_type_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_channel_binding_error_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_CHANNEL_BINDING_ERROR (g_tls_channel_binding_error_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_rehandshake_mode_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_REHANDSHAKE_MODE (g_tls_rehandshake_mode_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_password_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_PASSWORD_FLAGS (g_tls_password_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_interaction_result_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_INTERACTION_RESULT (g_tls_interaction_result_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_interface_skeleton_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_INTERFACE_SKELETON_FLAGS (g_dbus_interface_skeleton_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_dbus_object_manager_client_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_DBUS_OBJECT_MANAGER_CLIENT_FLAGS (g_dbus_object_manager_client_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_database_verify_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_DATABASE_VERIFY_FLAGS (g_tls_database_verify_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_database_lookup_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_DATABASE_LOOKUP_FLAGS (g_tls_database_lookup_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_certificate_request_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_CERTIFICATE_REQUEST_FLAGS (g_tls_certificate_request_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_tls_protocol_version_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TLS_PROTOCOL_VERSION (g_tls_protocol_version_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_io_module_scope_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_IO_MODULE_SCOPE_FLAGS (g_io_module_scope_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_socket_client_event_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SOCKET_CLIENT_EVENT (g_socket_client_event_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_socket_listener_event_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SOCKET_LISTENER_EVENT (g_socket_listener_event_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_test_dbus_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_TEST_DBUS_FLAGS (g_test_dbus_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_subprocess_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SUBPROCESS_FLAGS (g_subprocess_flags_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_notification_priority_get_type (void) G_GNUC_CONST;
+#define G_TYPE_NOTIFICATION_PRIORITY (g_notification_priority_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_network_connectivity_get_type (void) G_GNUC_CONST;
+#define G_TYPE_NETWORK_CONNECTIVITY (g_network_connectivity_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_pollable_return_get_type (void) G_GNUC_CONST;
+#define G_TYPE_POLLABLE_RETURN (g_pollable_return_get_type ())
+GLIB_AVAILABLE_IN_ALL GType g_memory_monitor_warning_level_get_type (void) G_GNUC_CONST;
+#define G_TYPE_MEMORY_MONITOR_WARNING_LEVEL (g_memory_monitor_warning_level_get_type ())
+
+/* enumerations from "../gio/gresolver.h" */
+GLIB_AVAILABLE_IN_ALL GType g_resolver_name_lookup_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_RESOLVER_NAME_LOOKUP_FLAGS (g_resolver_name_lookup_flags_get_type ())
+
+/* enumerations from "../gio/gsettings.h" */
+GLIB_AVAILABLE_IN_ALL GType g_settings_bind_flags_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SETTINGS_BIND_FLAGS (g_settings_bind_flags_get_type ())
+G_END_DECLS
+
+#endif /* __GIO_ENUM_TYPES_H__ */
+
+/* Generated data ends here */
+
diff --git a/gio/gnetworking.h b/gio/gnetworking.h
new file mode 100644
index 0000000..1f1124a
--- /dev/null
+++ b/gio/gnetworking.h
@@ -0,0 +1,78 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008-2011 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __G_NETWORKING_H__
+#define __G_NETWORKING_H__
+
+#include <glib.h>
+
+#ifdef G_OS_WIN32
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <windns.h>
+#include <mswsock.h>
+#include <wspiapi.h>
+#include <iphlpapi.h>
+#undef interface
+
+#else /* !G_OS_WIN32 */
+
+#include <sys/types.h>
+
+#include <netdb.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <resolv.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <net/if.h>
+
+#include <arpa/inet.h>
+#include <arpa/nameser.h>
+
+
+#ifndef T_SRV
+#define T_SRV 33
+#endif
+
+#ifndef _PATH_RESCONF
+#define _PATH_RESCONF "/etc/resolv.conf"
+#endif
+
+#ifndef CMSG_LEN
+/* CMSG_LEN and CMSG_SPACE are defined by RFC 2292, but missing on
+ * some older platforms.
+ */
+#define CMSG_LEN(len) ((size_t)CMSG_DATA((struct cmsghdr *)NULL) + (len))
+
+/* CMSG_SPACE must add at least as much padding as CMSG_NXTHDR()
+ * adds. We overestimate here.
+ */
+#define GLIB_ALIGN_TO_SIZEOF(len, obj) (((len) + sizeof (obj) - 1) & ~(sizeof (obj) - 1))
+#define CMSG_SPACE(len) GLIB_ALIGN_TO_SIZEOF (CMSG_LEN (len), struct cmsghdr)
+#endif
+#endif
+
+G_BEGIN_DECLS
+
+GLIB_AVAILABLE_IN_2_36
+void g_networking_init (void);
+
+G_END_DECLS
+
+#endif /* __G_NETWORKING_H__ */
diff --git a/gio/xdp-dbus.c b/gio/xdp-dbus.c
new file mode 100644
index 0000000..3e9dbff
--- /dev/null
+++ b/gio/xdp-dbus.c
@@ -0,0 +1,7909 @@
+/*
+ * This file is generated by gdbus-codegen, do not modify it.
+ *
+ * The license of this code is the same as for the D-Bus interface description
+ * it was derived from. Note that it links to GLib, so must comply with the
+ * LGPL linking clauses.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "xdp-dbus.h"
+
+#include <string.h>
+#ifdef G_OS_UNIX
+#  include <gio/gunixfdlist.h>
+#endif
+
+typedef struct
+{
+  GDBusArgInfo parent_struct;
+  gboolean use_gvariant;
+} _ExtendedGDBusArgInfo;
+
+typedef struct
+{
+  GDBusMethodInfo parent_struct;
+  const gchar *signal_name;
+  gboolean pass_fdlist;
+} _ExtendedGDBusMethodInfo;
+
+typedef struct
+{
+  GDBusSignalInfo parent_struct;
+  const gchar *signal_name;
+} _ExtendedGDBusSignalInfo;
+
+typedef struct
+{
+  GDBusPropertyInfo parent_struct;
+  const gchar *hyphen_name;
+  guint use_gvariant : 1;
+  guint emits_changed_signal : 1;
+} _ExtendedGDBusPropertyInfo;
+
+typedef struct
+{
+  GDBusInterfaceInfo parent_struct;
+  const gchar *hyphen_name;
+} _ExtendedGDBusInterfaceInfo;
+
+typedef struct
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  guint prop_id;
+  GValue orig_value; /* the value before the change */
+} ChangedProperty;
+
+static void
+_changed_property_free (ChangedProperty *data)
+{
+  g_value_unset (&data->orig_value);
+  g_free (data);
+}
+
+static gboolean
+_g_strv_equal0 (gchar **a, gchar **b)
+{
+  gboolean ret = FALSE;
+  guint n;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  if (g_strv_length (a) != g_strv_length (b))
+    goto out;
+  for (n = 0; a[n] != NULL; n++)
+    if (g_strcmp0 (a[n], b[n]) != 0)
+      goto out;
+  ret = TRUE;
+out:
+  return ret;
+}
+
+static gboolean
+_g_variant_equal0 (GVariant *a, GVariant *b)
+{
+  gboolean ret = FALSE;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  ret = g_variant_equal (a, b);
+out:
+  return ret;
+}
+
+G_GNUC_UNUSED static gboolean
+_g_value_equal (const GValue *a, const GValue *b)
+{
+  gboolean ret = FALSE;
+  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
+  switch (G_VALUE_TYPE (a))
+    {
+      case G_TYPE_BOOLEAN:
+        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
+        break;
+      case G_TYPE_UCHAR:
+        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
+        break;
+      case G_TYPE_INT:
+        ret = (g_value_get_int (a) == g_value_get_int (b));
+        break;
+      case G_TYPE_UINT:
+        ret = (g_value_get_uint (a) == g_value_get_uint (b));
+        break;
+      case G_TYPE_INT64:
+        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
+        break;
+      case G_TYPE_UINT64:
+        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
+        break;
+      case G_TYPE_DOUBLE:
+        {
+          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
+          gdouble da = g_value_get_double (a);
+          gdouble db = g_value_get_double (b);
+          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
+        }
+        break;
+      case G_TYPE_STRING:
+        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
+        break;
+      case G_TYPE_VARIANT:
+        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
+        break;
+      default:
+        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
+          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
+        else
+          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
+        break;
+    }
+  return ret;
+}
+
+/* ------------------------------------------------------------------------
+ * Code for interface org.freedesktop.portal.Documents
+ * ------------------------------------------------------------------------
+ */
+
+/**
+ * SECTION:GXdpDocuments
+ * @title: GXdpDocuments
+ * @short_description: Generated C code for the org.freedesktop.portal.Documents D-Bus interface
+ *
+ * This section contains code for working with the <link linkend="gdbus-interface-org-freedesktop-portal-Documents.top_of_page">org.freedesktop.portal.Documents</link> D-Bus interface in C.
+ */
+
+/* ---- Introspection data for org.freedesktop.portal.Documents ---- */
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_get_mount_point_OUT_ARG_path =
+{
+  {
+    -1,
+    (gchar *) "path",
+    (gchar *) "ay",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_get_mount_point_OUT_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_get_mount_point_OUT_ARG_path.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_get_mount_point =
+{
+  {
+    -1,
+    (gchar *) "GetMountPoint",
+    NULL,
+    (GDBusArgInfo **) &_gxdp_documents_method_info_get_mount_point_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-get-mount-point",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_IN_ARG_o_path_fd =
+{
+  {
+    -1,
+    (gchar *) "o_path_fd",
+    (gchar *) "h",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_IN_ARG_reuse_existing =
+{
+  {
+    -1,
+    (gchar *) "reuse_existing",
+    (gchar *) "b",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_IN_ARG_persistent =
+{
+  {
+    -1,
+    (gchar *) "persistent",
+    (gchar *) "b",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_add_IN_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_add_IN_ARG_o_path_fd.parent_struct,
+  &_gxdp_documents_method_info_add_IN_ARG_reuse_existing.parent_struct,
+  &_gxdp_documents_method_info_add_IN_ARG_persistent.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_OUT_ARG_doc_id =
+{
+  {
+    -1,
+    (gchar *) "doc_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_add_OUT_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_add_OUT_ARG_doc_id.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_add =
+{
+  {
+    -1,
+    (gchar *) "Add",
+    (GDBusArgInfo **) &_gxdp_documents_method_info_add_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_documents_method_info_add_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-add",
+  TRUE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_IN_ARG_o_path_parent_fd =
+{
+  {
+    -1,
+    (gchar *) "o_path_parent_fd",
+    (gchar *) "h",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_IN_ARG_filename =
+{
+  {
+    -1,
+    (gchar *) "filename",
+    (gchar *) "ay",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_IN_ARG_reuse_existing =
+{
+  {
+    -1,
+    (gchar *) "reuse_existing",
+    (gchar *) "b",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_IN_ARG_persistent =
+{
+  {
+    -1,
+    (gchar *) "persistent",
+    (gchar *) "b",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_add_named_IN_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_add_named_IN_ARG_o_path_parent_fd.parent_struct,
+  &_gxdp_documents_method_info_add_named_IN_ARG_filename.parent_struct,
+  &_gxdp_documents_method_info_add_named_IN_ARG_reuse_existing.parent_struct,
+  &_gxdp_documents_method_info_add_named_IN_ARG_persistent.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_OUT_ARG_doc_id =
+{
+  {
+    -1,
+    (gchar *) "doc_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_add_named_OUT_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_add_named_OUT_ARG_doc_id.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_add_named =
+{
+  {
+    -1,
+    (gchar *) "AddNamed",
+    (GDBusArgInfo **) &_gxdp_documents_method_info_add_named_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_documents_method_info_add_named_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-add-named",
+  TRUE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_full_IN_ARG_o_path_fds =
+{
+  {
+    -1,
+    (gchar *) "o_path_fds",
+    (gchar *) "ah",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_full_IN_ARG_flags =
+{
+  {
+    -1,
+    (gchar *) "flags",
+    (gchar *) "u",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_full_IN_ARG_app_id =
+{
+  {
+    -1,
+    (gchar *) "app_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_full_IN_ARG_permissions =
+{
+  {
+    -1,
+    (gchar *) "permissions",
+    (gchar *) "as",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_add_full_IN_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_add_full_IN_ARG_o_path_fds.parent_struct,
+  &_gxdp_documents_method_info_add_full_IN_ARG_flags.parent_struct,
+  &_gxdp_documents_method_info_add_full_IN_ARG_app_id.parent_struct,
+  &_gxdp_documents_method_info_add_full_IN_ARG_permissions.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_full_OUT_ARG_doc_ids =
+{
+  {
+    -1,
+    (gchar *) "doc_ids",
+    (gchar *) "as",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_full_OUT_ARG_extra_out =
+{
+  {
+    -1,
+    (gchar *) "extra_out",
+    (gchar *) "a{sv}",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_add_full_OUT_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_add_full_OUT_ARG_doc_ids.parent_struct,
+  &_gxdp_documents_method_info_add_full_OUT_ARG_extra_out.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_add_full =
+{
+  {
+    -1,
+    (gchar *) "AddFull",
+    (GDBusArgInfo **) &_gxdp_documents_method_info_add_full_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_documents_method_info_add_full_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-add-full",
+  TRUE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_full_IN_ARG_o_path_fd =
+{
+  {
+    -1,
+    (gchar *) "o_path_fd",
+    (gchar *) "h",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_full_IN_ARG_filename =
+{
+  {
+    -1,
+    (gchar *) "filename",
+    (gchar *) "ay",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_full_IN_ARG_flags =
+{
+  {
+    -1,
+    (gchar *) "flags",
+    (gchar *) "u",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_full_IN_ARG_app_id =
+{
+  {
+    -1,
+    (gchar *) "app_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_full_IN_ARG_permissions =
+{
+  {
+    -1,
+    (gchar *) "permissions",
+    (gchar *) "as",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_add_named_full_IN_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_add_named_full_IN_ARG_o_path_fd.parent_struct,
+  &_gxdp_documents_method_info_add_named_full_IN_ARG_filename.parent_struct,
+  &_gxdp_documents_method_info_add_named_full_IN_ARG_flags.parent_struct,
+  &_gxdp_documents_method_info_add_named_full_IN_ARG_app_id.parent_struct,
+  &_gxdp_documents_method_info_add_named_full_IN_ARG_permissions.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_full_OUT_ARG_doc_id =
+{
+  {
+    -1,
+    (gchar *) "doc_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_add_named_full_OUT_ARG_extra_out =
+{
+  {
+    -1,
+    (gchar *) "extra_out",
+    (gchar *) "a{sv}",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_add_named_full_OUT_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_add_named_full_OUT_ARG_doc_id.parent_struct,
+  &_gxdp_documents_method_info_add_named_full_OUT_ARG_extra_out.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_add_named_full =
+{
+  {
+    -1,
+    (gchar *) "AddNamedFull",
+    (GDBusArgInfo **) &_gxdp_documents_method_info_add_named_full_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_documents_method_info_add_named_full_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-add-named-full",
+  TRUE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_grant_permissions_IN_ARG_doc_id =
+{
+  {
+    -1,
+    (gchar *) "doc_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_grant_permissions_IN_ARG_app_id =
+{
+  {
+    -1,
+    (gchar *) "app_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_grant_permissions_IN_ARG_permissions =
+{
+  {
+    -1,
+    (gchar *) "permissions",
+    (gchar *) "as",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_grant_permissions_IN_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_grant_permissions_IN_ARG_doc_id.parent_struct,
+  &_gxdp_documents_method_info_grant_permissions_IN_ARG_app_id.parent_struct,
+  &_gxdp_documents_method_info_grant_permissions_IN_ARG_permissions.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_grant_permissions =
+{
+  {
+    -1,
+    (gchar *) "GrantPermissions",
+    (GDBusArgInfo **) &_gxdp_documents_method_info_grant_permissions_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-grant-permissions",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_revoke_permissions_IN_ARG_doc_id =
+{
+  {
+    -1,
+    (gchar *) "doc_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_revoke_permissions_IN_ARG_app_id =
+{
+  {
+    -1,
+    (gchar *) "app_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_revoke_permissions_IN_ARG_permissions =
+{
+  {
+    -1,
+    (gchar *) "permissions",
+    (gchar *) "as",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_revoke_permissions_IN_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_revoke_permissions_IN_ARG_doc_id.parent_struct,
+  &_gxdp_documents_method_info_revoke_permissions_IN_ARG_app_id.parent_struct,
+  &_gxdp_documents_method_info_revoke_permissions_IN_ARG_permissions.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_revoke_permissions =
+{
+  {
+    -1,
+    (gchar *) "RevokePermissions",
+    (GDBusArgInfo **) &_gxdp_documents_method_info_revoke_permissions_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-revoke-permissions",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_delete_IN_ARG_doc_id =
+{
+  {
+    -1,
+    (gchar *) "doc_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_delete_IN_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_delete_IN_ARG_doc_id.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_delete =
+{
+  {
+    -1,
+    (gchar *) "Delete",
+    (GDBusArgInfo **) &_gxdp_documents_method_info_delete_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-delete",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_lookup_IN_ARG_filename =
+{
+  {
+    -1,
+    (gchar *) "filename",
+    (gchar *) "ay",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_lookup_IN_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_lookup_IN_ARG_filename.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_lookup_OUT_ARG_doc_id =
+{
+  {
+    -1,
+    (gchar *) "doc_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_lookup_OUT_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_lookup_OUT_ARG_doc_id.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_lookup =
+{
+  {
+    -1,
+    (gchar *) "Lookup",
+    (GDBusArgInfo **) &_gxdp_documents_method_info_lookup_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_documents_method_info_lookup_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-lookup",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_info_IN_ARG_doc_id =
+{
+  {
+    -1,
+    (gchar *) "doc_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_info_IN_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_info_IN_ARG_doc_id.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_info_OUT_ARG_path =
+{
+  {
+    -1,
+    (gchar *) "path",
+    (gchar *) "ay",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_info_OUT_ARG_apps =
+{
+  {
+    -1,
+    (gchar *) "apps",
+    (gchar *) "a{sas}",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_info_OUT_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_info_OUT_ARG_path.parent_struct,
+  &_gxdp_documents_method_info_info_OUT_ARG_apps.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_info =
+{
+  {
+    -1,
+    (gchar *) "Info",
+    (GDBusArgInfo **) &_gxdp_documents_method_info_info_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_documents_method_info_info_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-info",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_list_IN_ARG_app_id =
+{
+  {
+    -1,
+    (gchar *) "app_id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_list_IN_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_list_IN_ARG_app_id.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_documents_method_info_list_OUT_ARG_docs =
+{
+  {
+    -1,
+    (gchar *) "docs",
+    (gchar *) "a{say}",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_documents_method_info_list_OUT_ARG_pointers[] =
+{
+  &_gxdp_documents_method_info_list_OUT_ARG_docs.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_documents_method_info_list =
+{
+  {
+    -1,
+    (gchar *) "List",
+    (GDBusArgInfo **) &_gxdp_documents_method_info_list_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_documents_method_info_list_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-list",
+  FALSE
+};
+
+static const GDBusMethodInfo * const _gxdp_documents_method_info_pointers[] =
+{
+  &_gxdp_documents_method_info_get_mount_point.parent_struct,
+  &_gxdp_documents_method_info_add.parent_struct,
+  &_gxdp_documents_method_info_add_named.parent_struct,
+  &_gxdp_documents_method_info_add_full.parent_struct,
+  &_gxdp_documents_method_info_add_named_full.parent_struct,
+  &_gxdp_documents_method_info_grant_permissions.parent_struct,
+  &_gxdp_documents_method_info_revoke_permissions.parent_struct,
+  &_gxdp_documents_method_info_delete.parent_struct,
+  &_gxdp_documents_method_info_lookup.parent_struct,
+  &_gxdp_documents_method_info_info.parent_struct,
+  &_gxdp_documents_method_info_list.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusPropertyInfo _gxdp_documents_property_info_version =
+{
+  {
+    -1,
+    (gchar *) "version",
+    (gchar *) "u",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "version",
+  FALSE,
+  TRUE
+};
+
+static const GDBusPropertyInfo * const _gxdp_documents_property_info_pointers[] =
+{
+  &_gxdp_documents_property_info_version.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusInterfaceInfo _gxdp_documents_interface_info =
+{
+  {
+    -1,
+    (gchar *) "org.freedesktop.portal.Documents",
+    (GDBusMethodInfo **) &_gxdp_documents_method_info_pointers,
+    NULL,
+    (GDBusPropertyInfo **) &_gxdp_documents_property_info_pointers,
+    NULL
+  },
+  "documents",
+};
+
+
+/**
+ * gxdp_documents_interface_info:
+ *
+ * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-portal-Documents.top_of_page">org.freedesktop.portal.Documents</link> D-Bus interface.
+ *
+ * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
+ */
+GDBusInterfaceInfo *
+gxdp_documents_interface_info (void)
+{
+  return (GDBusInterfaceInfo *) &_gxdp_documents_interface_info.parent_struct;
+}
+
+/**
+ * gxdp_documents_override_properties:
+ * @klass: The class structure for a #GObject derived class.
+ * @property_id_begin: The property id to assign to the first overridden property.
+ *
+ * Overrides all #GObject properties in the #GXdpDocuments interface for a concrete class.
+ * The properties are overridden in the order they are defined.
+ *
+ * Returns: The last property id.
+ */
+guint
+gxdp_documents_override_properties (GObjectClass *klass, guint property_id_begin)
+{
+  g_object_class_override_property (klass, property_id_begin++, "version");
+  return property_id_begin - 1;
+}
+
+
+
+/**
+ * GXdpDocuments:
+ *
+ * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-Documents.top_of_page">org.freedesktop.portal.Documents</link>.
+ */
+
+/**
+ * GXdpDocumentsIface:
+ * @parent_iface: The parent interface.
+ * @handle_add: Handler for the #GXdpDocuments::handle-add signal.
+ * @handle_add_full: Handler for the #GXdpDocuments::handle-add-full signal.
+ * @handle_add_named: Handler for the #GXdpDocuments::handle-add-named signal.
+ * @handle_add_named_full: Handler for the #GXdpDocuments::handle-add-named-full signal.
+ * @handle_delete: Handler for the #GXdpDocuments::handle-delete signal.
+ * @handle_get_mount_point: Handler for the #GXdpDocuments::handle-get-mount-point signal.
+ * @handle_grant_permissions: Handler for the #GXdpDocuments::handle-grant-permissions signal.
+ * @handle_info: Handler for the #GXdpDocuments::handle-info signal.
+ * @handle_list: Handler for the #GXdpDocuments::handle-list signal.
+ * @handle_lookup: Handler for the #GXdpDocuments::handle-lookup signal.
+ * @handle_revoke_permissions: Handler for the #GXdpDocuments::handle-revoke-permissions signal.
+ * @get_version: Getter for the #GXdpDocuments:version property.
+ *
+ * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-Documents.top_of_page">org.freedesktop.portal.Documents</link>.
+ */
+
+typedef GXdpDocumentsIface GXdpDocumentsInterface;
+G_DEFINE_INTERFACE (GXdpDocuments, gxdp_documents, G_TYPE_OBJECT)
+
+static void
+gxdp_documents_default_init (GXdpDocumentsIface *iface)
+{
+  /* GObject signals for incoming D-Bus method calls: */
+  /**
+   * GXdpDocuments::handle-get-mount-point:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.GetMountPoint">GetMountPoint()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_get_mount_point() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-get-mount-point",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_get_mount_point),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /**
+   * GXdpDocuments::handle-add:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   * @fd_list: (nullable): A #GUnixFDList or %NULL.
+   * @arg_o_path_fd: Argument passed by remote caller.
+   * @arg_reuse_existing: Argument passed by remote caller.
+   * @arg_persistent: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Add">Add()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_add() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-add",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_add),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    5,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UNIX_FD_LIST, G_TYPE_VARIANT, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN);
+
+  /**
+   * GXdpDocuments::handle-add-named:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   * @fd_list: (nullable): A #GUnixFDList or %NULL.
+   * @arg_o_path_parent_fd: Argument passed by remote caller.
+   * @arg_filename: Argument passed by remote caller.
+   * @arg_reuse_existing: Argument passed by remote caller.
+   * @arg_persistent: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddNamed">AddNamed()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_add_named() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-add-named",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_add_named),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    6,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UNIX_FD_LIST, G_TYPE_VARIANT, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN);
+
+  /**
+   * GXdpDocuments::handle-add-full:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   * @fd_list: (nullable): A #GUnixFDList or %NULL.
+   * @arg_o_path_fds: Argument passed by remote caller.
+   * @arg_flags: Argument passed by remote caller.
+   * @arg_app_id: Argument passed by remote caller.
+   * @arg_permissions: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddFull">AddFull()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_add_full() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-add-full",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_add_full),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    6,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UNIX_FD_LIST, G_TYPE_VARIANT, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_STRV);
+
+  /**
+   * GXdpDocuments::handle-add-named-full:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   * @fd_list: (nullable): A #GUnixFDList or %NULL.
+   * @arg_o_path_fd: Argument passed by remote caller.
+   * @arg_filename: Argument passed by remote caller.
+   * @arg_flags: Argument passed by remote caller.
+   * @arg_app_id: Argument passed by remote caller.
+   * @arg_permissions: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddNamedFull">AddNamedFull()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_add_named_full() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-add-named-full",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_add_named_full),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    7,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UNIX_FD_LIST, G_TYPE_VARIANT, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_STRV);
+
+  /**
+   * GXdpDocuments::handle-grant-permissions:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_doc_id: Argument passed by remote caller.
+   * @arg_app_id: Argument passed by remote caller.
+   * @arg_permissions: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.GrantPermissions">GrantPermissions()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_grant_permissions() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-grant-permissions",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_grant_permissions),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    4,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRV);
+
+  /**
+   * GXdpDocuments::handle-revoke-permissions:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_doc_id: Argument passed by remote caller.
+   * @arg_app_id: Argument passed by remote caller.
+   * @arg_permissions: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.RevokePermissions">RevokePermissions()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_revoke_permissions() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-revoke-permissions",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_revoke_permissions),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    4,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRV);
+
+  /**
+   * GXdpDocuments::handle-delete:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_doc_id: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Delete">Delete()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_delete() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-delete",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_delete),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GXdpDocuments::handle-lookup:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_filename: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Lookup">Lookup()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_lookup() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-lookup",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_lookup),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GXdpDocuments::handle-info:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_doc_id: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Info">Info()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_info() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-info",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_info),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * GXdpDocuments::handle-list:
+   * @object: A #GXdpDocuments.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_app_id: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Documents.List">List()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_documents_complete_list() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-list",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpDocumentsIface, handle_list),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /* GObject properties for D-Bus properties: */
+  /**
+   * GXdpDocuments:version:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-portal-Documents.version">"version"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_uint ("version", "version", "version", 0, G_MAXUINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+/**
+ * gxdp_documents_get_version: (skip)
+ * @object: A #GXdpDocuments.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-portal-Documents.version">"version"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+guint 
+gxdp_documents_get_version (GXdpDocuments *object)
+{
+  return GXDP_DOCUMENTS_GET_IFACE (object)->get_version (object);
+}
+
+/**
+ * gxdp_documents_set_version: (skip)
+ * @object: A #GXdpDocuments.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-portal-Documents.version">"version"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gxdp_documents_set_version (GXdpDocuments *object, guint value)
+{
+  g_object_set (G_OBJECT (object), "version", value, NULL);
+}
+
+/**
+ * gxdp_documents_call_get_mount_point:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.GetMountPoint">GetMountPoint()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_get_mount_point_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_get_mount_point_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_get_mount_point (
+    GXdpDocuments *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "GetMountPoint",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_get_mount_point_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @out_path: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_get_mount_point().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_get_mount_point().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_get_mount_point_finish (
+    GXdpDocuments *proxy,
+    gchar **out_path,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^ay)",
+                 out_path);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_get_mount_point_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @out_path: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.GetMountPoint">GetMountPoint()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_get_mount_point() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_get_mount_point_sync (
+    GXdpDocuments *proxy,
+    gchar **out_path,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "GetMountPoint",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^ay)",
+                 out_path);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_add:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_o_path_fd: Argument to pass with the method invocation.
+ * @arg_reuse_existing: Argument to pass with the method invocation.
+ * @arg_persistent: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Add">Add()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_add_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_add_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_add (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fd,
+    gboolean arg_reuse_existing,
+    gboolean arg_persistent,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),
+    "Add",
+    g_variant_new ("(@hbb)",
+                   arg_o_path_fd,
+                   arg_reuse_existing,
+                   arg_persistent),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_add_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @out_doc_id: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out) (optional): Return location for a #GUnixFDList or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_add().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_add().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_add_finish (
+    GXdpDocuments *proxy,
+    gchar **out_doc_id,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_doc_id);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_add_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_o_path_fd: Argument to pass with the method invocation.
+ * @arg_reuse_existing: Argument to pass with the method invocation.
+ * @arg_persistent: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @out_doc_id: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Add">Add()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_add() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_add_sync (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fd,
+    gboolean arg_reuse_existing,
+    gboolean arg_persistent,
+    GUnixFDList  *fd_list,
+    gchar **out_doc_id,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),
+    "Add",
+    g_variant_new ("(@hbb)",
+                   arg_o_path_fd,
+                   arg_reuse_existing,
+                   arg_persistent),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    out_fd_list,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_doc_id);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_add_named:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_o_path_parent_fd: Argument to pass with the method invocation.
+ * @arg_filename: Argument to pass with the method invocation.
+ * @arg_reuse_existing: Argument to pass with the method invocation.
+ * @arg_persistent: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddNamed">AddNamed()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_add_named_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_add_named_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_add_named (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_parent_fd,
+    const gchar *arg_filename,
+    gboolean arg_reuse_existing,
+    gboolean arg_persistent,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),
+    "AddNamed",
+    g_variant_new ("(@h^aybb)",
+                   arg_o_path_parent_fd,
+                   arg_filename,
+                   arg_reuse_existing,
+                   arg_persistent),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_add_named_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @out_doc_id: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out) (optional): Return location for a #GUnixFDList or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_add_named().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_add_named().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_add_named_finish (
+    GXdpDocuments *proxy,
+    gchar **out_doc_id,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_doc_id);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_add_named_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_o_path_parent_fd: Argument to pass with the method invocation.
+ * @arg_filename: Argument to pass with the method invocation.
+ * @arg_reuse_existing: Argument to pass with the method invocation.
+ * @arg_persistent: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @out_doc_id: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddNamed">AddNamed()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_add_named() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_add_named_sync (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_parent_fd,
+    const gchar *arg_filename,
+    gboolean arg_reuse_existing,
+    gboolean arg_persistent,
+    GUnixFDList  *fd_list,
+    gchar **out_doc_id,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),
+    "AddNamed",
+    g_variant_new ("(@h^aybb)",
+                   arg_o_path_parent_fd,
+                   arg_filename,
+                   arg_reuse_existing,
+                   arg_persistent),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    out_fd_list,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_doc_id);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_add_full:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_o_path_fds: Argument to pass with the method invocation.
+ * @arg_flags: Argument to pass with the method invocation.
+ * @arg_app_id: Argument to pass with the method invocation.
+ * @arg_permissions: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddFull">AddFull()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_add_full_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_add_full_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_add_full (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fds,
+    guint arg_flags,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),
+    "AddFull",
+    g_variant_new ("(@ahus^as)",
+                   arg_o_path_fds,
+                   arg_flags,
+                   arg_app_id,
+                   arg_permissions),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_add_full_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @out_doc_ids: (out) (optional) (array zero-terminated=1): Return location for return parameter or %NULL to ignore.
+ * @out_extra_out: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out) (optional): Return location for a #GUnixFDList or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_add_full().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_add_full().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_add_full_finish (
+    GXdpDocuments *proxy,
+    gchar ***out_doc_ids,
+    GVariant **out_extra_out,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^as@a{sv})",
+                 out_doc_ids,
+                 out_extra_out);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_add_full_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_o_path_fds: Argument to pass with the method invocation.
+ * @arg_flags: Argument to pass with the method invocation.
+ * @arg_app_id: Argument to pass with the method invocation.
+ * @arg_permissions: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @out_doc_ids: (out) (optional) (array zero-terminated=1): Return location for return parameter or %NULL to ignore.
+ * @out_extra_out: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddFull">AddFull()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_add_full() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_add_full_sync (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fds,
+    guint arg_flags,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GUnixFDList  *fd_list,
+    gchar ***out_doc_ids,
+    GVariant **out_extra_out,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),
+    "AddFull",
+    g_variant_new ("(@ahus^as)",
+                   arg_o_path_fds,
+                   arg_flags,
+                   arg_app_id,
+                   arg_permissions),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    out_fd_list,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^as@a{sv})",
+                 out_doc_ids,
+                 out_extra_out);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_add_named_full:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_o_path_fd: Argument to pass with the method invocation.
+ * @arg_filename: Argument to pass with the method invocation.
+ * @arg_flags: Argument to pass with the method invocation.
+ * @arg_app_id: Argument to pass with the method invocation.
+ * @arg_permissions: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddNamedFull">AddNamedFull()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_add_named_full_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_add_named_full_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_add_named_full (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fd,
+    const gchar *arg_filename,
+    guint arg_flags,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),
+    "AddNamedFull",
+    g_variant_new ("(@h^ayus^as)",
+                   arg_o_path_fd,
+                   arg_filename,
+                   arg_flags,
+                   arg_app_id,
+                   arg_permissions),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_add_named_full_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @out_doc_id: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_extra_out: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out) (optional): Return location for a #GUnixFDList or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_add_named_full().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_add_named_full().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_add_named_full_finish (
+    GXdpDocuments *proxy,
+    gchar **out_doc_id,
+    GVariant **out_extra_out,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s@a{sv})",
+                 out_doc_id,
+                 out_extra_out);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_add_named_full_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_o_path_fd: Argument to pass with the method invocation.
+ * @arg_filename: Argument to pass with the method invocation.
+ * @arg_flags: Argument to pass with the method invocation.
+ * @arg_app_id: Argument to pass with the method invocation.
+ * @arg_permissions: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @out_doc_id: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_extra_out: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddNamedFull">AddNamedFull()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_add_named_full() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_add_named_full_sync (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fd,
+    const gchar *arg_filename,
+    guint arg_flags,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GUnixFDList  *fd_list,
+    gchar **out_doc_id,
+    GVariant **out_extra_out,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),
+    "AddNamedFull",
+    g_variant_new ("(@h^ayus^as)",
+                   arg_o_path_fd,
+                   arg_filename,
+                   arg_flags,
+                   arg_app_id,
+                   arg_permissions),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    out_fd_list,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s@a{sv})",
+                 out_doc_id,
+                 out_extra_out);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_grant_permissions:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_doc_id: Argument to pass with the method invocation.
+ * @arg_app_id: Argument to pass with the method invocation.
+ * @arg_permissions: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.GrantPermissions">GrantPermissions()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_grant_permissions_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_grant_permissions_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_grant_permissions (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "GrantPermissions",
+    g_variant_new ("(ss^as)",
+                   arg_doc_id,
+                   arg_app_id,
+                   arg_permissions),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_grant_permissions_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_grant_permissions().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_grant_permissions().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_grant_permissions_finish (
+    GXdpDocuments *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_grant_permissions_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_doc_id: Argument to pass with the method invocation.
+ * @arg_app_id: Argument to pass with the method invocation.
+ * @arg_permissions: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.GrantPermissions">GrantPermissions()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_grant_permissions() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_grant_permissions_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "GrantPermissions",
+    g_variant_new ("(ss^as)",
+                   arg_doc_id,
+                   arg_app_id,
+                   arg_permissions),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_revoke_permissions:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_doc_id: Argument to pass with the method invocation.
+ * @arg_app_id: Argument to pass with the method invocation.
+ * @arg_permissions: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.RevokePermissions">RevokePermissions()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_revoke_permissions_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_revoke_permissions_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_revoke_permissions (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "RevokePermissions",
+    g_variant_new ("(ss^as)",
+                   arg_doc_id,
+                   arg_app_id,
+                   arg_permissions),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_revoke_permissions_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_revoke_permissions().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_revoke_permissions().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_revoke_permissions_finish (
+    GXdpDocuments *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_revoke_permissions_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_doc_id: Argument to pass with the method invocation.
+ * @arg_app_id: Argument to pass with the method invocation.
+ * @arg_permissions: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.RevokePermissions">RevokePermissions()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_revoke_permissions() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_revoke_permissions_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "RevokePermissions",
+    g_variant_new ("(ss^as)",
+                   arg_doc_id,
+                   arg_app_id,
+                   arg_permissions),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_delete:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_doc_id: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Delete">Delete()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_delete_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_delete_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_delete (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "Delete",
+    g_variant_new ("(s)",
+                   arg_doc_id),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_delete_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_delete().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_delete().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_delete_finish (
+    GXdpDocuments *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_delete_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_doc_id: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Delete">Delete()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_delete() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_delete_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "Delete",
+    g_variant_new ("(s)",
+                   arg_doc_id),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_lookup:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_filename: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Lookup">Lookup()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_lookup_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_lookup_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_lookup (
+    GXdpDocuments *proxy,
+    const gchar *arg_filename,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "Lookup",
+    g_variant_new ("(^ay)",
+                   arg_filename),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_lookup_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @out_doc_id: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_lookup().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_lookup().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_lookup_finish (
+    GXdpDocuments *proxy,
+    gchar **out_doc_id,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_doc_id);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_lookup_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_filename: Argument to pass with the method invocation.
+ * @out_doc_id: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Lookup">Lookup()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_lookup() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_lookup_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_filename,
+    gchar **out_doc_id,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "Lookup",
+    g_variant_new ("(^ay)",
+                   arg_filename),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_doc_id);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_info:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_doc_id: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Info">Info()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_info_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_info_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_info (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "Info",
+    g_variant_new ("(s)",
+                   arg_doc_id),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_info_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @out_path: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_apps: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_info().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_info().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_info_finish (
+    GXdpDocuments *proxy,
+    gchar **out_path,
+    GVariant **out_apps,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^ay@a{sas})",
+                 out_path,
+                 out_apps);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_info_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_doc_id: Argument to pass with the method invocation.
+ * @out_path: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_apps: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Info">Info()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_info() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_info_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    gchar **out_path,
+    GVariant **out_apps,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "Info",
+    g_variant_new ("(s)",
+                   arg_doc_id),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^ay@a{sas})",
+                 out_path,
+                 out_apps);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_list:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_app_id: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.List">List()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_call_list_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_call_list_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_documents_call_list (
+    GXdpDocuments *proxy,
+    const gchar *arg_app_id,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "List",
+    g_variant_new ("(s)",
+                   arg_app_id),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_documents_call_list_finish:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @out_docs: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_call_list().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_documents_call_list().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_list_finish (
+    GXdpDocuments *proxy,
+    GVariant **out_docs,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(@a{say})",
+                 out_docs);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_call_list_sync:
+ * @proxy: A #GXdpDocumentsProxy.
+ * @arg_app_id: Argument to pass with the method invocation.
+ * @out_docs: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Documents.List">List()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_call_list() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_documents_call_list_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_app_id,
+    GVariant **out_docs,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "List",
+    g_variant_new ("(s)",
+                   arg_app_id),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(@a{say})",
+                 out_docs);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_documents_complete_get_mount_point:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @path: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.GetMountPoint">GetMountPoint()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_get_mount_point (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *path)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(^ay)",
+                   path));
+}
+
+/**
+ * gxdp_documents_complete_add:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @doc_id: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Add">Add()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_add (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *doc_id)
+{
+  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,
+    g_variant_new ("(s)",
+                   doc_id),
+    fd_list);
+}
+
+/**
+ * gxdp_documents_complete_add_named:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @doc_id: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddNamed">AddNamed()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_add_named (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *doc_id)
+{
+  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,
+    g_variant_new ("(s)",
+                   doc_id),
+    fd_list);
+}
+
+/**
+ * gxdp_documents_complete_add_full:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @doc_ids: Parameter to return.
+ * @extra_out: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddFull">AddFull()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_add_full (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *const *doc_ids,
+    GVariant *extra_out)
+{
+  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,
+    g_variant_new ("(^as@a{sv})",
+                   doc_ids,
+                   extra_out),
+    fd_list);
+}
+
+/**
+ * gxdp_documents_complete_add_named_full:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @doc_id: Parameter to return.
+ * @extra_out: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.AddNamedFull">AddNamedFull()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_add_named_full (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *doc_id,
+    GVariant *extra_out)
+{
+  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,
+    g_variant_new ("(s@a{sv})",
+                   doc_id,
+                   extra_out),
+    fd_list);
+}
+
+/**
+ * gxdp_documents_complete_grant_permissions:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.GrantPermissions">GrantPermissions()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_grant_permissions (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gxdp_documents_complete_revoke_permissions:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.RevokePermissions">RevokePermissions()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_revoke_permissions (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gxdp_documents_complete_delete:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Delete">Delete()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_delete (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * gxdp_documents_complete_lookup:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @doc_id: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Lookup">Lookup()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_lookup (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *doc_id)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(s)",
+                   doc_id));
+}
+
+/**
+ * gxdp_documents_complete_info:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @path: Parameter to return.
+ * @apps: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.Info">Info()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_info (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *path,
+    GVariant *apps)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(^ay@a{sas})",
+                   path,
+                   apps));
+}
+
+/**
+ * gxdp_documents_complete_list:
+ * @object: A #GXdpDocuments.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @docs: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Documents.List">List()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_documents_complete_list (
+    GXdpDocuments *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    GVariant *docs)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(@a{say})",
+                   docs));
+}
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GXdpDocumentsProxy:
+ *
+ * The #GXdpDocumentsProxy structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GXdpDocumentsProxyClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GXdpDocumentsProxy.
+ */
+
+struct _GXdpDocumentsProxyPrivate
+{
+  GData *qdata;
+};
+
+static void gxdp_documents_proxy_iface_init (GXdpDocumentsIface *iface);
+
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GXdpDocumentsProxy, gxdp_documents_proxy, G_TYPE_DBUS_PROXY,
+                         G_ADD_PRIVATE (GXdpDocumentsProxy)
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_DOCUMENTS, gxdp_documents_proxy_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GXdpDocumentsProxy, gxdp_documents_proxy, G_TYPE_DBUS_PROXY,
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_DOCUMENTS, gxdp_documents_proxy_iface_init))
+
+#endif
+static void
+gxdp_documents_proxy_finalize (GObject *object)
+{
+  GXdpDocumentsProxy *proxy = GXDP_DOCUMENTS_PROXY (object);
+  g_datalist_clear (&proxy->priv->qdata);
+  G_OBJECT_CLASS (gxdp_documents_proxy_parent_class)->finalize (object);
+}
+
+static void
+gxdp_documents_proxy_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_documents_property_info_pointers[prop_id - 1];
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
+  if (info->use_gvariant)
+    {
+      g_value_set_variant (value, variant);
+    }
+  else
+    {
+      if (variant != NULL)
+        g_dbus_gvariant_to_gvalue (variant, value);
+    }
+  if (variant != NULL)
+    g_variant_unref (variant);
+}
+
+static void
+gxdp_documents_proxy_set_property_cb (GDBusProxy *proxy,
+  GAsyncResult *res,
+  gpointer      user_data)
+{
+  const _ExtendedGDBusPropertyInfo *info = user_data;
+  GError *error;
+  GVariant *_ret;
+  error = NULL;
+  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
+  if (!_ret)
+    {
+      g_warning ("Error setting property '%s' on interface org.freedesktop.portal.Documents: %s (%s, %d)",
+                 info->parent_struct.name, 
+                 error->message, g_quark_to_string (error->domain), error->code);
+      g_error_free (error);
+    }
+  else
+    {
+      g_variant_unref (_ret);
+    }
+}
+
+static void
+gxdp_documents_proxy_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_documents_property_info_pointers[prop_id - 1];
+  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
+  g_dbus_proxy_call (G_DBUS_PROXY (object),
+    "org.freedesktop.DBus.Properties.Set",
+    g_variant_new ("(ssv)", "org.freedesktop.portal.Documents", info->parent_struct.name, variant),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    NULL, (GAsyncReadyCallback) gxdp_documents_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
+  g_variant_unref (variant);
+}
+
+static void
+gxdp_documents_proxy_g_signal (GDBusProxy *proxy,
+  const gchar *sender_name G_GNUC_UNUSED,
+  const gchar *signal_name,
+  GVariant *parameters)
+{
+  _ExtendedGDBusSignalInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  gsize n;
+  guint signal_id;
+  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_gxdp_documents_interface_info.parent_struct, signal_name);
+  if (info == NULL)
+    return;
+  num_params = g_variant_n_children (parameters);
+  paramv = g_new0 (GValue, num_params + 1);
+  g_value_init (&paramv[0], GXDP_TYPE_DOCUMENTS);
+  g_value_set_object (&paramv[0], proxy);
+  g_variant_iter_init (&iter, parameters);
+  n = 1;
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GXDP_TYPE_DOCUMENTS);
+  g_signal_emitv (paramv, signal_id, 0, NULL);
+  for (n = 0; n < num_params + 1; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static void
+gxdp_documents_proxy_g_properties_changed (GDBusProxy *_proxy,
+  GVariant *changed_properties,
+  const gchar *const *invalidated_properties)
+{
+  GXdpDocumentsProxy *proxy = GXDP_DOCUMENTS_PROXY (_proxy);
+  guint n;
+  const gchar *key;
+  GVariantIter *iter;
+  _ExtendedGDBusPropertyInfo *info;
+  g_variant_get (changed_properties, "a{sv}", &iter);
+  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_documents_interface_info.parent_struct, key);
+      g_datalist_remove_data (&proxy->priv->qdata, key);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+  g_variant_iter_free (iter);
+  for (n = 0; invalidated_properties[n] != NULL; n++)
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_documents_interface_info.parent_struct, invalidated_properties[n]);
+      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+}
+
+static guint 
+gxdp_documents_proxy_get_version (GXdpDocuments *object)
+{
+  GXdpDocumentsProxy *proxy = GXDP_DOCUMENTS_PROXY (object);
+  GVariant *variant;
+  guint value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "version");
+  if (variant != NULL)
+    {
+      value = g_variant_get_uint32 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static void
+gxdp_documents_proxy_init (GXdpDocumentsProxy *proxy)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  proxy->priv = gxdp_documents_proxy_get_instance_private (proxy);
+#else
+  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GXDP_TYPE_DOCUMENTS_PROXY, GXdpDocumentsProxyPrivate);
+#endif
+
+  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), gxdp_documents_interface_info ());
+}
+
+static void
+gxdp_documents_proxy_class_init (GXdpDocumentsProxyClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusProxyClass *proxy_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize     = gxdp_documents_proxy_finalize;
+  gobject_class->get_property = gxdp_documents_proxy_get_property;
+  gobject_class->set_property = gxdp_documents_proxy_set_property;
+
+  proxy_class = G_DBUS_PROXY_CLASS (klass);
+  proxy_class->g_signal = gxdp_documents_proxy_g_signal;
+  proxy_class->g_properties_changed = gxdp_documents_proxy_g_properties_changed;
+
+  gxdp_documents_override_properties (gobject_class, 1);
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GXdpDocumentsProxyPrivate));
+#endif
+}
+
+static void
+gxdp_documents_proxy_iface_init (GXdpDocumentsIface *iface)
+{
+  iface->get_version = gxdp_documents_proxy_get_version;
+}
+
+/**
+ * gxdp_documents_proxy_new:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-Documents.top_of_page">org.freedesktop.portal.Documents</link>. See g_dbus_proxy_new() for more details.
+ *
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_proxy_new_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_proxy_new_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gxdp_documents_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GXDP_TYPE_DOCUMENTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.Documents", NULL);
+}
+
+/**
+ * gxdp_documents_proxy_new_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_proxy_new().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gxdp_documents_proxy_new().
+ *
+ * Returns: (transfer full) (type GXdpDocumentsProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpDocuments *
+gxdp_documents_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GXDP_DOCUMENTS (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gxdp_documents_proxy_new_sync:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-Documents.top_of_page">org.freedesktop.portal.Documents</link>. See g_dbus_proxy_new_sync() for more details.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_proxy_new() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GXdpDocumentsProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpDocuments *
+gxdp_documents_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GXDP_TYPE_DOCUMENTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.Documents", NULL);
+  if (ret != NULL)
+    return GXDP_DOCUMENTS (ret);
+  else
+    return NULL;
+}
+
+
+/**
+ * gxdp_documents_proxy_new_for_bus:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Like gxdp_documents_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_documents_proxy_new_for_bus_finish() to get the result of the operation.
+ *
+ * See gxdp_documents_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gxdp_documents_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GXDP_TYPE_DOCUMENTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.Documents", NULL);
+}
+
+/**
+ * gxdp_documents_proxy_new_for_bus_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_documents_proxy_new_for_bus().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gxdp_documents_proxy_new_for_bus().
+ *
+ * Returns: (transfer full) (type GXdpDocumentsProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpDocuments *
+gxdp_documents_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GXDP_DOCUMENTS (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gxdp_documents_proxy_new_for_bus_sync:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Like gxdp_documents_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_documents_proxy_new_for_bus() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GXdpDocumentsProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpDocuments *
+gxdp_documents_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GXDP_TYPE_DOCUMENTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.Documents", NULL);
+  if (ret != NULL)
+    return GXDP_DOCUMENTS (ret);
+  else
+    return NULL;
+}
+
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GXdpDocumentsSkeleton:
+ *
+ * The #GXdpDocumentsSkeleton structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GXdpDocumentsSkeletonClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GXdpDocumentsSkeleton.
+ */
+
+struct _GXdpDocumentsSkeletonPrivate
+{
+  GValue *properties;
+  GList *changed_properties;
+  GSource *changed_properties_idle_source;
+  GMainContext *context;
+  GMutex lock;
+};
+
+static void
+_gxdp_documents_skeleton_handle_method_call (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name,
+  const gchar *method_name,
+  GVariant *parameters,
+  GDBusMethodInvocation *invocation,
+  gpointer user_data)
+{
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (user_data);
+  _ExtendedGDBusMethodInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  guint num_extra;
+  gsize n;
+  guint signal_id;
+  GValue return_value = G_VALUE_INIT;
+  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
+  g_assert (info != NULL);
+  num_params = g_variant_n_children (parameters);
+  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
+  n = 0;
+  g_value_init (&paramv[n], GXDP_TYPE_DOCUMENTS);
+  g_value_set_object (&paramv[n++], skeleton);
+  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
+  g_value_set_object (&paramv[n++], invocation);
+  if (info->pass_fdlist)
+    {
+#ifdef G_OS_UNIX
+      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
+      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
+#else
+      g_assert_not_reached ();
+#endif
+    }
+  g_variant_iter_init (&iter, parameters);
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GXDP_TYPE_DOCUMENTS);
+  g_value_init (&return_value, G_TYPE_BOOLEAN);
+  g_signal_emitv (paramv, signal_id, 0, &return_value);
+  if (!g_value_get_boolean (&return_value))
+    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
+  g_value_unset (&return_value);
+  for (n = 0; n < num_params + num_extra; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static GVariant *
+_gxdp_documents_skeleton_handle_get_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GError **error,
+  gpointer user_data)
+{
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  GVariant *ret;
+  ret = NULL;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_documents_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      g_value_init (&value, pspec->value_type);
+      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
+      g_value_unset (&value);
+    }
+  return ret;
+}
+
+static gboolean
+_gxdp_documents_skeleton_handle_set_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GVariant *variant,
+  GError **error,
+  gpointer user_data)
+{
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  gboolean ret;
+  ret = FALSE;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_documents_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      if (info->use_gvariant)
+        g_value_set_variant (&value, variant);
+      else
+        g_dbus_gvariant_to_gvalue (variant, &value);
+      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      g_value_unset (&value);
+      ret = TRUE;
+    }
+  return ret;
+}
+
+static const GDBusInterfaceVTable _gxdp_documents_skeleton_vtable =
+{
+  _gxdp_documents_skeleton_handle_method_call,
+  _gxdp_documents_skeleton_handle_get_property,
+  _gxdp_documents_skeleton_handle_set_property,
+  {NULL}
+};
+
+static GDBusInterfaceInfo *
+gxdp_documents_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return gxdp_documents_interface_info ();
+}
+
+static GDBusInterfaceVTable *
+gxdp_documents_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return (GDBusInterfaceVTable *) &_gxdp_documents_skeleton_vtable;
+}
+
+static GVariant *
+gxdp_documents_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
+{
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (_skeleton);
+
+  GVariantBuilder builder;
+  guint n;
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  if (_gxdp_documents_interface_info.parent_struct.properties == NULL)
+    goto out;
+  for (n = 0; _gxdp_documents_interface_info.parent_struct.properties[n] != NULL; n++)
+    {
+      GDBusPropertyInfo *info = _gxdp_documents_interface_info.parent_struct.properties[n];
+      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
+        {
+          GVariant *value;
+          value = _gxdp_documents_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.portal.Documents", info->name, NULL, skeleton);
+          if (value != NULL)
+            {
+              g_variant_take_ref (value);
+              g_variant_builder_add (&builder, "{sv}", info->name, value);
+              g_variant_unref (value);
+            }
+        }
+    }
+out:
+  return g_variant_builder_end (&builder);
+}
+
+static gboolean _gxdp_documents_emit_changed (gpointer user_data);
+
+static void
+gxdp_documents_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
+{
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (_skeleton);
+  gboolean emit_changed = FALSE;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    {
+      g_source_destroy (skeleton->priv->changed_properties_idle_source);
+      skeleton->priv->changed_properties_idle_source = NULL;
+      emit_changed = TRUE;
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+
+  if (emit_changed)
+    _gxdp_documents_emit_changed (skeleton);
+}
+
+static void gxdp_documents_skeleton_iface_init (GXdpDocumentsIface *iface);
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GXdpDocumentsSkeleton, gxdp_documents_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_ADD_PRIVATE (GXdpDocumentsSkeleton)
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_DOCUMENTS, gxdp_documents_skeleton_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GXdpDocumentsSkeleton, gxdp_documents_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_DOCUMENTS, gxdp_documents_skeleton_iface_init))
+
+#endif
+static void
+gxdp_documents_skeleton_finalize (GObject *object)
+{
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (object);
+  guint n;
+  for (n = 0; n < 1; n++)
+    g_value_unset (&skeleton->priv->properties[n]);
+  g_free (skeleton->priv->properties);
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    g_source_destroy (skeleton->priv->changed_properties_idle_source);
+  g_main_context_unref (skeleton->priv->context);
+  g_mutex_clear (&skeleton->priv->lock);
+  G_OBJECT_CLASS (gxdp_documents_skeleton_parent_class)->finalize (object);
+}
+
+static void
+gxdp_documents_skeleton_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static gboolean
+_gxdp_documents_emit_changed (gpointer user_data)
+{
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (user_data);
+  GList *l;
+  GVariantBuilder builder;
+  GVariantBuilder invalidated_builder;
+  guint num_changes;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
+  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
+    {
+      ChangedProperty *cp = l->data;
+      GVariant *variant;
+      const GValue *cur_value;
+
+      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
+      if (!_g_value_equal (cur_value, &cp->orig_value))
+        {
+          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
+          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
+          g_variant_unref (variant);
+          num_changes++;
+        }
+    }
+  if (num_changes > 0)
+    {
+      GList *connections, *ll;
+      GVariant *signal_variant;
+      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.freedesktop.portal.Documents",
+                                           &builder, &invalidated_builder));
+      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+      for (ll = connections; ll != NULL; ll = ll->next)
+        {
+          GDBusConnection *connection = ll->data;
+
+          g_dbus_connection_emit_signal (connection,
+                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
+                                         "org.freedesktop.DBus.Properties",
+                                         "PropertiesChanged",
+                                         signal_variant,
+                                         NULL);
+        }
+      g_variant_unref (signal_variant);
+      g_list_free_full (connections, g_object_unref);
+    }
+  else
+    {
+      g_variant_builder_clear (&builder);
+      g_variant_builder_clear (&invalidated_builder);
+    }
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  skeleton->priv->changed_properties = NULL;
+  skeleton->priv->changed_properties_idle_source = NULL;
+  g_mutex_unlock (&skeleton->priv->lock);
+  return FALSE;
+}
+
+static void
+_gxdp_documents_schedule_emit_changed (GXdpDocumentsSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
+{
+  ChangedProperty *cp;
+  GList *l;
+  cp = NULL;
+  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
+    {
+      ChangedProperty *i_cp = l->data;
+      if (i_cp->info == info)
+        {
+          cp = i_cp;
+          break;
+        }
+    }
+  if (cp == NULL)
+    {
+      cp = g_new0 (ChangedProperty, 1);
+      cp->prop_id = prop_id;
+      cp->info = info;
+      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
+      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
+      g_value_copy (orig_value, &cp->orig_value);
+    }
+}
+
+static void
+gxdp_documents_skeleton_notify (GObject      *object,
+  GParamSpec *pspec G_GNUC_UNUSED)
+{
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (object);
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties != NULL &&
+      skeleton->priv->changed_properties_idle_source == NULL)
+    {
+      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
+      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
+      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _gxdp_documents_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
+      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _gxdp_documents_emit_changed");
+      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
+      g_source_unref (skeleton->priv->changed_properties_idle_source);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static void
+gxdp_documents_skeleton_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_documents_property_info_pointers[prop_id - 1];
+  g_mutex_lock (&skeleton->priv->lock);
+  g_object_freeze_notify (object);
+  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
+    {
+      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
+          info->emits_changed_signal)
+        _gxdp_documents_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
+      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
+      g_object_notify_by_pspec (object, pspec);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+  g_object_thaw_notify (object);
+}
+
+static void
+gxdp_documents_skeleton_init (GXdpDocumentsSkeleton *skeleton)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  skeleton->priv = gxdp_documents_skeleton_get_instance_private (skeleton);
+#else
+  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GXDP_TYPE_DOCUMENTS_SKELETON, GXdpDocumentsSkeletonPrivate);
+#endif
+
+  g_mutex_init (&skeleton->priv->lock);
+  skeleton->priv->context = g_main_context_ref_thread_default ();
+  skeleton->priv->properties = g_new0 (GValue, 1);
+  g_value_init (&skeleton->priv->properties[0], G_TYPE_UINT);
+}
+
+static guint 
+gxdp_documents_skeleton_get_version (GXdpDocuments *object)
+{
+  GXdpDocumentsSkeleton *skeleton = GXDP_DOCUMENTS_SKELETON (object);
+  guint value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_uint (&(skeleton->priv->properties[0]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static void
+gxdp_documents_skeleton_class_init (GXdpDocumentsSkeletonClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusInterfaceSkeletonClass *skeleton_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = gxdp_documents_skeleton_finalize;
+  gobject_class->get_property = gxdp_documents_skeleton_get_property;
+  gobject_class->set_property = gxdp_documents_skeleton_set_property;
+  gobject_class->notify       = gxdp_documents_skeleton_notify;
+
+
+  gxdp_documents_override_properties (gobject_class, 1);
+
+  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
+  skeleton_class->get_info = gxdp_documents_skeleton_dbus_interface_get_info;
+  skeleton_class->get_properties = gxdp_documents_skeleton_dbus_interface_get_properties;
+  skeleton_class->flush = gxdp_documents_skeleton_dbus_interface_flush;
+  skeleton_class->get_vtable = gxdp_documents_skeleton_dbus_interface_get_vtable;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GXdpDocumentsSkeletonPrivate));
+#endif
+}
+
+static void
+gxdp_documents_skeleton_iface_init (GXdpDocumentsIface *iface)
+{
+  iface->get_version = gxdp_documents_skeleton_get_version;
+}
+
+/**
+ * gxdp_documents_skeleton_new:
+ *
+ * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-Documents.top_of_page">org.freedesktop.portal.Documents</link>.
+ *
+ * Returns: (transfer full) (type GXdpDocumentsSkeleton): The skeleton object.
+ */
+GXdpDocuments *
+gxdp_documents_skeleton_new (void)
+{
+  return GXDP_DOCUMENTS (g_object_new (GXDP_TYPE_DOCUMENTS_SKELETON, NULL));
+}
+
+/* ------------------------------------------------------------------------
+ * Code for interface org.freedesktop.portal.OpenURI
+ * ------------------------------------------------------------------------
+ */
+
+/**
+ * SECTION:GXdpOpenURI
+ * @title: GXdpOpenURI
+ * @short_description: Generated C code for the org.freedesktop.portal.OpenURI D-Bus interface
+ *
+ * This section contains code for working with the <link linkend="gdbus-interface-org-freedesktop-portal-OpenURI.top_of_page">org.freedesktop.portal.OpenURI</link> D-Bus interface in C.
+ */
+
+/* ---- Introspection data for org.freedesktop.portal.OpenURI ---- */
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_uri_IN_ARG_parent_window =
+{
+  {
+    -1,
+    (gchar *) "parent_window",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_uri_IN_ARG_uri =
+{
+  {
+    -1,
+    (gchar *) "uri",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_uri_IN_ARG_options =
+{
+  {
+    -1,
+    (gchar *) "options",
+    (gchar *) "a{sv}",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_open_uri_method_info_open_uri_IN_ARG_pointers[] =
+{
+  &_gxdp_open_uri_method_info_open_uri_IN_ARG_parent_window.parent_struct,
+  &_gxdp_open_uri_method_info_open_uri_IN_ARG_uri.parent_struct,
+  &_gxdp_open_uri_method_info_open_uri_IN_ARG_options.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_uri_OUT_ARG_handle =
+{
+  {
+    -1,
+    (gchar *) "handle",
+    (gchar *) "o",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_open_uri_method_info_open_uri_OUT_ARG_pointers[] =
+{
+  &_gxdp_open_uri_method_info_open_uri_OUT_ARG_handle.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_open_uri_method_info_open_uri =
+{
+  {
+    -1,
+    (gchar *) "OpenURI",
+    (GDBusArgInfo **) &_gxdp_open_uri_method_info_open_uri_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_open_uri_method_info_open_uri_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-open-uri",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_file_IN_ARG_parent_window =
+{
+  {
+    -1,
+    (gchar *) "parent_window",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_file_IN_ARG_fd =
+{
+  {
+    -1,
+    (gchar *) "fd",
+    (gchar *) "h",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_file_IN_ARG_options =
+{
+  {
+    -1,
+    (gchar *) "options",
+    (gchar *) "a{sv}",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_open_uri_method_info_open_file_IN_ARG_pointers[] =
+{
+  &_gxdp_open_uri_method_info_open_file_IN_ARG_parent_window.parent_struct,
+  &_gxdp_open_uri_method_info_open_file_IN_ARG_fd.parent_struct,
+  &_gxdp_open_uri_method_info_open_file_IN_ARG_options.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_file_OUT_ARG_handle =
+{
+  {
+    -1,
+    (gchar *) "handle",
+    (gchar *) "o",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_open_uri_method_info_open_file_OUT_ARG_pointers[] =
+{
+  &_gxdp_open_uri_method_info_open_file_OUT_ARG_handle.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_open_uri_method_info_open_file =
+{
+  {
+    -1,
+    (gchar *) "OpenFile",
+    (GDBusArgInfo **) &_gxdp_open_uri_method_info_open_file_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_open_uri_method_info_open_file_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-open-file",
+  TRUE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_directory_IN_ARG_parent_window =
+{
+  {
+    -1,
+    (gchar *) "parent_window",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_directory_IN_ARG_fd =
+{
+  {
+    -1,
+    (gchar *) "fd",
+    (gchar *) "h",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_directory_IN_ARG_options =
+{
+  {
+    -1,
+    (gchar *) "options",
+    (gchar *) "a{sv}",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_open_uri_method_info_open_directory_IN_ARG_pointers[] =
+{
+  &_gxdp_open_uri_method_info_open_directory_IN_ARG_parent_window.parent_struct,
+  &_gxdp_open_uri_method_info_open_directory_IN_ARG_fd.parent_struct,
+  &_gxdp_open_uri_method_info_open_directory_IN_ARG_options.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_open_uri_method_info_open_directory_OUT_ARG_handle =
+{
+  {
+    -1,
+    (gchar *) "handle",
+    (gchar *) "o",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_open_uri_method_info_open_directory_OUT_ARG_pointers[] =
+{
+  &_gxdp_open_uri_method_info_open_directory_OUT_ARG_handle.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_open_uri_method_info_open_directory =
+{
+  {
+    -1,
+    (gchar *) "OpenDirectory",
+    (GDBusArgInfo **) &_gxdp_open_uri_method_info_open_directory_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_open_uri_method_info_open_directory_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-open-directory",
+  TRUE
+};
+
+static const GDBusMethodInfo * const _gxdp_open_uri_method_info_pointers[] =
+{
+  &_gxdp_open_uri_method_info_open_uri.parent_struct,
+  &_gxdp_open_uri_method_info_open_file.parent_struct,
+  &_gxdp_open_uri_method_info_open_directory.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusPropertyInfo _gxdp_open_uri_property_info_version =
+{
+  {
+    -1,
+    (gchar *) "version",
+    (gchar *) "u",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "version",
+  FALSE,
+  TRUE
+};
+
+static const GDBusPropertyInfo * const _gxdp_open_uri_property_info_pointers[] =
+{
+  &_gxdp_open_uri_property_info_version.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusInterfaceInfo _gxdp_open_uri_interface_info =
+{
+  {
+    -1,
+    (gchar *) "org.freedesktop.portal.OpenURI",
+    (GDBusMethodInfo **) &_gxdp_open_uri_method_info_pointers,
+    NULL,
+    (GDBusPropertyInfo **) &_gxdp_open_uri_property_info_pointers,
+    NULL
+  },
+  "open-uri",
+};
+
+
+/**
+ * gxdp_open_uri_interface_info:
+ *
+ * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-portal-OpenURI.top_of_page">org.freedesktop.portal.OpenURI</link> D-Bus interface.
+ *
+ * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
+ */
+GDBusInterfaceInfo *
+gxdp_open_uri_interface_info (void)
+{
+  return (GDBusInterfaceInfo *) &_gxdp_open_uri_interface_info.parent_struct;
+}
+
+/**
+ * gxdp_open_uri_override_properties:
+ * @klass: The class structure for a #GObject derived class.
+ * @property_id_begin: The property id to assign to the first overridden property.
+ *
+ * Overrides all #GObject properties in the #GXdpOpenURI interface for a concrete class.
+ * The properties are overridden in the order they are defined.
+ *
+ * Returns: The last property id.
+ */
+guint
+gxdp_open_uri_override_properties (GObjectClass *klass, guint property_id_begin)
+{
+  g_object_class_override_property (klass, property_id_begin++, "version");
+  return property_id_begin - 1;
+}
+
+
+
+/**
+ * GXdpOpenURI:
+ *
+ * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-OpenURI.top_of_page">org.freedesktop.portal.OpenURI</link>.
+ */
+
+/**
+ * GXdpOpenURIIface:
+ * @parent_iface: The parent interface.
+ * @handle_open_directory: Handler for the #GXdpOpenURI::handle-open-directory signal.
+ * @handle_open_file: Handler for the #GXdpOpenURI::handle-open-file signal.
+ * @handle_open_uri: Handler for the #GXdpOpenURI::handle-open-uri signal.
+ * @get_version: Getter for the #GXdpOpenURI:version property.
+ *
+ * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-OpenURI.top_of_page">org.freedesktop.portal.OpenURI</link>.
+ */
+
+typedef GXdpOpenURIIface GXdpOpenURIInterface;
+G_DEFINE_INTERFACE (GXdpOpenURI, gxdp_open_uri, G_TYPE_OBJECT)
+
+static void
+gxdp_open_uri_default_init (GXdpOpenURIIface *iface)
+{
+  /* GObject signals for incoming D-Bus method calls: */
+  /**
+   * GXdpOpenURI::handle-open-uri:
+   * @object: A #GXdpOpenURI.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_parent_window: Argument passed by remote caller.
+   * @arg_uri: Argument passed by remote caller.
+   * @arg_options: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenURI">OpenURI()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_open_uri_complete_open_uri() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-open-uri",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpOpenURIIface, handle_open_uri),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    4,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_VARIANT);
+
+  /**
+   * GXdpOpenURI::handle-open-file:
+   * @object: A #GXdpOpenURI.
+   * @invocation: A #GDBusMethodInvocation.
+   * @fd_list: (nullable): A #GUnixFDList or %NULL.
+   * @arg_parent_window: Argument passed by remote caller.
+   * @arg_fd: Argument passed by remote caller.
+   * @arg_options: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenFile">OpenFile()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_open_uri_complete_open_file() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-open-file",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpOpenURIIface, handle_open_file),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    5,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UNIX_FD_LIST, G_TYPE_STRING, G_TYPE_VARIANT, G_TYPE_VARIANT);
+
+  /**
+   * GXdpOpenURI::handle-open-directory:
+   * @object: A #GXdpOpenURI.
+   * @invocation: A #GDBusMethodInvocation.
+   * @fd_list: (nullable): A #GUnixFDList or %NULL.
+   * @arg_parent_window: Argument passed by remote caller.
+   * @arg_fd: Argument passed by remote caller.
+   * @arg_options: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenDirectory">OpenDirectory()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_open_uri_complete_open_directory() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-open-directory",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpOpenURIIface, handle_open_directory),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    5,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UNIX_FD_LIST, G_TYPE_STRING, G_TYPE_VARIANT, G_TYPE_VARIANT);
+
+  /* GObject properties for D-Bus properties: */
+  /**
+   * GXdpOpenURI:version:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-portal-OpenURI.version">"version"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_uint ("version", "version", "version", 0, G_MAXUINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+/**
+ * gxdp_open_uri_get_version: (skip)
+ * @object: A #GXdpOpenURI.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-portal-OpenURI.version">"version"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+guint 
+gxdp_open_uri_get_version (GXdpOpenURI *object)
+{
+  return GXDP_OPEN_URI_GET_IFACE (object)->get_version (object);
+}
+
+/**
+ * gxdp_open_uri_set_version: (skip)
+ * @object: A #GXdpOpenURI.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-portal-OpenURI.version">"version"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gxdp_open_uri_set_version (GXdpOpenURI *object, guint value)
+{
+  g_object_set (G_OBJECT (object), "version", value, NULL);
+}
+
+/**
+ * gxdp_open_uri_call_open_uri:
+ * @proxy: A #GXdpOpenURIProxy.
+ * @arg_parent_window: Argument to pass with the method invocation.
+ * @arg_uri: Argument to pass with the method invocation.
+ * @arg_options: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenURI">OpenURI()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_open_uri_call_open_uri_finish() to get the result of the operation.
+ *
+ * See gxdp_open_uri_call_open_uri_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_open_uri_call_open_uri (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    const gchar *arg_uri,
+    GVariant *arg_options,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "OpenURI",
+    g_variant_new ("(ss@a{sv})",
+                   arg_parent_window,
+                   arg_uri,
+                   arg_options),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_open_uri_call_open_uri_finish:
+ * @proxy: A #GXdpOpenURIProxy.
+ * @out_handle: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_open_uri_call_open_uri().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_open_uri_call_open_uri().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_open_uri_call_open_uri_finish (
+    GXdpOpenURI *proxy,
+    gchar **out_handle,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_handle);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_open_uri_call_open_uri_sync:
+ * @proxy: A #GXdpOpenURIProxy.
+ * @arg_parent_window: Argument to pass with the method invocation.
+ * @arg_uri: Argument to pass with the method invocation.
+ * @arg_options: Argument to pass with the method invocation.
+ * @out_handle: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenURI">OpenURI()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_open_uri_call_open_uri() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_open_uri_call_open_uri_sync (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    const gchar *arg_uri,
+    GVariant *arg_options,
+    gchar **out_handle,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "OpenURI",
+    g_variant_new ("(ss@a{sv})",
+                   arg_parent_window,
+                   arg_uri,
+                   arg_options),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_handle);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_open_uri_call_open_file:
+ * @proxy: A #GXdpOpenURIProxy.
+ * @arg_parent_window: Argument to pass with the method invocation.
+ * @arg_fd: Argument to pass with the method invocation.
+ * @arg_options: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenFile">OpenFile()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_open_uri_call_open_file_finish() to get the result of the operation.
+ *
+ * See gxdp_open_uri_call_open_file_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_open_uri_call_open_file (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    GVariant *arg_fd,
+    GVariant *arg_options,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),
+    "OpenFile",
+    g_variant_new ("(s@h@a{sv})",
+                   arg_parent_window,
+                   arg_fd,
+                   arg_options),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_open_uri_call_open_file_finish:
+ * @proxy: A #GXdpOpenURIProxy.
+ * @out_handle: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out) (optional): Return location for a #GUnixFDList or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_open_uri_call_open_file().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_open_uri_call_open_file().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_open_uri_call_open_file_finish (
+    GXdpOpenURI *proxy,
+    gchar **out_handle,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_handle);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_open_uri_call_open_file_sync:
+ * @proxy: A #GXdpOpenURIProxy.
+ * @arg_parent_window: Argument to pass with the method invocation.
+ * @arg_fd: Argument to pass with the method invocation.
+ * @arg_options: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @out_handle: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenFile">OpenFile()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_open_uri_call_open_file() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_open_uri_call_open_file_sync (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    GVariant *arg_fd,
+    GVariant *arg_options,
+    GUnixFDList  *fd_list,
+    gchar **out_handle,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),
+    "OpenFile",
+    g_variant_new ("(s@h@a{sv})",
+                   arg_parent_window,
+                   arg_fd,
+                   arg_options),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    out_fd_list,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_handle);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_open_uri_call_open_directory:
+ * @proxy: A #GXdpOpenURIProxy.
+ * @arg_parent_window: Argument to pass with the method invocation.
+ * @arg_fd: Argument to pass with the method invocation.
+ * @arg_options: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenDirectory">OpenDirectory()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_open_uri_call_open_directory_finish() to get the result of the operation.
+ *
+ * See gxdp_open_uri_call_open_directory_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_open_uri_call_open_directory (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    GVariant *arg_fd,
+    GVariant *arg_options,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),
+    "OpenDirectory",
+    g_variant_new ("(s@h@a{sv})",
+                   arg_parent_window,
+                   arg_fd,
+                   arg_options),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_open_uri_call_open_directory_finish:
+ * @proxy: A #GXdpOpenURIProxy.
+ * @out_handle: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out) (optional): Return location for a #GUnixFDList or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_open_uri_call_open_directory().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_open_uri_call_open_directory().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_open_uri_call_open_directory_finish (
+    GXdpOpenURI *proxy,
+    gchar **out_handle,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_handle);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_open_uri_call_open_directory_sync:
+ * @proxy: A #GXdpOpenURIProxy.
+ * @arg_parent_window: Argument to pass with the method invocation.
+ * @arg_fd: Argument to pass with the method invocation.
+ * @arg_options: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @out_handle: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenDirectory">OpenDirectory()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_open_uri_call_open_directory() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_open_uri_call_open_directory_sync (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    GVariant *arg_fd,
+    GVariant *arg_options,
+    GUnixFDList  *fd_list,
+    gchar **out_handle,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),
+    "OpenDirectory",
+    g_variant_new ("(s@h@a{sv})",
+                   arg_parent_window,
+                   arg_fd,
+                   arg_options),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    out_fd_list,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(o)",
+                 out_handle);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_open_uri_complete_open_uri:
+ * @object: A #GXdpOpenURI.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @handle: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenURI">OpenURI()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_open_uri_complete_open_uri (
+    GXdpOpenURI *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *handle)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(o)",
+                   handle));
+}
+
+/**
+ * gxdp_open_uri_complete_open_file:
+ * @object: A #GXdpOpenURI.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @handle: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenFile">OpenFile()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_open_uri_complete_open_file (
+    GXdpOpenURI *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *handle)
+{
+  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,
+    g_variant_new ("(o)",
+                   handle),
+    fd_list);
+}
+
+/**
+ * gxdp_open_uri_complete_open_directory:
+ * @object: A #GXdpOpenURI.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @handle: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-OpenURI.OpenDirectory">OpenDirectory()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_open_uri_complete_open_directory (
+    GXdpOpenURI *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *handle)
+{
+  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,
+    g_variant_new ("(o)",
+                   handle),
+    fd_list);
+}
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GXdpOpenURIProxy:
+ *
+ * The #GXdpOpenURIProxy structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GXdpOpenURIProxyClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GXdpOpenURIProxy.
+ */
+
+struct _GXdpOpenURIProxyPrivate
+{
+  GData *qdata;
+};
+
+static void gxdp_open_uri_proxy_iface_init (GXdpOpenURIIface *iface);
+
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GXdpOpenURIProxy, gxdp_open_uri_proxy, G_TYPE_DBUS_PROXY,
+                         G_ADD_PRIVATE (GXdpOpenURIProxy)
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_OPEN_URI, gxdp_open_uri_proxy_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GXdpOpenURIProxy, gxdp_open_uri_proxy, G_TYPE_DBUS_PROXY,
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_OPEN_URI, gxdp_open_uri_proxy_iface_init))
+
+#endif
+static void
+gxdp_open_uri_proxy_finalize (GObject *object)
+{
+  GXdpOpenURIProxy *proxy = GXDP_OPEN_URI_PROXY (object);
+  g_datalist_clear (&proxy->priv->qdata);
+  G_OBJECT_CLASS (gxdp_open_uri_proxy_parent_class)->finalize (object);
+}
+
+static void
+gxdp_open_uri_proxy_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_open_uri_property_info_pointers[prop_id - 1];
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
+  if (info->use_gvariant)
+    {
+      g_value_set_variant (value, variant);
+    }
+  else
+    {
+      if (variant != NULL)
+        g_dbus_gvariant_to_gvalue (variant, value);
+    }
+  if (variant != NULL)
+    g_variant_unref (variant);
+}
+
+static void
+gxdp_open_uri_proxy_set_property_cb (GDBusProxy *proxy,
+  GAsyncResult *res,
+  gpointer      user_data)
+{
+  const _ExtendedGDBusPropertyInfo *info = user_data;
+  GError *error;
+  GVariant *_ret;
+  error = NULL;
+  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
+  if (!_ret)
+    {
+      g_warning ("Error setting property '%s' on interface org.freedesktop.portal.OpenURI: %s (%s, %d)",
+                 info->parent_struct.name, 
+                 error->message, g_quark_to_string (error->domain), error->code);
+      g_error_free (error);
+    }
+  else
+    {
+      g_variant_unref (_ret);
+    }
+}
+
+static void
+gxdp_open_uri_proxy_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_open_uri_property_info_pointers[prop_id - 1];
+  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
+  g_dbus_proxy_call (G_DBUS_PROXY (object),
+    "org.freedesktop.DBus.Properties.Set",
+    g_variant_new ("(ssv)", "org.freedesktop.portal.OpenURI", info->parent_struct.name, variant),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    NULL, (GAsyncReadyCallback) gxdp_open_uri_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
+  g_variant_unref (variant);
+}
+
+static void
+gxdp_open_uri_proxy_g_signal (GDBusProxy *proxy,
+  const gchar *sender_name G_GNUC_UNUSED,
+  const gchar *signal_name,
+  GVariant *parameters)
+{
+  _ExtendedGDBusSignalInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  gsize n;
+  guint signal_id;
+  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_gxdp_open_uri_interface_info.parent_struct, signal_name);
+  if (info == NULL)
+    return;
+  num_params = g_variant_n_children (parameters);
+  paramv = g_new0 (GValue, num_params + 1);
+  g_value_init (&paramv[0], GXDP_TYPE_OPEN_URI);
+  g_value_set_object (&paramv[0], proxy);
+  g_variant_iter_init (&iter, parameters);
+  n = 1;
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GXDP_TYPE_OPEN_URI);
+  g_signal_emitv (paramv, signal_id, 0, NULL);
+  for (n = 0; n < num_params + 1; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static void
+gxdp_open_uri_proxy_g_properties_changed (GDBusProxy *_proxy,
+  GVariant *changed_properties,
+  const gchar *const *invalidated_properties)
+{
+  GXdpOpenURIProxy *proxy = GXDP_OPEN_URI_PROXY (_proxy);
+  guint n;
+  const gchar *key;
+  GVariantIter *iter;
+  _ExtendedGDBusPropertyInfo *info;
+  g_variant_get (changed_properties, "a{sv}", &iter);
+  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_open_uri_interface_info.parent_struct, key);
+      g_datalist_remove_data (&proxy->priv->qdata, key);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+  g_variant_iter_free (iter);
+  for (n = 0; invalidated_properties[n] != NULL; n++)
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_open_uri_interface_info.parent_struct, invalidated_properties[n]);
+      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+}
+
+static guint 
+gxdp_open_uri_proxy_get_version (GXdpOpenURI *object)
+{
+  GXdpOpenURIProxy *proxy = GXDP_OPEN_URI_PROXY (object);
+  GVariant *variant;
+  guint value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "version");
+  if (variant != NULL)
+    {
+      value = g_variant_get_uint32 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static void
+gxdp_open_uri_proxy_init (GXdpOpenURIProxy *proxy)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  proxy->priv = gxdp_open_uri_proxy_get_instance_private (proxy);
+#else
+  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GXDP_TYPE_OPEN_URI_PROXY, GXdpOpenURIProxyPrivate);
+#endif
+
+  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), gxdp_open_uri_interface_info ());
+}
+
+static void
+gxdp_open_uri_proxy_class_init (GXdpOpenURIProxyClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusProxyClass *proxy_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize     = gxdp_open_uri_proxy_finalize;
+  gobject_class->get_property = gxdp_open_uri_proxy_get_property;
+  gobject_class->set_property = gxdp_open_uri_proxy_set_property;
+
+  proxy_class = G_DBUS_PROXY_CLASS (klass);
+  proxy_class->g_signal = gxdp_open_uri_proxy_g_signal;
+  proxy_class->g_properties_changed = gxdp_open_uri_proxy_g_properties_changed;
+
+  gxdp_open_uri_override_properties (gobject_class, 1);
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GXdpOpenURIProxyPrivate));
+#endif
+}
+
+static void
+gxdp_open_uri_proxy_iface_init (GXdpOpenURIIface *iface)
+{
+  iface->get_version = gxdp_open_uri_proxy_get_version;
+}
+
+/**
+ * gxdp_open_uri_proxy_new:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-OpenURI.top_of_page">org.freedesktop.portal.OpenURI</link>. See g_dbus_proxy_new() for more details.
+ *
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_open_uri_proxy_new_finish() to get the result of the operation.
+ *
+ * See gxdp_open_uri_proxy_new_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gxdp_open_uri_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GXDP_TYPE_OPEN_URI_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.OpenURI", NULL);
+}
+
+/**
+ * gxdp_open_uri_proxy_new_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_open_uri_proxy_new().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gxdp_open_uri_proxy_new().
+ *
+ * Returns: (transfer full) (type GXdpOpenURIProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpOpenURI *
+gxdp_open_uri_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GXDP_OPEN_URI (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gxdp_open_uri_proxy_new_sync:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-OpenURI.top_of_page">org.freedesktop.portal.OpenURI</link>. See g_dbus_proxy_new_sync() for more details.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_open_uri_proxy_new() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GXdpOpenURIProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpOpenURI *
+gxdp_open_uri_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GXDP_TYPE_OPEN_URI_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.OpenURI", NULL);
+  if (ret != NULL)
+    return GXDP_OPEN_URI (ret);
+  else
+    return NULL;
+}
+
+
+/**
+ * gxdp_open_uri_proxy_new_for_bus:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Like gxdp_open_uri_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_open_uri_proxy_new_for_bus_finish() to get the result of the operation.
+ *
+ * See gxdp_open_uri_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gxdp_open_uri_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GXDP_TYPE_OPEN_URI_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.OpenURI", NULL);
+}
+
+/**
+ * gxdp_open_uri_proxy_new_for_bus_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_open_uri_proxy_new_for_bus().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gxdp_open_uri_proxy_new_for_bus().
+ *
+ * Returns: (transfer full) (type GXdpOpenURIProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpOpenURI *
+gxdp_open_uri_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GXDP_OPEN_URI (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gxdp_open_uri_proxy_new_for_bus_sync:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Like gxdp_open_uri_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_open_uri_proxy_new_for_bus() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GXdpOpenURIProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpOpenURI *
+gxdp_open_uri_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GXDP_TYPE_OPEN_URI_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.OpenURI", NULL);
+  if (ret != NULL)
+    return GXDP_OPEN_URI (ret);
+  else
+    return NULL;
+}
+
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GXdpOpenURISkeleton:
+ *
+ * The #GXdpOpenURISkeleton structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GXdpOpenURISkeletonClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GXdpOpenURISkeleton.
+ */
+
+struct _GXdpOpenURISkeletonPrivate
+{
+  GValue *properties;
+  GList *changed_properties;
+  GSource *changed_properties_idle_source;
+  GMainContext *context;
+  GMutex lock;
+};
+
+static void
+_gxdp_open_uri_skeleton_handle_method_call (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name,
+  const gchar *method_name,
+  GVariant *parameters,
+  GDBusMethodInvocation *invocation,
+  gpointer user_data)
+{
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (user_data);
+  _ExtendedGDBusMethodInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  guint num_extra;
+  gsize n;
+  guint signal_id;
+  GValue return_value = G_VALUE_INIT;
+  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
+  g_assert (info != NULL);
+  num_params = g_variant_n_children (parameters);
+  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
+  n = 0;
+  g_value_init (&paramv[n], GXDP_TYPE_OPEN_URI);
+  g_value_set_object (&paramv[n++], skeleton);
+  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
+  g_value_set_object (&paramv[n++], invocation);
+  if (info->pass_fdlist)
+    {
+#ifdef G_OS_UNIX
+      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
+      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
+#else
+      g_assert_not_reached ();
+#endif
+    }
+  g_variant_iter_init (&iter, parameters);
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GXDP_TYPE_OPEN_URI);
+  g_value_init (&return_value, G_TYPE_BOOLEAN);
+  g_signal_emitv (paramv, signal_id, 0, &return_value);
+  if (!g_value_get_boolean (&return_value))
+    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
+  g_value_unset (&return_value);
+  for (n = 0; n < num_params + num_extra; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static GVariant *
+_gxdp_open_uri_skeleton_handle_get_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GError **error,
+  gpointer user_data)
+{
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  GVariant *ret;
+  ret = NULL;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_open_uri_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      g_value_init (&value, pspec->value_type);
+      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
+      g_value_unset (&value);
+    }
+  return ret;
+}
+
+static gboolean
+_gxdp_open_uri_skeleton_handle_set_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GVariant *variant,
+  GError **error,
+  gpointer user_data)
+{
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  gboolean ret;
+  ret = FALSE;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_open_uri_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      if (info->use_gvariant)
+        g_value_set_variant (&value, variant);
+      else
+        g_dbus_gvariant_to_gvalue (variant, &value);
+      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      g_value_unset (&value);
+      ret = TRUE;
+    }
+  return ret;
+}
+
+static const GDBusInterfaceVTable _gxdp_open_uri_skeleton_vtable =
+{
+  _gxdp_open_uri_skeleton_handle_method_call,
+  _gxdp_open_uri_skeleton_handle_get_property,
+  _gxdp_open_uri_skeleton_handle_set_property,
+  {NULL}
+};
+
+static GDBusInterfaceInfo *
+gxdp_open_uri_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return gxdp_open_uri_interface_info ();
+}
+
+static GDBusInterfaceVTable *
+gxdp_open_uri_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return (GDBusInterfaceVTable *) &_gxdp_open_uri_skeleton_vtable;
+}
+
+static GVariant *
+gxdp_open_uri_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
+{
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (_skeleton);
+
+  GVariantBuilder builder;
+  guint n;
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  if (_gxdp_open_uri_interface_info.parent_struct.properties == NULL)
+    goto out;
+  for (n = 0; _gxdp_open_uri_interface_info.parent_struct.properties[n] != NULL; n++)
+    {
+      GDBusPropertyInfo *info = _gxdp_open_uri_interface_info.parent_struct.properties[n];
+      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
+        {
+          GVariant *value;
+          value = _gxdp_open_uri_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.portal.OpenURI", info->name, NULL, skeleton);
+          if (value != NULL)
+            {
+              g_variant_take_ref (value);
+              g_variant_builder_add (&builder, "{sv}", info->name, value);
+              g_variant_unref (value);
+            }
+        }
+    }
+out:
+  return g_variant_builder_end (&builder);
+}
+
+static gboolean _gxdp_open_uri_emit_changed (gpointer user_data);
+
+static void
+gxdp_open_uri_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
+{
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (_skeleton);
+  gboolean emit_changed = FALSE;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    {
+      g_source_destroy (skeleton->priv->changed_properties_idle_source);
+      skeleton->priv->changed_properties_idle_source = NULL;
+      emit_changed = TRUE;
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+
+  if (emit_changed)
+    _gxdp_open_uri_emit_changed (skeleton);
+}
+
+static void gxdp_open_uri_skeleton_iface_init (GXdpOpenURIIface *iface);
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GXdpOpenURISkeleton, gxdp_open_uri_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_ADD_PRIVATE (GXdpOpenURISkeleton)
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_OPEN_URI, gxdp_open_uri_skeleton_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GXdpOpenURISkeleton, gxdp_open_uri_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_OPEN_URI, gxdp_open_uri_skeleton_iface_init))
+
+#endif
+static void
+gxdp_open_uri_skeleton_finalize (GObject *object)
+{
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (object);
+  guint n;
+  for (n = 0; n < 1; n++)
+    g_value_unset (&skeleton->priv->properties[n]);
+  g_free (skeleton->priv->properties);
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    g_source_destroy (skeleton->priv->changed_properties_idle_source);
+  g_main_context_unref (skeleton->priv->context);
+  g_mutex_clear (&skeleton->priv->lock);
+  G_OBJECT_CLASS (gxdp_open_uri_skeleton_parent_class)->finalize (object);
+}
+
+static void
+gxdp_open_uri_skeleton_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static gboolean
+_gxdp_open_uri_emit_changed (gpointer user_data)
+{
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (user_data);
+  GList *l;
+  GVariantBuilder builder;
+  GVariantBuilder invalidated_builder;
+  guint num_changes;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
+  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
+    {
+      ChangedProperty *cp = l->data;
+      GVariant *variant;
+      const GValue *cur_value;
+
+      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
+      if (!_g_value_equal (cur_value, &cp->orig_value))
+        {
+          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
+          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
+          g_variant_unref (variant);
+          num_changes++;
+        }
+    }
+  if (num_changes > 0)
+    {
+      GList *connections, *ll;
+      GVariant *signal_variant;
+      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.freedesktop.portal.OpenURI",
+                                           &builder, &invalidated_builder));
+      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+      for (ll = connections; ll != NULL; ll = ll->next)
+        {
+          GDBusConnection *connection = ll->data;
+
+          g_dbus_connection_emit_signal (connection,
+                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
+                                         "org.freedesktop.DBus.Properties",
+                                         "PropertiesChanged",
+                                         signal_variant,
+                                         NULL);
+        }
+      g_variant_unref (signal_variant);
+      g_list_free_full (connections, g_object_unref);
+    }
+  else
+    {
+      g_variant_builder_clear (&builder);
+      g_variant_builder_clear (&invalidated_builder);
+    }
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  skeleton->priv->changed_properties = NULL;
+  skeleton->priv->changed_properties_idle_source = NULL;
+  g_mutex_unlock (&skeleton->priv->lock);
+  return FALSE;
+}
+
+static void
+_gxdp_open_uri_schedule_emit_changed (GXdpOpenURISkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
+{
+  ChangedProperty *cp;
+  GList *l;
+  cp = NULL;
+  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
+    {
+      ChangedProperty *i_cp = l->data;
+      if (i_cp->info == info)
+        {
+          cp = i_cp;
+          break;
+        }
+    }
+  if (cp == NULL)
+    {
+      cp = g_new0 (ChangedProperty, 1);
+      cp->prop_id = prop_id;
+      cp->info = info;
+      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
+      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
+      g_value_copy (orig_value, &cp->orig_value);
+    }
+}
+
+static void
+gxdp_open_uri_skeleton_notify (GObject      *object,
+  GParamSpec *pspec G_GNUC_UNUSED)
+{
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (object);
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties != NULL &&
+      skeleton->priv->changed_properties_idle_source == NULL)
+    {
+      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
+      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
+      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _gxdp_open_uri_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
+      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _gxdp_open_uri_emit_changed");
+      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
+      g_source_unref (skeleton->priv->changed_properties_idle_source);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static void
+gxdp_open_uri_skeleton_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_open_uri_property_info_pointers[prop_id - 1];
+  g_mutex_lock (&skeleton->priv->lock);
+  g_object_freeze_notify (object);
+  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
+    {
+      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
+          info->emits_changed_signal)
+        _gxdp_open_uri_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
+      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
+      g_object_notify_by_pspec (object, pspec);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+  g_object_thaw_notify (object);
+}
+
+static void
+gxdp_open_uri_skeleton_init (GXdpOpenURISkeleton *skeleton)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  skeleton->priv = gxdp_open_uri_skeleton_get_instance_private (skeleton);
+#else
+  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GXDP_TYPE_OPEN_URI_SKELETON, GXdpOpenURISkeletonPrivate);
+#endif
+
+  g_mutex_init (&skeleton->priv->lock);
+  skeleton->priv->context = g_main_context_ref_thread_default ();
+  skeleton->priv->properties = g_new0 (GValue, 1);
+  g_value_init (&skeleton->priv->properties[0], G_TYPE_UINT);
+}
+
+static guint 
+gxdp_open_uri_skeleton_get_version (GXdpOpenURI *object)
+{
+  GXdpOpenURISkeleton *skeleton = GXDP_OPEN_URI_SKELETON (object);
+  guint value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_uint (&(skeleton->priv->properties[0]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static void
+gxdp_open_uri_skeleton_class_init (GXdpOpenURISkeletonClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusInterfaceSkeletonClass *skeleton_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = gxdp_open_uri_skeleton_finalize;
+  gobject_class->get_property = gxdp_open_uri_skeleton_get_property;
+  gobject_class->set_property = gxdp_open_uri_skeleton_set_property;
+  gobject_class->notify       = gxdp_open_uri_skeleton_notify;
+
+
+  gxdp_open_uri_override_properties (gobject_class, 1);
+
+  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
+  skeleton_class->get_info = gxdp_open_uri_skeleton_dbus_interface_get_info;
+  skeleton_class->get_properties = gxdp_open_uri_skeleton_dbus_interface_get_properties;
+  skeleton_class->flush = gxdp_open_uri_skeleton_dbus_interface_flush;
+  skeleton_class->get_vtable = gxdp_open_uri_skeleton_dbus_interface_get_vtable;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GXdpOpenURISkeletonPrivate));
+#endif
+}
+
+static void
+gxdp_open_uri_skeleton_iface_init (GXdpOpenURIIface *iface)
+{
+  iface->get_version = gxdp_open_uri_skeleton_get_version;
+}
+
+/**
+ * gxdp_open_uri_skeleton_new:
+ *
+ * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-OpenURI.top_of_page">org.freedesktop.portal.OpenURI</link>.
+ *
+ * Returns: (transfer full) (type GXdpOpenURISkeleton): The skeleton object.
+ */
+GXdpOpenURI *
+gxdp_open_uri_skeleton_new (void)
+{
+  return GXDP_OPEN_URI (g_object_new (GXDP_TYPE_OPEN_URI_SKELETON, NULL));
+}
+
+/* ------------------------------------------------------------------------
+ * Code for interface org.freedesktop.portal.ProxyResolver
+ * ------------------------------------------------------------------------
+ */
+
+/**
+ * SECTION:GXdpProxyResolver
+ * @title: GXdpProxyResolver
+ * @short_description: Generated C code for the org.freedesktop.portal.ProxyResolver D-Bus interface
+ *
+ * This section contains code for working with the <link linkend="gdbus-interface-org-freedesktop-portal-ProxyResolver.top_of_page">org.freedesktop.portal.ProxyResolver</link> D-Bus interface in C.
+ */
+
+/* ---- Introspection data for org.freedesktop.portal.ProxyResolver ---- */
+
+static const _ExtendedGDBusArgInfo _gxdp_proxy_resolver_method_info_lookup_IN_ARG_uri =
+{
+  {
+    -1,
+    (gchar *) "uri",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_proxy_resolver_method_info_lookup_IN_ARG_pointers[] =
+{
+  &_gxdp_proxy_resolver_method_info_lookup_IN_ARG_uri.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_proxy_resolver_method_info_lookup_OUT_ARG_proxies =
+{
+  {
+    -1,
+    (gchar *) "proxies",
+    (gchar *) "as",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_proxy_resolver_method_info_lookup_OUT_ARG_pointers[] =
+{
+  &_gxdp_proxy_resolver_method_info_lookup_OUT_ARG_proxies.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_proxy_resolver_method_info_lookup =
+{
+  {
+    -1,
+    (gchar *) "Lookup",
+    (GDBusArgInfo **) &_gxdp_proxy_resolver_method_info_lookup_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_proxy_resolver_method_info_lookup_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-lookup",
+  FALSE
+};
+
+static const GDBusMethodInfo * const _gxdp_proxy_resolver_method_info_pointers[] =
+{
+  &_gxdp_proxy_resolver_method_info_lookup.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusPropertyInfo _gxdp_proxy_resolver_property_info_version =
+{
+  {
+    -1,
+    (gchar *) "version",
+    (gchar *) "u",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "version",
+  FALSE,
+  TRUE
+};
+
+static const GDBusPropertyInfo * const _gxdp_proxy_resolver_property_info_pointers[] =
+{
+  &_gxdp_proxy_resolver_property_info_version.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusInterfaceInfo _gxdp_proxy_resolver_interface_info =
+{
+  {
+    -1,
+    (gchar *) "org.freedesktop.portal.ProxyResolver",
+    (GDBusMethodInfo **) &_gxdp_proxy_resolver_method_info_pointers,
+    NULL,
+    (GDBusPropertyInfo **) &_gxdp_proxy_resolver_property_info_pointers,
+    NULL
+  },
+  "proxy-resolver",
+};
+
+
+/**
+ * gxdp_proxy_resolver_interface_info:
+ *
+ * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-portal-ProxyResolver.top_of_page">org.freedesktop.portal.ProxyResolver</link> D-Bus interface.
+ *
+ * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
+ */
+GDBusInterfaceInfo *
+gxdp_proxy_resolver_interface_info (void)
+{
+  return (GDBusInterfaceInfo *) &_gxdp_proxy_resolver_interface_info.parent_struct;
+}
+
+/**
+ * gxdp_proxy_resolver_override_properties:
+ * @klass: The class structure for a #GObject derived class.
+ * @property_id_begin: The property id to assign to the first overridden property.
+ *
+ * Overrides all #GObject properties in the #GXdpProxyResolver interface for a concrete class.
+ * The properties are overridden in the order they are defined.
+ *
+ * Returns: The last property id.
+ */
+guint
+gxdp_proxy_resolver_override_properties (GObjectClass *klass, guint property_id_begin)
+{
+  g_object_class_override_property (klass, property_id_begin++, "version");
+  return property_id_begin - 1;
+}
+
+
+
+/**
+ * GXdpProxyResolver:
+ *
+ * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-ProxyResolver.top_of_page">org.freedesktop.portal.ProxyResolver</link>.
+ */
+
+/**
+ * GXdpProxyResolverIface:
+ * @parent_iface: The parent interface.
+ * @handle_lookup: Handler for the #GXdpProxyResolver::handle-lookup signal.
+ * @get_version: Getter for the #GXdpProxyResolver:version property.
+ *
+ * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-ProxyResolver.top_of_page">org.freedesktop.portal.ProxyResolver</link>.
+ */
+
+typedef GXdpProxyResolverIface GXdpProxyResolverInterface;
+G_DEFINE_INTERFACE (GXdpProxyResolver, gxdp_proxy_resolver, G_TYPE_OBJECT)
+
+static void
+gxdp_proxy_resolver_default_init (GXdpProxyResolverIface *iface)
+{
+  /* GObject signals for incoming D-Bus method calls: */
+  /**
+   * GXdpProxyResolver::handle-lookup:
+   * @object: A #GXdpProxyResolver.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_uri: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-ProxyResolver.Lookup">Lookup()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_proxy_resolver_complete_lookup() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-lookup",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpProxyResolverIface, handle_lookup),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /* GObject properties for D-Bus properties: */
+  /**
+   * GXdpProxyResolver:version:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-portal-ProxyResolver.version">"version"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_uint ("version", "version", "version", 0, G_MAXUINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+/**
+ * gxdp_proxy_resolver_get_version: (skip)
+ * @object: A #GXdpProxyResolver.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-portal-ProxyResolver.version">"version"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+guint 
+gxdp_proxy_resolver_get_version (GXdpProxyResolver *object)
+{
+  return GXDP_PROXY_RESOLVER_GET_IFACE (object)->get_version (object);
+}
+
+/**
+ * gxdp_proxy_resolver_set_version: (skip)
+ * @object: A #GXdpProxyResolver.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-portal-ProxyResolver.version">"version"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gxdp_proxy_resolver_set_version (GXdpProxyResolver *object, guint value)
+{
+  g_object_set (G_OBJECT (object), "version", value, NULL);
+}
+
+/**
+ * gxdp_proxy_resolver_call_lookup:
+ * @proxy: A #GXdpProxyResolverProxy.
+ * @arg_uri: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-ProxyResolver.Lookup">Lookup()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_proxy_resolver_call_lookup_finish() to get the result of the operation.
+ *
+ * See gxdp_proxy_resolver_call_lookup_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_proxy_resolver_call_lookup (
+    GXdpProxyResolver *proxy,
+    const gchar *arg_uri,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "Lookup",
+    g_variant_new ("(s)",
+                   arg_uri),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_proxy_resolver_call_lookup_finish:
+ * @proxy: A #GXdpProxyResolverProxy.
+ * @out_proxies: (out) (optional) (array zero-terminated=1): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_proxy_resolver_call_lookup().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_proxy_resolver_call_lookup().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_proxy_resolver_call_lookup_finish (
+    GXdpProxyResolver *proxy,
+    gchar ***out_proxies,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^as)",
+                 out_proxies);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_proxy_resolver_call_lookup_sync:
+ * @proxy: A #GXdpProxyResolverProxy.
+ * @arg_uri: Argument to pass with the method invocation.
+ * @out_proxies: (out) (optional) (array zero-terminated=1): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-ProxyResolver.Lookup">Lookup()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_proxy_resolver_call_lookup() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_proxy_resolver_call_lookup_sync (
+    GXdpProxyResolver *proxy,
+    const gchar *arg_uri,
+    gchar ***out_proxies,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "Lookup",
+    g_variant_new ("(s)",
+                   arg_uri),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(^as)",
+                 out_proxies);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_proxy_resolver_complete_lookup:
+ * @object: A #GXdpProxyResolver.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @proxies: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-ProxyResolver.Lookup">Lookup()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_proxy_resolver_complete_lookup (
+    GXdpProxyResolver *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    const gchar *const *proxies)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(^as)",
+                   proxies));
+}
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GXdpProxyResolverProxy:
+ *
+ * The #GXdpProxyResolverProxy structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GXdpProxyResolverProxyClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GXdpProxyResolverProxy.
+ */
+
+struct _GXdpProxyResolverProxyPrivate
+{
+  GData *qdata;
+};
+
+static void gxdp_proxy_resolver_proxy_iface_init (GXdpProxyResolverIface *iface);
+
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GXdpProxyResolverProxy, gxdp_proxy_resolver_proxy, G_TYPE_DBUS_PROXY,
+                         G_ADD_PRIVATE (GXdpProxyResolverProxy)
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_PROXY_RESOLVER, gxdp_proxy_resolver_proxy_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GXdpProxyResolverProxy, gxdp_proxy_resolver_proxy, G_TYPE_DBUS_PROXY,
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_PROXY_RESOLVER, gxdp_proxy_resolver_proxy_iface_init))
+
+#endif
+static void
+gxdp_proxy_resolver_proxy_finalize (GObject *object)
+{
+  GXdpProxyResolverProxy *proxy = GXDP_PROXY_RESOLVER_PROXY (object);
+  g_datalist_clear (&proxy->priv->qdata);
+  G_OBJECT_CLASS (gxdp_proxy_resolver_proxy_parent_class)->finalize (object);
+}
+
+static void
+gxdp_proxy_resolver_proxy_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_proxy_resolver_property_info_pointers[prop_id - 1];
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
+  if (info->use_gvariant)
+    {
+      g_value_set_variant (value, variant);
+    }
+  else
+    {
+      if (variant != NULL)
+        g_dbus_gvariant_to_gvalue (variant, value);
+    }
+  if (variant != NULL)
+    g_variant_unref (variant);
+}
+
+static void
+gxdp_proxy_resolver_proxy_set_property_cb (GDBusProxy *proxy,
+  GAsyncResult *res,
+  gpointer      user_data)
+{
+  const _ExtendedGDBusPropertyInfo *info = user_data;
+  GError *error;
+  GVariant *_ret;
+  error = NULL;
+  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
+  if (!_ret)
+    {
+      g_warning ("Error setting property '%s' on interface org.freedesktop.portal.ProxyResolver: %s (%s, %d)",
+                 info->parent_struct.name, 
+                 error->message, g_quark_to_string (error->domain), error->code);
+      g_error_free (error);
+    }
+  else
+    {
+      g_variant_unref (_ret);
+    }
+}
+
+static void
+gxdp_proxy_resolver_proxy_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_proxy_resolver_property_info_pointers[prop_id - 1];
+  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
+  g_dbus_proxy_call (G_DBUS_PROXY (object),
+    "org.freedesktop.DBus.Properties.Set",
+    g_variant_new ("(ssv)", "org.freedesktop.portal.ProxyResolver", info->parent_struct.name, variant),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    NULL, (GAsyncReadyCallback) gxdp_proxy_resolver_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
+  g_variant_unref (variant);
+}
+
+static void
+gxdp_proxy_resolver_proxy_g_signal (GDBusProxy *proxy,
+  const gchar *sender_name G_GNUC_UNUSED,
+  const gchar *signal_name,
+  GVariant *parameters)
+{
+  _ExtendedGDBusSignalInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  gsize n;
+  guint signal_id;
+  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_gxdp_proxy_resolver_interface_info.parent_struct, signal_name);
+  if (info == NULL)
+    return;
+  num_params = g_variant_n_children (parameters);
+  paramv = g_new0 (GValue, num_params + 1);
+  g_value_init (&paramv[0], GXDP_TYPE_PROXY_RESOLVER);
+  g_value_set_object (&paramv[0], proxy);
+  g_variant_iter_init (&iter, parameters);
+  n = 1;
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GXDP_TYPE_PROXY_RESOLVER);
+  g_signal_emitv (paramv, signal_id, 0, NULL);
+  for (n = 0; n < num_params + 1; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static void
+gxdp_proxy_resolver_proxy_g_properties_changed (GDBusProxy *_proxy,
+  GVariant *changed_properties,
+  const gchar *const *invalidated_properties)
+{
+  GXdpProxyResolverProxy *proxy = GXDP_PROXY_RESOLVER_PROXY (_proxy);
+  guint n;
+  const gchar *key;
+  GVariantIter *iter;
+  _ExtendedGDBusPropertyInfo *info;
+  g_variant_get (changed_properties, "a{sv}", &iter);
+  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_proxy_resolver_interface_info.parent_struct, key);
+      g_datalist_remove_data (&proxy->priv->qdata, key);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+  g_variant_iter_free (iter);
+  for (n = 0; invalidated_properties[n] != NULL; n++)
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_proxy_resolver_interface_info.parent_struct, invalidated_properties[n]);
+      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+}
+
+static guint 
+gxdp_proxy_resolver_proxy_get_version (GXdpProxyResolver *object)
+{
+  GXdpProxyResolverProxy *proxy = GXDP_PROXY_RESOLVER_PROXY (object);
+  GVariant *variant;
+  guint value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "version");
+  if (variant != NULL)
+    {
+      value = g_variant_get_uint32 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static void
+gxdp_proxy_resolver_proxy_init (GXdpProxyResolverProxy *proxy)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  proxy->priv = gxdp_proxy_resolver_proxy_get_instance_private (proxy);
+#else
+  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GXDP_TYPE_PROXY_RESOLVER_PROXY, GXdpProxyResolverProxyPrivate);
+#endif
+
+  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), gxdp_proxy_resolver_interface_info ());
+}
+
+static void
+gxdp_proxy_resolver_proxy_class_init (GXdpProxyResolverProxyClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusProxyClass *proxy_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize     = gxdp_proxy_resolver_proxy_finalize;
+  gobject_class->get_property = gxdp_proxy_resolver_proxy_get_property;
+  gobject_class->set_property = gxdp_proxy_resolver_proxy_set_property;
+
+  proxy_class = G_DBUS_PROXY_CLASS (klass);
+  proxy_class->g_signal = gxdp_proxy_resolver_proxy_g_signal;
+  proxy_class->g_properties_changed = gxdp_proxy_resolver_proxy_g_properties_changed;
+
+  gxdp_proxy_resolver_override_properties (gobject_class, 1);
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GXdpProxyResolverProxyPrivate));
+#endif
+}
+
+static void
+gxdp_proxy_resolver_proxy_iface_init (GXdpProxyResolverIface *iface)
+{
+  iface->get_version = gxdp_proxy_resolver_proxy_get_version;
+}
+
+/**
+ * gxdp_proxy_resolver_proxy_new:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-ProxyResolver.top_of_page">org.freedesktop.portal.ProxyResolver</link>. See g_dbus_proxy_new() for more details.
+ *
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_proxy_resolver_proxy_new_finish() to get the result of the operation.
+ *
+ * See gxdp_proxy_resolver_proxy_new_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gxdp_proxy_resolver_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GXDP_TYPE_PROXY_RESOLVER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.ProxyResolver", NULL);
+}
+
+/**
+ * gxdp_proxy_resolver_proxy_new_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_proxy_resolver_proxy_new().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gxdp_proxy_resolver_proxy_new().
+ *
+ * Returns: (transfer full) (type GXdpProxyResolverProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpProxyResolver *
+gxdp_proxy_resolver_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GXDP_PROXY_RESOLVER (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gxdp_proxy_resolver_proxy_new_sync:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-ProxyResolver.top_of_page">org.freedesktop.portal.ProxyResolver</link>. See g_dbus_proxy_new_sync() for more details.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_proxy_resolver_proxy_new() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GXdpProxyResolverProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpProxyResolver *
+gxdp_proxy_resolver_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GXDP_TYPE_PROXY_RESOLVER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.ProxyResolver", NULL);
+  if (ret != NULL)
+    return GXDP_PROXY_RESOLVER (ret);
+  else
+    return NULL;
+}
+
+
+/**
+ * gxdp_proxy_resolver_proxy_new_for_bus:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Like gxdp_proxy_resolver_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_proxy_resolver_proxy_new_for_bus_finish() to get the result of the operation.
+ *
+ * See gxdp_proxy_resolver_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gxdp_proxy_resolver_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GXDP_TYPE_PROXY_RESOLVER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.ProxyResolver", NULL);
+}
+
+/**
+ * gxdp_proxy_resolver_proxy_new_for_bus_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_proxy_resolver_proxy_new_for_bus().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gxdp_proxy_resolver_proxy_new_for_bus().
+ *
+ * Returns: (transfer full) (type GXdpProxyResolverProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpProxyResolver *
+gxdp_proxy_resolver_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GXDP_PROXY_RESOLVER (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gxdp_proxy_resolver_proxy_new_for_bus_sync:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Like gxdp_proxy_resolver_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_proxy_resolver_proxy_new_for_bus() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GXdpProxyResolverProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpProxyResolver *
+gxdp_proxy_resolver_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GXDP_TYPE_PROXY_RESOLVER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.ProxyResolver", NULL);
+  if (ret != NULL)
+    return GXDP_PROXY_RESOLVER (ret);
+  else
+    return NULL;
+}
+
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GXdpProxyResolverSkeleton:
+ *
+ * The #GXdpProxyResolverSkeleton structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GXdpProxyResolverSkeletonClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GXdpProxyResolverSkeleton.
+ */
+
+struct _GXdpProxyResolverSkeletonPrivate
+{
+  GValue *properties;
+  GList *changed_properties;
+  GSource *changed_properties_idle_source;
+  GMainContext *context;
+  GMutex lock;
+};
+
+static void
+_gxdp_proxy_resolver_skeleton_handle_method_call (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name,
+  const gchar *method_name,
+  GVariant *parameters,
+  GDBusMethodInvocation *invocation,
+  gpointer user_data)
+{
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (user_data);
+  _ExtendedGDBusMethodInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  guint num_extra;
+  gsize n;
+  guint signal_id;
+  GValue return_value = G_VALUE_INIT;
+  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
+  g_assert (info != NULL);
+  num_params = g_variant_n_children (parameters);
+  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
+  n = 0;
+  g_value_init (&paramv[n], GXDP_TYPE_PROXY_RESOLVER);
+  g_value_set_object (&paramv[n++], skeleton);
+  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
+  g_value_set_object (&paramv[n++], invocation);
+  if (info->pass_fdlist)
+    {
+#ifdef G_OS_UNIX
+      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
+      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
+#else
+      g_assert_not_reached ();
+#endif
+    }
+  g_variant_iter_init (&iter, parameters);
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GXDP_TYPE_PROXY_RESOLVER);
+  g_value_init (&return_value, G_TYPE_BOOLEAN);
+  g_signal_emitv (paramv, signal_id, 0, &return_value);
+  if (!g_value_get_boolean (&return_value))
+    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
+  g_value_unset (&return_value);
+  for (n = 0; n < num_params + num_extra; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static GVariant *
+_gxdp_proxy_resolver_skeleton_handle_get_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GError **error,
+  gpointer user_data)
+{
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  GVariant *ret;
+  ret = NULL;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_proxy_resolver_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      g_value_init (&value, pspec->value_type);
+      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
+      g_value_unset (&value);
+    }
+  return ret;
+}
+
+static gboolean
+_gxdp_proxy_resolver_skeleton_handle_set_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GVariant *variant,
+  GError **error,
+  gpointer user_data)
+{
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  gboolean ret;
+  ret = FALSE;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_proxy_resolver_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      if (info->use_gvariant)
+        g_value_set_variant (&value, variant);
+      else
+        g_dbus_gvariant_to_gvalue (variant, &value);
+      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      g_value_unset (&value);
+      ret = TRUE;
+    }
+  return ret;
+}
+
+static const GDBusInterfaceVTable _gxdp_proxy_resolver_skeleton_vtable =
+{
+  _gxdp_proxy_resolver_skeleton_handle_method_call,
+  _gxdp_proxy_resolver_skeleton_handle_get_property,
+  _gxdp_proxy_resolver_skeleton_handle_set_property,
+  {NULL}
+};
+
+static GDBusInterfaceInfo *
+gxdp_proxy_resolver_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return gxdp_proxy_resolver_interface_info ();
+}
+
+static GDBusInterfaceVTable *
+gxdp_proxy_resolver_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return (GDBusInterfaceVTable *) &_gxdp_proxy_resolver_skeleton_vtable;
+}
+
+static GVariant *
+gxdp_proxy_resolver_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
+{
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (_skeleton);
+
+  GVariantBuilder builder;
+  guint n;
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  if (_gxdp_proxy_resolver_interface_info.parent_struct.properties == NULL)
+    goto out;
+  for (n = 0; _gxdp_proxy_resolver_interface_info.parent_struct.properties[n] != NULL; n++)
+    {
+      GDBusPropertyInfo *info = _gxdp_proxy_resolver_interface_info.parent_struct.properties[n];
+      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
+        {
+          GVariant *value;
+          value = _gxdp_proxy_resolver_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.portal.ProxyResolver", info->name, NULL, skeleton);
+          if (value != NULL)
+            {
+              g_variant_take_ref (value);
+              g_variant_builder_add (&builder, "{sv}", info->name, value);
+              g_variant_unref (value);
+            }
+        }
+    }
+out:
+  return g_variant_builder_end (&builder);
+}
+
+static gboolean _gxdp_proxy_resolver_emit_changed (gpointer user_data);
+
+static void
+gxdp_proxy_resolver_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
+{
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (_skeleton);
+  gboolean emit_changed = FALSE;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    {
+      g_source_destroy (skeleton->priv->changed_properties_idle_source);
+      skeleton->priv->changed_properties_idle_source = NULL;
+      emit_changed = TRUE;
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+
+  if (emit_changed)
+    _gxdp_proxy_resolver_emit_changed (skeleton);
+}
+
+static void gxdp_proxy_resolver_skeleton_iface_init (GXdpProxyResolverIface *iface);
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GXdpProxyResolverSkeleton, gxdp_proxy_resolver_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_ADD_PRIVATE (GXdpProxyResolverSkeleton)
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_PROXY_RESOLVER, gxdp_proxy_resolver_skeleton_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GXdpProxyResolverSkeleton, gxdp_proxy_resolver_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_PROXY_RESOLVER, gxdp_proxy_resolver_skeleton_iface_init))
+
+#endif
+static void
+gxdp_proxy_resolver_skeleton_finalize (GObject *object)
+{
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (object);
+  guint n;
+  for (n = 0; n < 1; n++)
+    g_value_unset (&skeleton->priv->properties[n]);
+  g_free (skeleton->priv->properties);
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    g_source_destroy (skeleton->priv->changed_properties_idle_source);
+  g_main_context_unref (skeleton->priv->context);
+  g_mutex_clear (&skeleton->priv->lock);
+  G_OBJECT_CLASS (gxdp_proxy_resolver_skeleton_parent_class)->finalize (object);
+}
+
+static void
+gxdp_proxy_resolver_skeleton_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static gboolean
+_gxdp_proxy_resolver_emit_changed (gpointer user_data)
+{
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (user_data);
+  GList *l;
+  GVariantBuilder builder;
+  GVariantBuilder invalidated_builder;
+  guint num_changes;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
+  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
+    {
+      ChangedProperty *cp = l->data;
+      GVariant *variant;
+      const GValue *cur_value;
+
+      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
+      if (!_g_value_equal (cur_value, &cp->orig_value))
+        {
+          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
+          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
+          g_variant_unref (variant);
+          num_changes++;
+        }
+    }
+  if (num_changes > 0)
+    {
+      GList *connections, *ll;
+      GVariant *signal_variant;
+      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.freedesktop.portal.ProxyResolver",
+                                           &builder, &invalidated_builder));
+      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+      for (ll = connections; ll != NULL; ll = ll->next)
+        {
+          GDBusConnection *connection = ll->data;
+
+          g_dbus_connection_emit_signal (connection,
+                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
+                                         "org.freedesktop.DBus.Properties",
+                                         "PropertiesChanged",
+                                         signal_variant,
+                                         NULL);
+        }
+      g_variant_unref (signal_variant);
+      g_list_free_full (connections, g_object_unref);
+    }
+  else
+    {
+      g_variant_builder_clear (&builder);
+      g_variant_builder_clear (&invalidated_builder);
+    }
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  skeleton->priv->changed_properties = NULL;
+  skeleton->priv->changed_properties_idle_source = NULL;
+  g_mutex_unlock (&skeleton->priv->lock);
+  return FALSE;
+}
+
+static void
+_gxdp_proxy_resolver_schedule_emit_changed (GXdpProxyResolverSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
+{
+  ChangedProperty *cp;
+  GList *l;
+  cp = NULL;
+  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
+    {
+      ChangedProperty *i_cp = l->data;
+      if (i_cp->info == info)
+        {
+          cp = i_cp;
+          break;
+        }
+    }
+  if (cp == NULL)
+    {
+      cp = g_new0 (ChangedProperty, 1);
+      cp->prop_id = prop_id;
+      cp->info = info;
+      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
+      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
+      g_value_copy (orig_value, &cp->orig_value);
+    }
+}
+
+static void
+gxdp_proxy_resolver_skeleton_notify (GObject      *object,
+  GParamSpec *pspec G_GNUC_UNUSED)
+{
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (object);
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties != NULL &&
+      skeleton->priv->changed_properties_idle_source == NULL)
+    {
+      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
+      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
+      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _gxdp_proxy_resolver_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
+      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _gxdp_proxy_resolver_emit_changed");
+      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
+      g_source_unref (skeleton->priv->changed_properties_idle_source);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static void
+gxdp_proxy_resolver_skeleton_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_proxy_resolver_property_info_pointers[prop_id - 1];
+  g_mutex_lock (&skeleton->priv->lock);
+  g_object_freeze_notify (object);
+  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
+    {
+      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
+          info->emits_changed_signal)
+        _gxdp_proxy_resolver_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
+      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
+      g_object_notify_by_pspec (object, pspec);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+  g_object_thaw_notify (object);
+}
+
+static void
+gxdp_proxy_resolver_skeleton_init (GXdpProxyResolverSkeleton *skeleton)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  skeleton->priv = gxdp_proxy_resolver_skeleton_get_instance_private (skeleton);
+#else
+  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GXDP_TYPE_PROXY_RESOLVER_SKELETON, GXdpProxyResolverSkeletonPrivate);
+#endif
+
+  g_mutex_init (&skeleton->priv->lock);
+  skeleton->priv->context = g_main_context_ref_thread_default ();
+  skeleton->priv->properties = g_new0 (GValue, 1);
+  g_value_init (&skeleton->priv->properties[0], G_TYPE_UINT);
+}
+
+static guint 
+gxdp_proxy_resolver_skeleton_get_version (GXdpProxyResolver *object)
+{
+  GXdpProxyResolverSkeleton *skeleton = GXDP_PROXY_RESOLVER_SKELETON (object);
+  guint value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_uint (&(skeleton->priv->properties[0]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static void
+gxdp_proxy_resolver_skeleton_class_init (GXdpProxyResolverSkeletonClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusInterfaceSkeletonClass *skeleton_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = gxdp_proxy_resolver_skeleton_finalize;
+  gobject_class->get_property = gxdp_proxy_resolver_skeleton_get_property;
+  gobject_class->set_property = gxdp_proxy_resolver_skeleton_set_property;
+  gobject_class->notify       = gxdp_proxy_resolver_skeleton_notify;
+
+
+  gxdp_proxy_resolver_override_properties (gobject_class, 1);
+
+  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
+  skeleton_class->get_info = gxdp_proxy_resolver_skeleton_dbus_interface_get_info;
+  skeleton_class->get_properties = gxdp_proxy_resolver_skeleton_dbus_interface_get_properties;
+  skeleton_class->flush = gxdp_proxy_resolver_skeleton_dbus_interface_flush;
+  skeleton_class->get_vtable = gxdp_proxy_resolver_skeleton_dbus_interface_get_vtable;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GXdpProxyResolverSkeletonPrivate));
+#endif
+}
+
+static void
+gxdp_proxy_resolver_skeleton_iface_init (GXdpProxyResolverIface *iface)
+{
+  iface->get_version = gxdp_proxy_resolver_skeleton_get_version;
+}
+
+/**
+ * gxdp_proxy_resolver_skeleton_new:
+ *
+ * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-ProxyResolver.top_of_page">org.freedesktop.portal.ProxyResolver</link>.
+ *
+ * Returns: (transfer full) (type GXdpProxyResolverSkeleton): The skeleton object.
+ */
+GXdpProxyResolver *
+gxdp_proxy_resolver_skeleton_new (void)
+{
+  return GXDP_PROXY_RESOLVER (g_object_new (GXDP_TYPE_PROXY_RESOLVER_SKELETON, NULL));
+}
+
+/* ------------------------------------------------------------------------
+ * Code for interface org.freedesktop.portal.Trash
+ * ------------------------------------------------------------------------
+ */
+
+/**
+ * SECTION:GXdpTrash
+ * @title: GXdpTrash
+ * @short_description: Generated C code for the org.freedesktop.portal.Trash D-Bus interface
+ *
+ * This section contains code for working with the <link linkend="gdbus-interface-org-freedesktop-portal-Trash.top_of_page">org.freedesktop.portal.Trash</link> D-Bus interface in C.
+ */
+
+/* ---- Introspection data for org.freedesktop.portal.Trash ---- */
+
+static const _ExtendedGDBusArgInfo _gxdp_trash_method_info_trash_file_IN_ARG_fd =
+{
+  {
+    -1,
+    (gchar *) "fd",
+    (gchar *) "h",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_trash_method_info_trash_file_IN_ARG_pointers[] =
+{
+  &_gxdp_trash_method_info_trash_file_IN_ARG_fd.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _gxdp_trash_method_info_trash_file_OUT_ARG_result =
+{
+  {
+    -1,
+    (gchar *) "result",
+    (gchar *) "u",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _gxdp_trash_method_info_trash_file_OUT_ARG_pointers[] =
+{
+  &_gxdp_trash_method_info_trash_file_OUT_ARG_result.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _gxdp_trash_method_info_trash_file =
+{
+  {
+    -1,
+    (gchar *) "TrashFile",
+    (GDBusArgInfo **) &_gxdp_trash_method_info_trash_file_IN_ARG_pointers,
+    (GDBusArgInfo **) &_gxdp_trash_method_info_trash_file_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-trash-file",
+  TRUE
+};
+
+static const GDBusMethodInfo * const _gxdp_trash_method_info_pointers[] =
+{
+  &_gxdp_trash_method_info_trash_file.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusPropertyInfo _gxdp_trash_property_info_version =
+{
+  {
+    -1,
+    (gchar *) "version",
+    (gchar *) "u",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "version",
+  FALSE,
+  TRUE
+};
+
+static const GDBusPropertyInfo * const _gxdp_trash_property_info_pointers[] =
+{
+  &_gxdp_trash_property_info_version.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusInterfaceInfo _gxdp_trash_interface_info =
+{
+  {
+    -1,
+    (gchar *) "org.freedesktop.portal.Trash",
+    (GDBusMethodInfo **) &_gxdp_trash_method_info_pointers,
+    NULL,
+    (GDBusPropertyInfo **) &_gxdp_trash_property_info_pointers,
+    NULL
+  },
+  "trash",
+};
+
+
+/**
+ * gxdp_trash_interface_info:
+ *
+ * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-portal-Trash.top_of_page">org.freedesktop.portal.Trash</link> D-Bus interface.
+ *
+ * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
+ */
+GDBusInterfaceInfo *
+gxdp_trash_interface_info (void)
+{
+  return (GDBusInterfaceInfo *) &_gxdp_trash_interface_info.parent_struct;
+}
+
+/**
+ * gxdp_trash_override_properties:
+ * @klass: The class structure for a #GObject derived class.
+ * @property_id_begin: The property id to assign to the first overridden property.
+ *
+ * Overrides all #GObject properties in the #GXdpTrash interface for a concrete class.
+ * The properties are overridden in the order they are defined.
+ *
+ * Returns: The last property id.
+ */
+guint
+gxdp_trash_override_properties (GObjectClass *klass, guint property_id_begin)
+{
+  g_object_class_override_property (klass, property_id_begin++, "version");
+  return property_id_begin - 1;
+}
+
+
+
+/**
+ * GXdpTrash:
+ *
+ * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-Trash.top_of_page">org.freedesktop.portal.Trash</link>.
+ */
+
+/**
+ * GXdpTrashIface:
+ * @parent_iface: The parent interface.
+ * @handle_trash_file: Handler for the #GXdpTrash::handle-trash-file signal.
+ * @get_version: Getter for the #GXdpTrash:version property.
+ *
+ * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-Trash.top_of_page">org.freedesktop.portal.Trash</link>.
+ */
+
+typedef GXdpTrashIface GXdpTrashInterface;
+G_DEFINE_INTERFACE (GXdpTrash, gxdp_trash, G_TYPE_OBJECT)
+
+static void
+gxdp_trash_default_init (GXdpTrashIface *iface)
+{
+  /* GObject signals for incoming D-Bus method calls: */
+  /**
+   * GXdpTrash::handle-trash-file:
+   * @object: A #GXdpTrash.
+   * @invocation: A #GDBusMethodInvocation.
+   * @fd_list: (nullable): A #GUnixFDList or %NULL.
+   * @arg_fd: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-portal-Trash.TrashFile">TrashFile()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call gxdp_trash_complete_trash_file() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %G_DBUS_METHOD_INVOCATION_HANDLED or %TRUE if the invocation was handled, %G_DBUS_METHOD_INVOCATION_UNHANDLED or %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-trash-file",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (GXdpTrashIface, handle_trash_file),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    3,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UNIX_FD_LIST, G_TYPE_VARIANT);
+
+  /* GObject properties for D-Bus properties: */
+  /**
+   * GXdpTrash:version:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-portal-Trash.version">"version"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_uint ("version", "version", "version", 0, G_MAXUINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+/**
+ * gxdp_trash_get_version: (skip)
+ * @object: A #GXdpTrash.
+ *
+ * Gets the value of the <link linkend="gdbus-property-org-freedesktop-portal-Trash.version">"version"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+guint 
+gxdp_trash_get_version (GXdpTrash *object)
+{
+  return GXDP_TRASH_GET_IFACE (object)->get_version (object);
+}
+
+/**
+ * gxdp_trash_set_version: (skip)
+ * @object: A #GXdpTrash.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-org-freedesktop-portal-Trash.version">"version"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+gxdp_trash_set_version (GXdpTrash *object, guint value)
+{
+  g_object_set (G_OBJECT (object), "version", value, NULL);
+}
+
+/**
+ * gxdp_trash_call_trash_file:
+ * @proxy: A #GXdpTrashProxy.
+ * @arg_fd: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Trash.TrashFile">TrashFile()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_trash_call_trash_file_finish() to get the result of the operation.
+ *
+ * See gxdp_trash_call_trash_file_sync() for the synchronous, blocking version of this method.
+ */
+void
+gxdp_trash_call_trash_file (
+    GXdpTrash *proxy,
+    GVariant *arg_fd,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),
+    "TrashFile",
+    g_variant_new ("(@h)",
+                   arg_fd),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * gxdp_trash_call_trash_file_finish:
+ * @proxy: A #GXdpTrashProxy.
+ * @out_result: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out) (optional): Return location for a #GUnixFDList or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_trash_call_trash_file().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with gxdp_trash_call_trash_file().
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_trash_call_trash_file_finish (
+    GXdpTrash *proxy,
+    guint *out_result,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_result);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_trash_call_trash_file_sync:
+ * @proxy: A #GXdpTrashProxy.
+ * @arg_fd: Argument to pass with the method invocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @out_result: (out) (optional): Return location for return parameter or %NULL to ignore.
+ * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-portal-Trash.TrashFile">TrashFile()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_trash_call_trash_file() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
+ */
+gboolean
+gxdp_trash_call_trash_file_sync (
+    GXdpTrash *proxy,
+    GVariant *arg_fd,
+    GUnixFDList  *fd_list,
+    guint *out_result,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),
+    "TrashFile",
+    g_variant_new ("(@h)",
+                   arg_fd),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    fd_list,
+    out_fd_list,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(u)",
+                 out_result);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * gxdp_trash_complete_trash_file:
+ * @object: A #GXdpTrash.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @fd_list: (nullable): A #GUnixFDList or %NULL.
+ * @result: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-portal-Trash.TrashFile">TrashFile()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+gxdp_trash_complete_trash_file (
+    GXdpTrash *object G_GNUC_UNUSED,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    guint result)
+{
+  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,
+    g_variant_new ("(u)",
+                   result),
+    fd_list);
+}
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GXdpTrashProxy:
+ *
+ * The #GXdpTrashProxy structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GXdpTrashProxyClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GXdpTrashProxy.
+ */
+
+struct _GXdpTrashProxyPrivate
+{
+  GData *qdata;
+};
+
+static void gxdp_trash_proxy_iface_init (GXdpTrashIface *iface);
+
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GXdpTrashProxy, gxdp_trash_proxy, G_TYPE_DBUS_PROXY,
+                         G_ADD_PRIVATE (GXdpTrashProxy)
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_TRASH, gxdp_trash_proxy_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GXdpTrashProxy, gxdp_trash_proxy, G_TYPE_DBUS_PROXY,
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_TRASH, gxdp_trash_proxy_iface_init))
+
+#endif
+static void
+gxdp_trash_proxy_finalize (GObject *object)
+{
+  GXdpTrashProxy *proxy = GXDP_TRASH_PROXY (object);
+  g_datalist_clear (&proxy->priv->qdata);
+  G_OBJECT_CLASS (gxdp_trash_proxy_parent_class)->finalize (object);
+}
+
+static void
+gxdp_trash_proxy_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_trash_property_info_pointers[prop_id - 1];
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
+  if (info->use_gvariant)
+    {
+      g_value_set_variant (value, variant);
+    }
+  else
+    {
+      if (variant != NULL)
+        g_dbus_gvariant_to_gvalue (variant, value);
+    }
+  if (variant != NULL)
+    g_variant_unref (variant);
+}
+
+static void
+gxdp_trash_proxy_set_property_cb (GDBusProxy *proxy,
+  GAsyncResult *res,
+  gpointer      user_data)
+{
+  const _ExtendedGDBusPropertyInfo *info = user_data;
+  GError *error;
+  GVariant *_ret;
+  error = NULL;
+  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
+  if (!_ret)
+    {
+      g_warning ("Error setting property '%s' on interface org.freedesktop.portal.Trash: %s (%s, %d)",
+                 info->parent_struct.name, 
+                 error->message, g_quark_to_string (error->domain), error->code);
+      g_error_free (error);
+    }
+  else
+    {
+      g_variant_unref (_ret);
+    }
+}
+
+static void
+gxdp_trash_proxy_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_trash_property_info_pointers[prop_id - 1];
+  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
+  g_dbus_proxy_call (G_DBUS_PROXY (object),
+    "org.freedesktop.DBus.Properties.Set",
+    g_variant_new ("(ssv)", "org.freedesktop.portal.Trash", info->parent_struct.name, variant),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    NULL, (GAsyncReadyCallback) gxdp_trash_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
+  g_variant_unref (variant);
+}
+
+static void
+gxdp_trash_proxy_g_signal (GDBusProxy *proxy,
+  const gchar *sender_name G_GNUC_UNUSED,
+  const gchar *signal_name,
+  GVariant *parameters)
+{
+  _ExtendedGDBusSignalInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  gsize n;
+  guint signal_id;
+  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_gxdp_trash_interface_info.parent_struct, signal_name);
+  if (info == NULL)
+    return;
+  num_params = g_variant_n_children (parameters);
+  paramv = g_new0 (GValue, num_params + 1);
+  g_value_init (&paramv[0], GXDP_TYPE_TRASH);
+  g_value_set_object (&paramv[0], proxy);
+  g_variant_iter_init (&iter, parameters);
+  n = 1;
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GXDP_TYPE_TRASH);
+  g_signal_emitv (paramv, signal_id, 0, NULL);
+  for (n = 0; n < num_params + 1; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static void
+gxdp_trash_proxy_g_properties_changed (GDBusProxy *_proxy,
+  GVariant *changed_properties,
+  const gchar *const *invalidated_properties)
+{
+  GXdpTrashProxy *proxy = GXDP_TRASH_PROXY (_proxy);
+  guint n;
+  const gchar *key;
+  GVariantIter *iter;
+  _ExtendedGDBusPropertyInfo *info;
+  g_variant_get (changed_properties, "a{sv}", &iter);
+  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_trash_interface_info.parent_struct, key);
+      g_datalist_remove_data (&proxy->priv->qdata, key);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+  g_variant_iter_free (iter);
+  for (n = 0; invalidated_properties[n] != NULL; n++)
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_trash_interface_info.parent_struct, invalidated_properties[n]);
+      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+}
+
+static guint 
+gxdp_trash_proxy_get_version (GXdpTrash *object)
+{
+  GXdpTrashProxy *proxy = GXDP_TRASH_PROXY (object);
+  GVariant *variant;
+  guint value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "version");
+  if (variant != NULL)
+    {
+      value = g_variant_get_uint32 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static void
+gxdp_trash_proxy_init (GXdpTrashProxy *proxy)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  proxy->priv = gxdp_trash_proxy_get_instance_private (proxy);
+#else
+  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GXDP_TYPE_TRASH_PROXY, GXdpTrashProxyPrivate);
+#endif
+
+  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), gxdp_trash_interface_info ());
+}
+
+static void
+gxdp_trash_proxy_class_init (GXdpTrashProxyClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusProxyClass *proxy_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize     = gxdp_trash_proxy_finalize;
+  gobject_class->get_property = gxdp_trash_proxy_get_property;
+  gobject_class->set_property = gxdp_trash_proxy_set_property;
+
+  proxy_class = G_DBUS_PROXY_CLASS (klass);
+  proxy_class->g_signal = gxdp_trash_proxy_g_signal;
+  proxy_class->g_properties_changed = gxdp_trash_proxy_g_properties_changed;
+
+  gxdp_trash_override_properties (gobject_class, 1);
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GXdpTrashProxyPrivate));
+#endif
+}
+
+static void
+gxdp_trash_proxy_iface_init (GXdpTrashIface *iface)
+{
+  iface->get_version = gxdp_trash_proxy_get_version;
+}
+
+/**
+ * gxdp_trash_proxy_new:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-Trash.top_of_page">org.freedesktop.portal.Trash</link>. See g_dbus_proxy_new() for more details.
+ *
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_trash_proxy_new_finish() to get the result of the operation.
+ *
+ * See gxdp_trash_proxy_new_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gxdp_trash_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GXDP_TYPE_TRASH_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.Trash", NULL);
+}
+
+/**
+ * gxdp_trash_proxy_new_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_trash_proxy_new().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gxdp_trash_proxy_new().
+ *
+ * Returns: (transfer full) (type GXdpTrashProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpTrash *
+gxdp_trash_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GXDP_TRASH (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gxdp_trash_proxy_new_sync:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-Trash.top_of_page">org.freedesktop.portal.Trash</link>. See g_dbus_proxy_new_sync() for more details.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_trash_proxy_new() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GXdpTrashProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpTrash *
+gxdp_trash_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GXDP_TYPE_TRASH_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.Trash", NULL);
+  if (ret != NULL)
+    return GXDP_TRASH (ret);
+  else
+    return NULL;
+}
+
+
+/**
+ * gxdp_trash_proxy_new_for_bus:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Like gxdp_trash_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
+ * You can then call gxdp_trash_proxy_new_for_bus_finish() to get the result of the operation.
+ *
+ * See gxdp_trash_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+gxdp_trash_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (GXDP_TYPE_TRASH_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.Trash", NULL);
+}
+
+/**
+ * gxdp_trash_proxy_new_for_bus_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to gxdp_trash_proxy_new_for_bus().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with gxdp_trash_proxy_new_for_bus().
+ *
+ * Returns: (transfer full) (type GXdpTrashProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpTrash *
+gxdp_trash_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return GXDP_TRASH (ret);
+  else
+    return NULL;
+}
+
+/**
+ * gxdp_trash_proxy_new_for_bus_sync:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Like gxdp_trash_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See gxdp_trash_proxy_new_for_bus() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type GXdpTrashProxy): The constructed proxy object or %NULL if @error is set.
+ */
+GXdpTrash *
+gxdp_trash_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (GXDP_TYPE_TRASH_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.portal.Trash", NULL);
+  if (ret != NULL)
+    return GXDP_TRASH (ret);
+  else
+    return NULL;
+}
+
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * GXdpTrashSkeleton:
+ *
+ * The #GXdpTrashSkeleton structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * GXdpTrashSkeletonClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #GXdpTrashSkeleton.
+ */
+
+struct _GXdpTrashSkeletonPrivate
+{
+  GValue *properties;
+  GList *changed_properties;
+  GSource *changed_properties_idle_source;
+  GMainContext *context;
+  GMutex lock;
+};
+
+static void
+_gxdp_trash_skeleton_handle_method_call (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name,
+  const gchar *method_name,
+  GVariant *parameters,
+  GDBusMethodInvocation *invocation,
+  gpointer user_data)
+{
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (user_data);
+  _ExtendedGDBusMethodInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  guint num_extra;
+  gsize n;
+  guint signal_id;
+  GValue return_value = G_VALUE_INIT;
+  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
+  g_assert (info != NULL);
+  num_params = g_variant_n_children (parameters);
+  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
+  n = 0;
+  g_value_init (&paramv[n], GXDP_TYPE_TRASH);
+  g_value_set_object (&paramv[n++], skeleton);
+  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
+  g_value_set_object (&paramv[n++], invocation);
+  if (info->pass_fdlist)
+    {
+#ifdef G_OS_UNIX
+      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
+      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
+#else
+      g_assert_not_reached ();
+#endif
+    }
+  g_variant_iter_init (&iter, parameters);
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, GXDP_TYPE_TRASH);
+  g_value_init (&return_value, G_TYPE_BOOLEAN);
+  g_signal_emitv (paramv, signal_id, 0, &return_value);
+  if (!g_value_get_boolean (&return_value))
+    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
+  g_value_unset (&return_value);
+  for (n = 0; n < num_params + num_extra; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static GVariant *
+_gxdp_trash_skeleton_handle_get_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GError **error,
+  gpointer user_data)
+{
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  GVariant *ret;
+  ret = NULL;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_trash_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      g_value_init (&value, pspec->value_type);
+      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
+      g_value_unset (&value);
+    }
+  return ret;
+}
+
+static gboolean
+_gxdp_trash_skeleton_handle_set_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GVariant *variant,
+  GError **error,
+  gpointer user_data)
+{
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  gboolean ret;
+  ret = FALSE;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_gxdp_trash_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      if (info->use_gvariant)
+        g_value_set_variant (&value, variant);
+      else
+        g_dbus_gvariant_to_gvalue (variant, &value);
+      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      g_value_unset (&value);
+      ret = TRUE;
+    }
+  return ret;
+}
+
+static const GDBusInterfaceVTable _gxdp_trash_skeleton_vtable =
+{
+  _gxdp_trash_skeleton_handle_method_call,
+  _gxdp_trash_skeleton_handle_get_property,
+  _gxdp_trash_skeleton_handle_set_property,
+  {NULL}
+};
+
+static GDBusInterfaceInfo *
+gxdp_trash_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return gxdp_trash_interface_info ();
+}
+
+static GDBusInterfaceVTable *
+gxdp_trash_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return (GDBusInterfaceVTable *) &_gxdp_trash_skeleton_vtable;
+}
+
+static GVariant *
+gxdp_trash_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
+{
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (_skeleton);
+
+  GVariantBuilder builder;
+  guint n;
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  if (_gxdp_trash_interface_info.parent_struct.properties == NULL)
+    goto out;
+  for (n = 0; _gxdp_trash_interface_info.parent_struct.properties[n] != NULL; n++)
+    {
+      GDBusPropertyInfo *info = _gxdp_trash_interface_info.parent_struct.properties[n];
+      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
+        {
+          GVariant *value;
+          value = _gxdp_trash_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.portal.Trash", info->name, NULL, skeleton);
+          if (value != NULL)
+            {
+              g_variant_take_ref (value);
+              g_variant_builder_add (&builder, "{sv}", info->name, value);
+              g_variant_unref (value);
+            }
+        }
+    }
+out:
+  return g_variant_builder_end (&builder);
+}
+
+static gboolean _gxdp_trash_emit_changed (gpointer user_data);
+
+static void
+gxdp_trash_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
+{
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (_skeleton);
+  gboolean emit_changed = FALSE;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    {
+      g_source_destroy (skeleton->priv->changed_properties_idle_source);
+      skeleton->priv->changed_properties_idle_source = NULL;
+      emit_changed = TRUE;
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+
+  if (emit_changed)
+    _gxdp_trash_emit_changed (skeleton);
+}
+
+static void gxdp_trash_skeleton_iface_init (GXdpTrashIface *iface);
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (GXdpTrashSkeleton, gxdp_trash_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_ADD_PRIVATE (GXdpTrashSkeleton)
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_TRASH, gxdp_trash_skeleton_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (GXdpTrashSkeleton, gxdp_trash_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (GXDP_TYPE_TRASH, gxdp_trash_skeleton_iface_init))
+
+#endif
+static void
+gxdp_trash_skeleton_finalize (GObject *object)
+{
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (object);
+  guint n;
+  for (n = 0; n < 1; n++)
+    g_value_unset (&skeleton->priv->properties[n]);
+  g_free (skeleton->priv->properties);
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    g_source_destroy (skeleton->priv->changed_properties_idle_source);
+  g_main_context_unref (skeleton->priv->context);
+  g_mutex_clear (&skeleton->priv->lock);
+  G_OBJECT_CLASS (gxdp_trash_skeleton_parent_class)->finalize (object);
+}
+
+static void
+gxdp_trash_skeleton_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static gboolean
+_gxdp_trash_emit_changed (gpointer user_data)
+{
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (user_data);
+  GList *l;
+  GVariantBuilder builder;
+  GVariantBuilder invalidated_builder;
+  guint num_changes;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
+  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
+    {
+      ChangedProperty *cp = l->data;
+      GVariant *variant;
+      const GValue *cur_value;
+
+      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
+      if (!_g_value_equal (cur_value, &cp->orig_value))
+        {
+          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
+          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
+          g_variant_unref (variant);
+          num_changes++;
+        }
+    }
+  if (num_changes > 0)
+    {
+      GList *connections, *ll;
+      GVariant *signal_variant;
+      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.freedesktop.portal.Trash",
+                                           &builder, &invalidated_builder));
+      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+      for (ll = connections; ll != NULL; ll = ll->next)
+        {
+          GDBusConnection *connection = ll->data;
+
+          g_dbus_connection_emit_signal (connection,
+                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
+                                         "org.freedesktop.DBus.Properties",
+                                         "PropertiesChanged",
+                                         signal_variant,
+                                         NULL);
+        }
+      g_variant_unref (signal_variant);
+      g_list_free_full (connections, g_object_unref);
+    }
+  else
+    {
+      g_variant_builder_clear (&builder);
+      g_variant_builder_clear (&invalidated_builder);
+    }
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  skeleton->priv->changed_properties = NULL;
+  skeleton->priv->changed_properties_idle_source = NULL;
+  g_mutex_unlock (&skeleton->priv->lock);
+  return FALSE;
+}
+
+static void
+_gxdp_trash_schedule_emit_changed (GXdpTrashSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
+{
+  ChangedProperty *cp;
+  GList *l;
+  cp = NULL;
+  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
+    {
+      ChangedProperty *i_cp = l->data;
+      if (i_cp->info == info)
+        {
+          cp = i_cp;
+          break;
+        }
+    }
+  if (cp == NULL)
+    {
+      cp = g_new0 (ChangedProperty, 1);
+      cp->prop_id = prop_id;
+      cp->info = info;
+      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
+      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
+      g_value_copy (orig_value, &cp->orig_value);
+    }
+}
+
+static void
+gxdp_trash_skeleton_notify (GObject      *object,
+  GParamSpec *pspec G_GNUC_UNUSED)
+{
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (object);
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties != NULL &&
+      skeleton->priv->changed_properties_idle_source == NULL)
+    {
+      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
+      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
+      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _gxdp_trash_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
+      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _gxdp_trash_emit_changed");
+      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
+      g_source_unref (skeleton->priv->changed_properties_idle_source);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static void
+gxdp_trash_skeleton_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 1);
+  info = (const _ExtendedGDBusPropertyInfo *) _gxdp_trash_property_info_pointers[prop_id - 1];
+  g_mutex_lock (&skeleton->priv->lock);
+  g_object_freeze_notify (object);
+  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
+    {
+      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
+          info->emits_changed_signal)
+        _gxdp_trash_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
+      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
+      g_object_notify_by_pspec (object, pspec);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+  g_object_thaw_notify (object);
+}
+
+static void
+gxdp_trash_skeleton_init (GXdpTrashSkeleton *skeleton)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  skeleton->priv = gxdp_trash_skeleton_get_instance_private (skeleton);
+#else
+  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GXDP_TYPE_TRASH_SKELETON, GXdpTrashSkeletonPrivate);
+#endif
+
+  g_mutex_init (&skeleton->priv->lock);
+  skeleton->priv->context = g_main_context_ref_thread_default ();
+  skeleton->priv->properties = g_new0 (GValue, 1);
+  g_value_init (&skeleton->priv->properties[0], G_TYPE_UINT);
+}
+
+static guint 
+gxdp_trash_skeleton_get_version (GXdpTrash *object)
+{
+  GXdpTrashSkeleton *skeleton = GXDP_TRASH_SKELETON (object);
+  guint value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_uint (&(skeleton->priv->properties[0]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static void
+gxdp_trash_skeleton_class_init (GXdpTrashSkeletonClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusInterfaceSkeletonClass *skeleton_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = gxdp_trash_skeleton_finalize;
+  gobject_class->get_property = gxdp_trash_skeleton_get_property;
+  gobject_class->set_property = gxdp_trash_skeleton_set_property;
+  gobject_class->notify       = gxdp_trash_skeleton_notify;
+
+
+  gxdp_trash_override_properties (gobject_class, 1);
+
+  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
+  skeleton_class->get_info = gxdp_trash_skeleton_dbus_interface_get_info;
+  skeleton_class->get_properties = gxdp_trash_skeleton_dbus_interface_get_properties;
+  skeleton_class->flush = gxdp_trash_skeleton_dbus_interface_flush;
+  skeleton_class->get_vtable = gxdp_trash_skeleton_dbus_interface_get_vtable;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (GXdpTrashSkeletonPrivate));
+#endif
+}
+
+static void
+gxdp_trash_skeleton_iface_init (GXdpTrashIface *iface)
+{
+  iface->get_version = gxdp_trash_skeleton_get_version;
+}
+
+/**
+ * gxdp_trash_skeleton_new:
+ *
+ * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-portal-Trash.top_of_page">org.freedesktop.portal.Trash</link>.
+ *
+ * Returns: (transfer full) (type GXdpTrashSkeleton): The skeleton object.
+ */
+GXdpTrash *
+gxdp_trash_skeleton_new (void)
+{
+  return GXDP_TRASH (g_object_new (GXDP_TYPE_TRASH_SKELETON, NULL));
+}
+
diff --git a/gio/xdp-dbus.h b/gio/xdp-dbus.h
new file mode 100644
index 0000000..6c06210
--- /dev/null
+++ b/gio/xdp-dbus.h
@@ -0,0 +1,1172 @@
+/*
+ * This file is generated by gdbus-codegen, do not modify it.
+ *
+ * The license of this code is the same as for the D-Bus interface description
+ * it was derived from. Note that it links to GLib, so must comply with the
+ * LGPL linking clauses.
+ */
+
+#ifndef __XDP_DBUS_H__
+#define __XDP_DBUS_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+
+/* ------------------------------------------------------------------------ */
+/* Declarations for org.freedesktop.portal.Documents */
+
+#define GXDP_TYPE_DOCUMENTS (gxdp_documents_get_type ())
+#define GXDP_DOCUMENTS(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_DOCUMENTS, GXdpDocuments))
+#define GXDP_IS_DOCUMENTS(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_DOCUMENTS))
+#define GXDP_DOCUMENTS_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GXDP_TYPE_DOCUMENTS, GXdpDocumentsIface))
+
+struct _GXdpDocuments;
+typedef struct _GXdpDocuments GXdpDocuments;
+typedef struct _GXdpDocumentsIface GXdpDocumentsIface;
+
+struct _GXdpDocumentsIface
+{
+  GTypeInterface parent_iface;
+
+
+  gboolean (*handle_add) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    GVariant *arg_o_path_fd,
+    gboolean arg_reuse_existing,
+    gboolean arg_persistent);
+
+  gboolean (*handle_add_full) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    GVariant *arg_o_path_fds,
+    guint arg_flags,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions);
+
+  gboolean (*handle_add_named) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    GVariant *arg_o_path_parent_fd,
+    const gchar *arg_filename,
+    gboolean arg_reuse_existing,
+    gboolean arg_persistent);
+
+  gboolean (*handle_add_named_full) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    GVariant *arg_o_path_fd,
+    const gchar *arg_filename,
+    guint arg_flags,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions);
+
+  gboolean (*handle_delete) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_doc_id);
+
+  gboolean (*handle_get_mount_point) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_grant_permissions) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_doc_id,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions);
+
+  gboolean (*handle_info) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_doc_id);
+
+  gboolean (*handle_list) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_app_id);
+
+  gboolean (*handle_lookup) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_filename);
+
+  gboolean (*handle_revoke_permissions) (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_doc_id,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions);
+
+  guint  (*get_version) (GXdpDocuments *object);
+
+};
+
+GType gxdp_documents_get_type (void) G_GNUC_CONST;
+
+GDBusInterfaceInfo *gxdp_documents_interface_info (void);
+guint gxdp_documents_override_properties (GObjectClass *klass, guint property_id_begin);
+
+
+/* D-Bus method call completion functions: */
+void gxdp_documents_complete_get_mount_point (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *path);
+
+void gxdp_documents_complete_add (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *doc_id);
+
+void gxdp_documents_complete_add_named (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *doc_id);
+
+void gxdp_documents_complete_add_full (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *const *doc_ids,
+    GVariant *extra_out);
+
+void gxdp_documents_complete_add_named_full (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *doc_id,
+    GVariant *extra_out);
+
+void gxdp_documents_complete_grant_permissions (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation);
+
+void gxdp_documents_complete_revoke_permissions (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation);
+
+void gxdp_documents_complete_delete (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation);
+
+void gxdp_documents_complete_lookup (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *doc_id);
+
+void gxdp_documents_complete_info (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *path,
+    GVariant *apps);
+
+void gxdp_documents_complete_list (
+    GXdpDocuments *object,
+    GDBusMethodInvocation *invocation,
+    GVariant *docs);
+
+
+
+/* D-Bus method calls: */
+void gxdp_documents_call_get_mount_point (
+    GXdpDocuments *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_get_mount_point_finish (
+    GXdpDocuments *proxy,
+    gchar **out_path,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_get_mount_point_sync (
+    GXdpDocuments *proxy,
+    gchar **out_path,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_documents_call_add (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fd,
+    gboolean arg_reuse_existing,
+    gboolean arg_persistent,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_add_finish (
+    GXdpDocuments *proxy,
+    gchar **out_doc_id,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_add_sync (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fd,
+    gboolean arg_reuse_existing,
+    gboolean arg_persistent,
+    GUnixFDList  *fd_list,
+    gchar **out_doc_id,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_documents_call_add_named (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_parent_fd,
+    const gchar *arg_filename,
+    gboolean arg_reuse_existing,
+    gboolean arg_persistent,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_add_named_finish (
+    GXdpDocuments *proxy,
+    gchar **out_doc_id,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_add_named_sync (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_parent_fd,
+    const gchar *arg_filename,
+    gboolean arg_reuse_existing,
+    gboolean arg_persistent,
+    GUnixFDList  *fd_list,
+    gchar **out_doc_id,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_documents_call_add_full (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fds,
+    guint arg_flags,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_add_full_finish (
+    GXdpDocuments *proxy,
+    gchar ***out_doc_ids,
+    GVariant **out_extra_out,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_add_full_sync (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fds,
+    guint arg_flags,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GUnixFDList  *fd_list,
+    gchar ***out_doc_ids,
+    GVariant **out_extra_out,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_documents_call_add_named_full (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fd,
+    const gchar *arg_filename,
+    guint arg_flags,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_add_named_full_finish (
+    GXdpDocuments *proxy,
+    gchar **out_doc_id,
+    GVariant **out_extra_out,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_add_named_full_sync (
+    GXdpDocuments *proxy,
+    GVariant *arg_o_path_fd,
+    const gchar *arg_filename,
+    guint arg_flags,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GUnixFDList  *fd_list,
+    gchar **out_doc_id,
+    GVariant **out_extra_out,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_documents_call_grant_permissions (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_grant_permissions_finish (
+    GXdpDocuments *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_grant_permissions_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_documents_call_revoke_permissions (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_revoke_permissions_finish (
+    GXdpDocuments *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_revoke_permissions_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    const gchar *arg_app_id,
+    const gchar *const *arg_permissions,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_documents_call_delete (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_delete_finish (
+    GXdpDocuments *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_delete_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_documents_call_lookup (
+    GXdpDocuments *proxy,
+    const gchar *arg_filename,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_lookup_finish (
+    GXdpDocuments *proxy,
+    gchar **out_doc_id,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_lookup_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_filename,
+    gchar **out_doc_id,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_documents_call_info (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_info_finish (
+    GXdpDocuments *proxy,
+    gchar **out_path,
+    GVariant **out_apps,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_info_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_doc_id,
+    gchar **out_path,
+    GVariant **out_apps,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_documents_call_list (
+    GXdpDocuments *proxy,
+    const gchar *arg_app_id,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_documents_call_list_finish (
+    GXdpDocuments *proxy,
+    GVariant **out_docs,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_documents_call_list_sync (
+    GXdpDocuments *proxy,
+    const gchar *arg_app_id,
+    GVariant **out_docs,
+    GCancellable *cancellable,
+    GError **error);
+
+
+
+/* D-Bus property accessors: */
+guint gxdp_documents_get_version (GXdpDocuments *object);
+void gxdp_documents_set_version (GXdpDocuments *object, guint value);
+
+
+/* ---- */
+
+#define GXDP_TYPE_DOCUMENTS_PROXY (gxdp_documents_proxy_get_type ())
+#define GXDP_DOCUMENTS_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_DOCUMENTS_PROXY, GXdpDocumentsProxy))
+#define GXDP_DOCUMENTS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_DOCUMENTS_PROXY, GXdpDocumentsProxyClass))
+#define GXDP_DOCUMENTS_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_DOCUMENTS_PROXY, GXdpDocumentsProxyClass))
+#define GXDP_IS_DOCUMENTS_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_DOCUMENTS_PROXY))
+#define GXDP_IS_DOCUMENTS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_DOCUMENTS_PROXY))
+
+typedef struct _GXdpDocumentsProxy GXdpDocumentsProxy;
+typedef struct _GXdpDocumentsProxyClass GXdpDocumentsProxyClass;
+typedef struct _GXdpDocumentsProxyPrivate GXdpDocumentsProxyPrivate;
+
+struct _GXdpDocumentsProxy
+{
+  /*< private >*/
+  GDBusProxy parent_instance;
+  GXdpDocumentsProxyPrivate *priv;
+};
+
+struct _GXdpDocumentsProxyClass
+{
+  GDBusProxyClass parent_class;
+};
+
+GType gxdp_documents_proxy_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GXdpDocumentsProxy, g_object_unref)
+#endif
+
+void gxdp_documents_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GXdpDocuments *gxdp_documents_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GXdpDocuments *gxdp_documents_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+void gxdp_documents_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GXdpDocuments *gxdp_documents_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GXdpDocuments *gxdp_documents_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+
+/* ---- */
+
+#define GXDP_TYPE_DOCUMENTS_SKELETON (gxdp_documents_skeleton_get_type ())
+#define GXDP_DOCUMENTS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_DOCUMENTS_SKELETON, GXdpDocumentsSkeleton))
+#define GXDP_DOCUMENTS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_DOCUMENTS_SKELETON, GXdpDocumentsSkeletonClass))
+#define GXDP_DOCUMENTS_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_DOCUMENTS_SKELETON, GXdpDocumentsSkeletonClass))
+#define GXDP_IS_DOCUMENTS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_DOCUMENTS_SKELETON))
+#define GXDP_IS_DOCUMENTS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_DOCUMENTS_SKELETON))
+
+typedef struct _GXdpDocumentsSkeleton GXdpDocumentsSkeleton;
+typedef struct _GXdpDocumentsSkeletonClass GXdpDocumentsSkeletonClass;
+typedef struct _GXdpDocumentsSkeletonPrivate GXdpDocumentsSkeletonPrivate;
+
+struct _GXdpDocumentsSkeleton
+{
+  /*< private >*/
+  GDBusInterfaceSkeleton parent_instance;
+  GXdpDocumentsSkeletonPrivate *priv;
+};
+
+struct _GXdpDocumentsSkeletonClass
+{
+  GDBusInterfaceSkeletonClass parent_class;
+};
+
+GType gxdp_documents_skeleton_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GXdpDocumentsSkeleton, g_object_unref)
+#endif
+
+GXdpDocuments *gxdp_documents_skeleton_new (void);
+
+
+/* ------------------------------------------------------------------------ */
+/* Declarations for org.freedesktop.portal.OpenURI */
+
+#define GXDP_TYPE_OPEN_URI (gxdp_open_uri_get_type ())
+#define GXDP_OPEN_URI(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_OPEN_URI, GXdpOpenURI))
+#define GXDP_IS_OPEN_URI(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_OPEN_URI))
+#define GXDP_OPEN_URI_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GXDP_TYPE_OPEN_URI, GXdpOpenURIIface))
+
+struct _GXdpOpenURI;
+typedef struct _GXdpOpenURI GXdpOpenURI;
+typedef struct _GXdpOpenURIIface GXdpOpenURIIface;
+
+struct _GXdpOpenURIIface
+{
+  GTypeInterface parent_iface;
+
+
+  gboolean (*handle_open_directory) (
+    GXdpOpenURI *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *arg_parent_window,
+    GVariant *arg_fd,
+    GVariant *arg_options);
+
+  gboolean (*handle_open_file) (
+    GXdpOpenURI *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *arg_parent_window,
+    GVariant *arg_fd,
+    GVariant *arg_options);
+
+  gboolean (*handle_open_uri) (
+    GXdpOpenURI *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_parent_window,
+    const gchar *arg_uri,
+    GVariant *arg_options);
+
+  guint  (*get_version) (GXdpOpenURI *object);
+
+};
+
+GType gxdp_open_uri_get_type (void) G_GNUC_CONST;
+
+GDBusInterfaceInfo *gxdp_open_uri_interface_info (void);
+guint gxdp_open_uri_override_properties (GObjectClass *klass, guint property_id_begin);
+
+
+/* D-Bus method call completion functions: */
+void gxdp_open_uri_complete_open_uri (
+    GXdpOpenURI *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *handle);
+
+void gxdp_open_uri_complete_open_file (
+    GXdpOpenURI *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *handle);
+
+void gxdp_open_uri_complete_open_directory (
+    GXdpOpenURI *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    const gchar *handle);
+
+
+
+/* D-Bus method calls: */
+void gxdp_open_uri_call_open_uri (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    const gchar *arg_uri,
+    GVariant *arg_options,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_open_uri_call_open_uri_finish (
+    GXdpOpenURI *proxy,
+    gchar **out_handle,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_open_uri_call_open_uri_sync (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    const gchar *arg_uri,
+    GVariant *arg_options,
+    gchar **out_handle,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_open_uri_call_open_file (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    GVariant *arg_fd,
+    GVariant *arg_options,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_open_uri_call_open_file_finish (
+    GXdpOpenURI *proxy,
+    gchar **out_handle,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_open_uri_call_open_file_sync (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    GVariant *arg_fd,
+    GVariant *arg_options,
+    GUnixFDList  *fd_list,
+    gchar **out_handle,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error);
+
+void gxdp_open_uri_call_open_directory (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    GVariant *arg_fd,
+    GVariant *arg_options,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_open_uri_call_open_directory_finish (
+    GXdpOpenURI *proxy,
+    gchar **out_handle,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_open_uri_call_open_directory_sync (
+    GXdpOpenURI *proxy,
+    const gchar *arg_parent_window,
+    GVariant *arg_fd,
+    GVariant *arg_options,
+    GUnixFDList  *fd_list,
+    gchar **out_handle,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error);
+
+
+
+/* D-Bus property accessors: */
+guint gxdp_open_uri_get_version (GXdpOpenURI *object);
+void gxdp_open_uri_set_version (GXdpOpenURI *object, guint value);
+
+
+/* ---- */
+
+#define GXDP_TYPE_OPEN_URI_PROXY (gxdp_open_uri_proxy_get_type ())
+#define GXDP_OPEN_URI_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_OPEN_URI_PROXY, GXdpOpenURIProxy))
+#define GXDP_OPEN_URI_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_OPEN_URI_PROXY, GXdpOpenURIProxyClass))
+#define GXDP_OPEN_URI_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_OPEN_URI_PROXY, GXdpOpenURIProxyClass))
+#define GXDP_IS_OPEN_URI_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_OPEN_URI_PROXY))
+#define GXDP_IS_OPEN_URI_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_OPEN_URI_PROXY))
+
+typedef struct _GXdpOpenURIProxy GXdpOpenURIProxy;
+typedef struct _GXdpOpenURIProxyClass GXdpOpenURIProxyClass;
+typedef struct _GXdpOpenURIProxyPrivate GXdpOpenURIProxyPrivate;
+
+struct _GXdpOpenURIProxy
+{
+  /*< private >*/
+  GDBusProxy parent_instance;
+  GXdpOpenURIProxyPrivate *priv;
+};
+
+struct _GXdpOpenURIProxyClass
+{
+  GDBusProxyClass parent_class;
+};
+
+GType gxdp_open_uri_proxy_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GXdpOpenURIProxy, g_object_unref)
+#endif
+
+void gxdp_open_uri_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GXdpOpenURI *gxdp_open_uri_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GXdpOpenURI *gxdp_open_uri_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+void gxdp_open_uri_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GXdpOpenURI *gxdp_open_uri_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GXdpOpenURI *gxdp_open_uri_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+
+/* ---- */
+
+#define GXDP_TYPE_OPEN_URI_SKELETON (gxdp_open_uri_skeleton_get_type ())
+#define GXDP_OPEN_URI_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_OPEN_URI_SKELETON, GXdpOpenURISkeleton))
+#define GXDP_OPEN_URI_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_OPEN_URI_SKELETON, GXdpOpenURISkeletonClass))
+#define GXDP_OPEN_URI_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_OPEN_URI_SKELETON, GXdpOpenURISkeletonClass))
+#define GXDP_IS_OPEN_URI_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_OPEN_URI_SKELETON))
+#define GXDP_IS_OPEN_URI_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_OPEN_URI_SKELETON))
+
+typedef struct _GXdpOpenURISkeleton GXdpOpenURISkeleton;
+typedef struct _GXdpOpenURISkeletonClass GXdpOpenURISkeletonClass;
+typedef struct _GXdpOpenURISkeletonPrivate GXdpOpenURISkeletonPrivate;
+
+struct _GXdpOpenURISkeleton
+{
+  /*< private >*/
+  GDBusInterfaceSkeleton parent_instance;
+  GXdpOpenURISkeletonPrivate *priv;
+};
+
+struct _GXdpOpenURISkeletonClass
+{
+  GDBusInterfaceSkeletonClass parent_class;
+};
+
+GType gxdp_open_uri_skeleton_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GXdpOpenURISkeleton, g_object_unref)
+#endif
+
+GXdpOpenURI *gxdp_open_uri_skeleton_new (void);
+
+
+/* ------------------------------------------------------------------------ */
+/* Declarations for org.freedesktop.portal.ProxyResolver */
+
+#define GXDP_TYPE_PROXY_RESOLVER (gxdp_proxy_resolver_get_type ())
+#define GXDP_PROXY_RESOLVER(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_PROXY_RESOLVER, GXdpProxyResolver))
+#define GXDP_IS_PROXY_RESOLVER(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_PROXY_RESOLVER))
+#define GXDP_PROXY_RESOLVER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GXDP_TYPE_PROXY_RESOLVER, GXdpProxyResolverIface))
+
+struct _GXdpProxyResolver;
+typedef struct _GXdpProxyResolver GXdpProxyResolver;
+typedef struct _GXdpProxyResolverIface GXdpProxyResolverIface;
+
+struct _GXdpProxyResolverIface
+{
+  GTypeInterface parent_iface;
+
+
+  gboolean (*handle_lookup) (
+    GXdpProxyResolver *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_uri);
+
+  guint  (*get_version) (GXdpProxyResolver *object);
+
+};
+
+GType gxdp_proxy_resolver_get_type (void) G_GNUC_CONST;
+
+GDBusInterfaceInfo *gxdp_proxy_resolver_interface_info (void);
+guint gxdp_proxy_resolver_override_properties (GObjectClass *klass, guint property_id_begin);
+
+
+/* D-Bus method call completion functions: */
+void gxdp_proxy_resolver_complete_lookup (
+    GXdpProxyResolver *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *const *proxies);
+
+
+
+/* D-Bus method calls: */
+void gxdp_proxy_resolver_call_lookup (
+    GXdpProxyResolver *proxy,
+    const gchar *arg_uri,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_proxy_resolver_call_lookup_finish (
+    GXdpProxyResolver *proxy,
+    gchar ***out_proxies,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_proxy_resolver_call_lookup_sync (
+    GXdpProxyResolver *proxy,
+    const gchar *arg_uri,
+    gchar ***out_proxies,
+    GCancellable *cancellable,
+    GError **error);
+
+
+
+/* D-Bus property accessors: */
+guint gxdp_proxy_resolver_get_version (GXdpProxyResolver *object);
+void gxdp_proxy_resolver_set_version (GXdpProxyResolver *object, guint value);
+
+
+/* ---- */
+
+#define GXDP_TYPE_PROXY_RESOLVER_PROXY (gxdp_proxy_resolver_proxy_get_type ())
+#define GXDP_PROXY_RESOLVER_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_PROXY_RESOLVER_PROXY, GXdpProxyResolverProxy))
+#define GXDP_PROXY_RESOLVER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_PROXY_RESOLVER_PROXY, GXdpProxyResolverProxyClass))
+#define GXDP_PROXY_RESOLVER_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_PROXY_RESOLVER_PROXY, GXdpProxyResolverProxyClass))
+#define GXDP_IS_PROXY_RESOLVER_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_PROXY_RESOLVER_PROXY))
+#define GXDP_IS_PROXY_RESOLVER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_PROXY_RESOLVER_PROXY))
+
+typedef struct _GXdpProxyResolverProxy GXdpProxyResolverProxy;
+typedef struct _GXdpProxyResolverProxyClass GXdpProxyResolverProxyClass;
+typedef struct _GXdpProxyResolverProxyPrivate GXdpProxyResolverProxyPrivate;
+
+struct _GXdpProxyResolverProxy
+{
+  /*< private >*/
+  GDBusProxy parent_instance;
+  GXdpProxyResolverProxyPrivate *priv;
+};
+
+struct _GXdpProxyResolverProxyClass
+{
+  GDBusProxyClass parent_class;
+};
+
+GType gxdp_proxy_resolver_proxy_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GXdpProxyResolverProxy, g_object_unref)
+#endif
+
+void gxdp_proxy_resolver_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GXdpProxyResolver *gxdp_proxy_resolver_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GXdpProxyResolver *gxdp_proxy_resolver_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+void gxdp_proxy_resolver_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GXdpProxyResolver *gxdp_proxy_resolver_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GXdpProxyResolver *gxdp_proxy_resolver_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+
+/* ---- */
+
+#define GXDP_TYPE_PROXY_RESOLVER_SKELETON (gxdp_proxy_resolver_skeleton_get_type ())
+#define GXDP_PROXY_RESOLVER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_PROXY_RESOLVER_SKELETON, GXdpProxyResolverSkeleton))
+#define GXDP_PROXY_RESOLVER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_PROXY_RESOLVER_SKELETON, GXdpProxyResolverSkeletonClass))
+#define GXDP_PROXY_RESOLVER_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_PROXY_RESOLVER_SKELETON, GXdpProxyResolverSkeletonClass))
+#define GXDP_IS_PROXY_RESOLVER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_PROXY_RESOLVER_SKELETON))
+#define GXDP_IS_PROXY_RESOLVER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_PROXY_RESOLVER_SKELETON))
+
+typedef struct _GXdpProxyResolverSkeleton GXdpProxyResolverSkeleton;
+typedef struct _GXdpProxyResolverSkeletonClass GXdpProxyResolverSkeletonClass;
+typedef struct _GXdpProxyResolverSkeletonPrivate GXdpProxyResolverSkeletonPrivate;
+
+struct _GXdpProxyResolverSkeleton
+{
+  /*< private >*/
+  GDBusInterfaceSkeleton parent_instance;
+  GXdpProxyResolverSkeletonPrivate *priv;
+};
+
+struct _GXdpProxyResolverSkeletonClass
+{
+  GDBusInterfaceSkeletonClass parent_class;
+};
+
+GType gxdp_proxy_resolver_skeleton_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GXdpProxyResolverSkeleton, g_object_unref)
+#endif
+
+GXdpProxyResolver *gxdp_proxy_resolver_skeleton_new (void);
+
+
+/* ------------------------------------------------------------------------ */
+/* Declarations for org.freedesktop.portal.Trash */
+
+#define GXDP_TYPE_TRASH (gxdp_trash_get_type ())
+#define GXDP_TRASH(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_TRASH, GXdpTrash))
+#define GXDP_IS_TRASH(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_TRASH))
+#define GXDP_TRASH_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GXDP_TYPE_TRASH, GXdpTrashIface))
+
+struct _GXdpTrash;
+typedef struct _GXdpTrash GXdpTrash;
+typedef struct _GXdpTrashIface GXdpTrashIface;
+
+struct _GXdpTrashIface
+{
+  GTypeInterface parent_iface;
+
+
+  gboolean (*handle_trash_file) (
+    GXdpTrash *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    GVariant *arg_fd);
+
+  guint  (*get_version) (GXdpTrash *object);
+
+};
+
+GType gxdp_trash_get_type (void) G_GNUC_CONST;
+
+GDBusInterfaceInfo *gxdp_trash_interface_info (void);
+guint gxdp_trash_override_properties (GObjectClass *klass, guint property_id_begin);
+
+
+/* D-Bus method call completion functions: */
+void gxdp_trash_complete_trash_file (
+    GXdpTrash *object,
+    GDBusMethodInvocation *invocation,
+    GUnixFDList *fd_list,
+    guint result);
+
+
+
+/* D-Bus method calls: */
+void gxdp_trash_call_trash_file (
+    GXdpTrash *proxy,
+    GVariant *arg_fd,
+    GUnixFDList *fd_list,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean gxdp_trash_call_trash_file_finish (
+    GXdpTrash *proxy,
+    guint *out_result,
+    GUnixFDList **out_fd_list,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean gxdp_trash_call_trash_file_sync (
+    GXdpTrash *proxy,
+    GVariant *arg_fd,
+    GUnixFDList  *fd_list,
+    guint *out_result,
+    GUnixFDList **out_fd_list,
+    GCancellable *cancellable,
+    GError **error);
+
+
+
+/* D-Bus property accessors: */
+guint gxdp_trash_get_version (GXdpTrash *object);
+void gxdp_trash_set_version (GXdpTrash *object, guint value);
+
+
+/* ---- */
+
+#define GXDP_TYPE_TRASH_PROXY (gxdp_trash_proxy_get_type ())
+#define GXDP_TRASH_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_TRASH_PROXY, GXdpTrashProxy))
+#define GXDP_TRASH_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_TRASH_PROXY, GXdpTrashProxyClass))
+#define GXDP_TRASH_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_TRASH_PROXY, GXdpTrashProxyClass))
+#define GXDP_IS_TRASH_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_TRASH_PROXY))
+#define GXDP_IS_TRASH_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_TRASH_PROXY))
+
+typedef struct _GXdpTrashProxy GXdpTrashProxy;
+typedef struct _GXdpTrashProxyClass GXdpTrashProxyClass;
+typedef struct _GXdpTrashProxyPrivate GXdpTrashProxyPrivate;
+
+struct _GXdpTrashProxy
+{
+  /*< private >*/
+  GDBusProxy parent_instance;
+  GXdpTrashProxyPrivate *priv;
+};
+
+struct _GXdpTrashProxyClass
+{
+  GDBusProxyClass parent_class;
+};
+
+GType gxdp_trash_proxy_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GXdpTrashProxy, g_object_unref)
+#endif
+
+void gxdp_trash_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GXdpTrash *gxdp_trash_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GXdpTrash *gxdp_trash_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+void gxdp_trash_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+GXdpTrash *gxdp_trash_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error);
+GXdpTrash *gxdp_trash_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+
+/* ---- */
+
+#define GXDP_TYPE_TRASH_SKELETON (gxdp_trash_skeleton_get_type ())
+#define GXDP_TRASH_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GXDP_TYPE_TRASH_SKELETON, GXdpTrashSkeleton))
+#define GXDP_TRASH_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GXDP_TYPE_TRASH_SKELETON, GXdpTrashSkeletonClass))
+#define GXDP_TRASH_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GXDP_TYPE_TRASH_SKELETON, GXdpTrashSkeletonClass))
+#define GXDP_IS_TRASH_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GXDP_TYPE_TRASH_SKELETON))
+#define GXDP_IS_TRASH_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GXDP_TYPE_TRASH_SKELETON))
+
+typedef struct _GXdpTrashSkeleton GXdpTrashSkeleton;
+typedef struct _GXdpTrashSkeletonClass GXdpTrashSkeletonClass;
+typedef struct _GXdpTrashSkeletonPrivate GXdpTrashSkeletonPrivate;
+
+struct _GXdpTrashSkeleton
+{
+  /*< private >*/
+  GDBusInterfaceSkeleton parent_instance;
+  GXdpTrashSkeletonPrivate *priv;
+};
+
+struct _GXdpTrashSkeletonClass
+{
+  GDBusInterfaceSkeletonClass parent_class;
+};
+
+GType gxdp_trash_skeleton_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (GXdpTrashSkeleton, g_object_unref)
+#endif
+
+GXdpTrash *gxdp_trash_skeleton_new (void);
+
+
+G_END_DECLS
+
+#endif /* __XDP_DBUS_H__ */
diff --git a/glib/gatomic.h b/glib/gatomic.h
index 8b2b880..7bb4443 100644
--- a/glib/gatomic.h
+++ b/glib/gatomic.h
@@ -86,7 +86,13 @@ G_END_DECLS
 #if defined(G_ATOMIC_LOCK_FREE) && defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4)
 
 /* We prefer the new C11-style atomic extension of GCC if available */
-#if defined(__ATOMIC_SEQ_CST)
+/* OHOS_GLIB_COMPATIBLE
+ * ohos.glib.compatible.001: glib 2.62.5 update 2.68.1 Incompatible with gstreamer 1.16.2
+ * static volatile gsize _init_once = 0; // Conflicts with volatile, 
+ *    if (g_once_init_enter (&_init_once))
+ *    add "&& !defined(__clang__)"
+ */
+#if defined(__ATOMIC_SEQ_CST) && !defined(__clang__)
 
 #define g_atomic_int_get(atomic) \
   (G_GNUC_EXTENSION ({                                                       \
diff --git a/glib/ggettext.c b/glib/ggettext.c
index 303b9b9..4d4cb25 100644
--- a/glib/ggettext.c
+++ b/glib/ggettext.c
@@ -40,7 +40,12 @@
 
 #include <string.h>
 #include <locale.h>
+#ifndef OHOS_OPT_COMPAT
+/* ohos.opt.compat.001:
+ * Remove dependency to gettext
+ */
 #include <libintl.h>
+#endif
 
 #ifdef G_OS_WIN32
 
diff --git a/glib/gi18n-lib.h b/glib/gi18n-lib.h
index 74e50a3..b6cc3d8 100644
--- a/glib/gi18n-lib.h
+++ b/glib/gi18n-lib.h
@@ -20,7 +20,12 @@
 
 #include <glib.h>
 
+#ifndef OHOS_OPT_COMPAT
+/* ohos.opt.compat.001:
+ * Remove dependency to gettext
+ */
 #include <libintl.h>
+#endif
 #include <string.h>
 
 #ifndef GETTEXT_PACKAGE
diff --git a/glib/gi18n.h b/glib/gi18n.h
index 5f996d2..a3e11c4 100644
--- a/glib/gi18n.h
+++ b/glib/gi18n.h
@@ -20,7 +20,12 @@
 
 #include <glib.h>
 
+#ifndef OHOS_OPT_COMPAT
+/* ohos.opt.compat.001:
+ * Remove dependency to gettext
+ */
 #include <libintl.h>
+#endif
 #include <string.h>
 
 #define  _(String) gettext (String)
diff --git a/glib/glibconfig.h b/glib/glibconfig.h
new file mode 100644
index 0000000..4189f00
--- /dev/null
+++ b/glib/glibconfig.h
@@ -0,0 +1,294 @@
+/* glibconfig.h
+ *
+ * This is a generated file.  Please modify 'glibconfig.h.in'
+ */
+
+#ifndef __GLIBCONFIG_H__
+#define __GLIBCONFIG_H__
+
+#include <glib/gmacros.h>
+
+#include <limits.h>
+#include <float.h>
+#define GLIB_HAVE_ALLOCA_H
+
+/* Specifies that GLib's g_print*() functions wrap the
+ * system printf functions.  This is useful to know, for example,
+ * when using glibc's register_printf_function().
+ */
+#undef GLIB_USING_SYSTEM_PRINTF
+
+/* #undef GLIB_STATIC_COMPILATION */
+/* #undef GOBJECT_STATIC_COMPILATION */
+/* #undef G_INTL_STATIC_COMPILATION */
+/* #undef FFI_STATIC_BUILD */
+
+G_BEGIN_DECLS
+
+#define G_MINFLOAT	FLT_MIN
+#define G_MAXFLOAT	FLT_MAX
+#define G_MINDOUBLE	DBL_MIN
+#define G_MAXDOUBLE	DBL_MAX
+#define G_MINSHORT	SHRT_MIN
+#define G_MAXSHORT	SHRT_MAX
+#define G_MAXUSHORT	USHRT_MAX
+#define G_MININT	INT_MIN
+#define G_MAXINT	INT_MAX
+#define G_MAXUINT	UINT_MAX
+#define G_MINLONG	LONG_MIN
+#define G_MAXLONG	LONG_MAX
+#define G_MAXULONG	ULONG_MAX
+
+typedef signed char gint8;
+typedef unsigned char guint8;
+
+typedef signed short gint16;
+typedef unsigned short guint16;
+
+#define G_GINT16_MODIFIER "h"
+#define G_GINT16_FORMAT "hi"
+#define G_GUINT16_FORMAT "hu"
+
+
+typedef signed int gint32;
+typedef unsigned int guint32;
+
+#define G_GINT32_MODIFIER ""
+#define G_GINT32_FORMAT "i"
+#define G_GUINT32_FORMAT "u"
+
+
+#define G_HAVE_GINT64 1          /* deprecated, always true */
+
+#ifdef __LP64__
+
+typedef signed long gint64;
+typedef unsigned long guint64;
+
+#define G_GINT64_CONSTANT(val)	(val##L)
+#define G_GUINT64_CONSTANT(val)	(val##UL)
+
+#define G_GINT64_MODIFIER "l"
+#define G_GINT64_FORMAT "li"
+#define G_GUINT64_FORMAT "lu"
+
+
+#define GLIB_SIZEOF_VOID_P 8
+#define GLIB_SIZEOF_LONG   8
+#define GLIB_SIZEOF_SIZE_T 8
+#define GLIB_SIZEOF_SSIZE_T 8
+
+typedef signed long gssize;
+typedef unsigned long gsize;
+#define G_GSIZE_MODIFIER "l"
+#define G_GSSIZE_MODIFIER "l"
+#define G_GSIZE_FORMAT "lu"
+#define G_GSSIZE_FORMAT "li"
+
+#define G_MAXSIZE	G_MAXULONG
+#define G_MINSSIZE	G_MINLONG
+#define G_MAXSSIZE	G_MAXLONG
+
+typedef gint64 goffset;
+#define G_MINOFFSET	G_MININT64
+#define G_MAXOFFSET	G_MAXINT64
+
+#define G_GOFFSET_MODIFIER      G_GINT64_MODIFIER
+#define G_GOFFSET_FORMAT        G_GINT64_FORMAT
+#define G_GOFFSET_CONSTANT(val) G_GINT64_CONSTANT(val)
+
+#define G_POLLFD_FORMAT "%d"
+
+#define GPOINTER_TO_INT(p)	((gint)  (glong) (p))
+#define GPOINTER_TO_UINT(p)	((guint) (gulong) (p))
+
+#define GINT_TO_POINTER(i)	((gpointer) (glong) (i))
+#define GUINT_TO_POINTER(u)	((gpointer) (gulong) (u))
+
+typedef signed long gintptr;
+typedef unsigned long guintptr;
+
+#define G_GINTPTR_MODIFIER      "l"
+#define G_GINTPTR_FORMAT        "li"
+#define G_GUINTPTR_FORMAT       "lu"
+
+#else
+
+G_GNUC_EXTENSION typedef signed long long gint64;
+G_GNUC_EXTENSION typedef unsigned long long guint64;
+
+#define G_GINT64_CONSTANT(val)	(G_GNUC_EXTENSION (val##LL))
+#define G_GUINT64_CONSTANT(val)	(G_GNUC_EXTENSION (val##ULL))
+
+#define G_GINT64_MODIFIER "ll"
+#define G_GINT64_FORMAT "lli"
+#define G_GUINT64_FORMAT "llu"
+
+
+#define GLIB_SIZEOF_VOID_P 4
+#define GLIB_SIZEOF_LONG   4
+#define GLIB_SIZEOF_SIZE_T 4
+#define GLIB_SIZEOF_SSIZE_T 4
+
+typedef signed int gssize;
+typedef unsigned int gsize;
+#define G_GSIZE_MODIFIER ""
+#define G_GSSIZE_MODIFIER ""
+#define G_GSIZE_FORMAT "u"
+#define G_GSSIZE_FORMAT "i"
+
+#define G_MAXSIZE	G_MAXUINT
+#define G_MINSSIZE	G_MININT
+#define G_MAXSSIZE	G_MAXINT
+
+typedef gint64 goffset;
+#define G_MINOFFSET	G_MININT64
+#define G_MAXOFFSET	G_MAXINT64
+
+#define G_GOFFSET_MODIFIER      G_GINT64_MODIFIER
+#define G_GOFFSET_FORMAT        G_GINT64_FORMAT
+#define G_GOFFSET_CONSTANT(val) G_GINT64_CONSTANT(val)
+
+#define G_POLLFD_FORMAT "%d"
+
+#define GPOINTER_TO_INT(p)	((gint)  (gint) (p))
+#define GPOINTER_TO_UINT(p)	((guint) (guint) (p))
+
+#define GINT_TO_POINTER(i)	((gpointer) (gint) (i))
+#define GUINT_TO_POINTER(u)	((gpointer) (guint) (u))
+
+typedef signed int gintptr;
+typedef unsigned int guintptr;
+
+#define G_GINTPTR_MODIFIER      ""
+#define G_GINTPTR_FORMAT        "i"
+#define G_GUINTPTR_FORMAT       "u"
+#endif
+
+
+#define GLIB_MAJOR_VERSION 2
+#define GLIB_MINOR_VERSION 72
+#define GLIB_MICRO_VERSION 2
+
+#define G_OS_UNIX
+
+#define G_VA_COPY va_copy
+#define G_VA_COPY_AS_ARRAY 1
+
+
+#ifndef __cplusplus
+# define G_HAVE_ISO_VARARGS 1
+#endif
+
+#ifdef __cplusplus
+# define G_HAVE_ISO_VARARGS 1
+#endif
+
+/* gcc-2.95.x supports both gnu style and ISO varargs, but if -ansi
+ * is passed ISO vararg support is turned off, and there is no work
+ * around to turn it on, so we unconditionally turn it off.
+ */
+#if __GNUC__ == 2 && __GNUC_MINOR__ == 95
+#  undef G_HAVE_ISO_VARARGS
+#endif
+
+#define G_HAVE_GROWING_STACK 0
+#define G_HAVE_GNUC_VISIBILITY 1
+
+#ifndef _MSC_VER
+# define G_HAVE_GNUC_VARARGS 1
+#endif
+
+#if defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590)
+#define G_GNUC_INTERNAL __attribute__((visibility("hidden")))
+#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
+#define G_GNUC_INTERNAL __hidden
+#elif defined (__GNUC__) && defined (G_HAVE_GNUC_VISIBILITY)
+#define G_GNUC_INTERNAL __attribute__((visibility("hidden")))
+#else
+#define G_GNUC_INTERNAL
+#endif
+
+#define G_THREADS_ENABLED
+#define G_THREADS_IMPL_POSIX
+
+#define G_ATOMIC_LOCK_FREE
+
+#define GINT16_TO_LE(val)	((gint16) (val))
+#define GUINT16_TO_LE(val)	((guint16) (val))
+#define GINT16_TO_BE(val)	((gint16) GUINT16_SWAP_LE_BE (val))
+#define GUINT16_TO_BE(val)	(GUINT16_SWAP_LE_BE (val))
+
+#define GINT32_TO_LE(val)	((gint32) (val))
+#define GUINT32_TO_LE(val)	((guint32) (val))
+#define GINT32_TO_BE(val)	((gint32) GUINT32_SWAP_LE_BE (val))
+#define GUINT32_TO_BE(val)	(GUINT32_SWAP_LE_BE (val))
+
+#define GINT64_TO_LE(val)	((gint64) (val))
+#define GUINT64_TO_LE(val)	((guint64) (val))
+#define GINT64_TO_BE(val)	((gint64) GUINT64_SWAP_LE_BE (val))
+#define GUINT64_TO_BE(val)	(GUINT64_SWAP_LE_BE (val))
+
+#ifdef __LP64__
+
+#define GLONG_TO_LE(val)	((glong) GINT64_TO_LE (val))
+#define GULONG_TO_LE(val)	((gulong) GUINT64_TO_LE (val))
+#define GLONG_TO_BE(val)	((glong) GINT64_TO_BE (val))
+#define GULONG_TO_BE(val)	((gulong) GUINT64_TO_BE (val))
+#define GINT_TO_LE(val)		((gint) GINT32_TO_LE (val))
+#define GUINT_TO_LE(val)	((guint) GUINT32_TO_LE (val))
+#define GINT_TO_BE(val)		((gint) GINT32_TO_BE (val))
+#define GUINT_TO_BE(val)	((guint) GUINT32_TO_BE (val))
+#define GSIZE_TO_LE(val)	((gsize) GUINT64_TO_LE (val))
+#define GSSIZE_TO_LE(val)	((gssize) GINT64_TO_LE (val))
+#define GSIZE_TO_BE(val)	((gsize) GUINT64_TO_BE (val))
+#define GSSIZE_TO_BE(val)	((gssize) GINT64_TO_BE (val))
+#define G_BYTE_ORDER G_LITTLE_ENDIAN
+
+#else
+
+#define GLONG_TO_LE(val)	((glong) GINT32_TO_LE (val))
+#define GULONG_TO_LE(val)	((gulong) GUINT32_TO_LE (val))
+#define GLONG_TO_BE(val)	((glong) GINT32_TO_BE (val))
+#define GULONG_TO_BE(val)	((gulong) GUINT32_TO_BE (val))
+#define GINT_TO_LE(val)		((gint) GINT32_TO_LE (val))
+#define GUINT_TO_LE(val)	((guint) GUINT32_TO_LE (val))
+#define GINT_TO_BE(val)		((gint) GINT32_TO_BE (val))
+#define GUINT_TO_BE(val)	((guint) GUINT32_TO_BE (val))
+#define GSIZE_TO_LE(val)	((gsize) GUINT32_TO_LE (val))
+#define GSSIZE_TO_LE(val)	((gssize) GINT32_TO_LE (val))
+#define GSIZE_TO_BE(val)	((gsize) GUINT32_TO_BE (val))
+#define GSSIZE_TO_BE(val)	((gssize) GINT32_TO_BE (val))
+#define G_BYTE_ORDER G_LITTLE_ENDIAN
+
+#endif
+
+
+#define GLIB_SYSDEF_POLLIN =1
+#define GLIB_SYSDEF_POLLOUT =4
+#define GLIB_SYSDEF_POLLPRI =2
+#define GLIB_SYSDEF_POLLHUP =16
+#define GLIB_SYSDEF_POLLERR =8
+#define GLIB_SYSDEF_POLLNVAL =32
+
+#define G_MODULE_SUFFIX "so"
+
+typedef int GPid;
+#define G_PID_FORMAT "i"
+
+#define GLIB_SYSDEF_AF_UNIX 1
+#define GLIB_SYSDEF_AF_INET 2
+#define GLIB_SYSDEF_AF_INET6 10
+
+#define GLIB_SYSDEF_MSG_OOB 1
+#define GLIB_SYSDEF_MSG_PEEK 2
+#define GLIB_SYSDEF_MSG_DONTROUTE 4
+
+#define G_DIR_SEPARATOR '/'
+#define G_DIR_SEPARATOR_S "/"
+#define G_SEARCHPATH_SEPARATOR ':'
+#define G_SEARCHPATH_SEPARATOR_S ":"
+
+G_END_DECLS
+
+#endif /* __GLIBCONFIG_H__ */
diff --git a/glib/gscanner.c b/glib/gscanner.c
index 5f34218..39a9269 100644
--- a/glib/gscanner.c
+++ b/glib/gscanner.c
@@ -1678,7 +1678,7 @@ g_scanner_get_token_i (GScanner	*scanner,
       
     case G_TOKEN_SYMBOL:
       if (scanner->config->symbol_2_token)
-        *token_p = (GTokenType) ((size_t) value_p->v_symbol);
+	*token_p = (GTokenType)(intptr_t)value_p->v_symbol;
       break;
       
     case G_TOKEN_BINARY:
diff --git a/glib/gslice.c b/glib/gslice.c
index 4e99920..c58591e 100644
--- a/glib/gslice.c
+++ b/glib/gslice.c
@@ -51,6 +51,18 @@
 
 #include "gvalgrind.h"
 
+#include "gmemdfx.h"
+
+#if defined(G_MEM_DFX)
+
+#define DFX_TRACE(probe) probe
+
+#else
+
+#define DFX_TRACE(probe)
+
+#endif
+
 /**
  * SECTION:memory_slices
  * @title: Memory Slices
@@ -675,6 +687,66 @@ magazine_chain_prepare_fields (ChunkLink *magazine_chunks)
 #define magazine_chain_next(mc)         ((mc)->next->next->data)
 #define magazine_chain_count(mc)        ((mc)->next->next->next->data)
 
+
+#ifdef OHOS_OPT_PERFORMANCE
+/*
+ * ohos.opt.performance.0004
+ * fix glib cache too large problem. when thread exit, release mem no user.
+ */
+
+static void
+magazine_cache_trim (Allocator *local_allocator,
+                     guint ix,
+                     guint stamp,
+                     gboolean release)
+{
+  /* g_mutex_lock (local_allocator->mutex); done by caller */
+  /* trim magazine cache from tail */
+  ChunkLink *current = magazine_chain_prev (local_allocator->magazines[ix]);
+  ChunkLink *trash = NULL;
+  while (!G_APPROX_VALUE (stamp, magazine_chain_uint_stamp (current),
+                          local_allocator->config.working_set_msecs) || release)
+    {
+      /* unlink */
+      ChunkLink *prev = magazine_chain_prev (current);
+      ChunkLink *next = magazine_chain_next (current);
+      magazine_chain_next (prev) = next;
+      magazine_chain_prev (next) = prev;
+      /* clear special fields, put on trash stack */
+      magazine_chain_next (current) = NULL;
+      magazine_chain_count (current) = NULL;
+      magazine_chain_stamp (current) = NULL;
+      magazine_chain_prev (current) = trash;
+      trash = current;
+      /* fixup list head if required */
+      if (current == local_allocator->magazines[ix])
+        {
+          local_allocator->magazines[ix] = NULL;
+          break;
+        }
+      current = prev;
+    }
+  g_mutex_unlock (&local_allocator->magazine_mutex);
+  /* free trash */
+  if (trash)
+    {
+      const gsize chunk_size = SLAB_CHUNK_SIZE (local_allocator, ix);
+      g_mutex_lock (&local_allocator->slab_mutex);
+      while (trash)
+        {
+          current = trash;
+          trash = magazine_chain_prev (current);
+          magazine_chain_prev (current) = NULL; /* clear special field */
+          while (current)
+            {
+              ChunkLink *chunk = magazine_chain_pop_head (&current);
+              slab_allocator_free_chunk (chunk_size, chunk);
+            }
+        }
+      g_mutex_unlock (&local_allocator->slab_mutex);
+    }
+}
+#else
 static void
 magazine_cache_trim (Allocator *local_allocator,
                      guint ix,
@@ -726,7 +798,42 @@ magazine_cache_trim (Allocator *local_allocator,
       g_mutex_unlock (&local_allocator->slab_mutex);
     }
 }
+#endif
 
+#ifdef OHOS_OPT_PERFORMANCE
+/*
+ * ohos.opt.performance.0004
+ * fix glib cache too large problem. when thread exit, release mem no user.
+ */
+static void
+magazine_cache_push_magazine (guint      ix,
+                              ChunkLink *magazine_chunks,
+                              gsize      count, /* must be >= MIN_MAGAZINE_SIZE */
+                              gboolean release) 
+{
+  ChunkLink *current = magazine_chain_prepare_fields (magazine_chunks);
+  ChunkLink *next, *prev;
+  g_mutex_lock (&allocator->magazine_mutex);
+  /* add magazine at head */
+  next = allocator->magazines[ix];
+  if (next)
+    prev = magazine_chain_prev (next);
+  else
+    next = prev = current;
+  magazine_chain_next (prev) = current;
+  magazine_chain_prev (next) = current;
+  magazine_chain_prev (current) = prev;
+  magazine_chain_next (current) = next;
+  magazine_chain_count (current) = (gpointer) count;
+  /* stamp magazine */
+  magazine_cache_update_stamp();
+  magazine_chain_stamp (current) = GUINT_TO_POINTER (allocator->last_stamp);
+  allocator->magazines[ix] = current;
+  /* free old magazines beyond a certain threshold */
+  magazine_cache_trim (allocator, ix, allocator->last_stamp, release);
+  /* g_mutex_unlock (allocator->mutex); was done by magazine_cache_trim() */
+}
+#else
 static void
 magazine_cache_push_magazine (guint      ix,
                               ChunkLink *magazine_chunks,
@@ -754,6 +861,7 @@ magazine_cache_push_magazine (guint      ix,
   magazine_cache_trim (allocator, ix, allocator->last_stamp);
   /* g_mutex_unlock (allocator->mutex); was done by magazine_cache_trim() */
 }
+#endif
 
 static ChunkLink*
 magazine_cache_pop_magazine (guint  ix,
@@ -818,7 +926,15 @@ private_thread_memory_cleanup (gpointer data)
         {
           Magazine *mag = mags[j];
           if (mag->count >= MIN_MAGAZINE_SIZE)
+#ifdef OHOS_OPT_PERFORMANCE
+/*
+ * ohos.opt.performance.0004
+ * fix glib cache too large problem. when thread exit, release mem no user.
+ */
+            magazine_cache_push_magazine (ix, mag->chunks, mag->count, TRUE);
+#else
             magazine_cache_push_magazine (ix, mag->chunks, mag->count);
+#endif
           else
             {
               const gsize chunk_size = SLAB_CHUNK_SIZE (allocator, ix);
@@ -850,7 +966,15 @@ thread_memory_magazine2_unload (ThreadMemory *tmem,
                                 guint         ix)
 {
   Magazine *mag = &tmem->magazine2[ix];
+#ifdef OHOS_OPT_PERFORMANCE
+/*
+ * ohos.opt.performance.0004
+ * fix glib cache too large problem. when thread exit, release mem no user.
+ */
+  magazine_cache_push_magazine (ix, mag->chunks, mag->count, FALSE);
+#else
   magazine_cache_push_magazine (ix, mag->chunks, mag->count);
+#endif
   mag->chunks = NULL;
   mag->count = 0;
 }
@@ -1074,7 +1198,7 @@ g_slice_alloc (gsize mem_size)
     smc_notify_alloc (mem, mem_size);
 
   TRACE (GLIB_SLICE_ALLOC((void*)mem, mem_size));
-
+  DFX_TRACE(GMemAllocDfx((void *)mem, (unsigned int)mem_size));
   return mem;
 }
 
@@ -1183,6 +1307,7 @@ g_slice_free1 (gsize    mem_size,
       g_free (mem_block);
     }
   TRACE (GLIB_SLICE_FREE((void*)mem_block, mem_size));
+  DFX_TRACE(GMemFreeDfx((void *)mem_block));
 }
 
 /**
@@ -1210,6 +1335,7 @@ g_slice_free_chain_with_offset (gsize    mem_size,
                                 gpointer mem_chain,
                                 gsize    next_offset)
 {
+  DFX_TRACE(GChainMemFreeDfx((void *)mem_chain, next_offset));
   gpointer slice = mem_chain;
   /* while the thread magazines and the magazine cache are implemented so that
    * they can easily be extended to allow for free lists containing more free
@@ -1457,6 +1583,7 @@ allocator_memalign (gsize alignment,
   gint err = ENOMEM;
 #if     HAVE_POSIX_MEMALIGN
   err = posix_memalign (&aligned_memory, alignment, memsize);
+  DFX_TRACE(GMemPoolAllocDfx(aligned_memory, alignment, memsize));
 #elif   HAVE_MEMALIGN
   errno = 0;
   aligned_memory = memalign (alignment, memsize);
@@ -1500,6 +1627,7 @@ allocator_memfree (gsize    memsize,
                    gpointer mem)
 {
 #if     HAVE_POSIX_MEMALIGN || HAVE_MEMALIGN || HAVE_VALLOC
+  DFX_TRACE(GMemPoolFreeDfx(mem));
   free (mem);
 #else
   mem_assert (memsize <= sys_page_size);
diff --git a/glib/gstrfuncs.h b/glib/gstrfuncs.h
index 2b44c9a..520faa1 100644
--- a/glib/gstrfuncs.h
+++ b/glib/gstrfuncs.h
@@ -253,7 +253,15 @@ GLIB_AVAILABLE_IN_ALL
 gchar*                g_strescape      (const gchar *source,
 					const gchar *exceptions) G_GNUC_MALLOC;
 
+
+/* ohos.glib.compatible.001: glib 2.62.5 update 2.68.1 Incompatible with gstreamer/libsoup
+ * GLIB Not allowed g_memdup but gstreamer/libsoup need to use g_memdup
+ */
+#ifdef OHOS_GLIB_COMPATIBLE
+GLIB_AVAILABLE_IN_ALL
+#else
 GLIB_DEPRECATED_IN_2_68_FOR (g_memdup2)
+#endif
 gpointer              g_memdup         (gconstpointer mem,
                                         guint         byte_size) G_GNUC_ALLOC_SIZE(2);
 
diff --git a/glib/gthread-posix.c b/glib/gthread-posix.c
index 8e2e66d..9286fc7 100644
--- a/glib/gthread-posix.c
+++ b/glib/gthread-posix.c
@@ -72,8 +72,14 @@
 #include <sys/syscall.h>
 #endif
 
+/* OHOS_GLIB_COMPATIBLE
+ * ohos.glib.compatible.001: glib 2.62.5 update 2.68.1 Incompatible with gstreamer 1.16.2
+ * static volatile gsize _init_once = 0; // Conflicts with volatile, 
+ *    if (g_once_init_enter (&_init_once))
+ *    add "&& !defined(__clang__)"
+ */
 #if defined(HAVE_FUTEX) && \
-    (defined(HAVE_STDATOMIC_H) || defined(__ATOMIC_SEQ_CST))
+    (defined(HAVE_STDATOMIC_H) || defined(__ATOMIC_SEQ_CST)) && !defined(__clang__)
 #define USE_NATIVE_MUTEX
 #endif
 
diff --git a/glibmemdfx/gmemdfx.cpp b/glibmemdfx/gmemdfx.cpp
new file mode 100644
index 0000000..7c36613
--- /dev/null
+++ b/glibmemdfx/gmemdfx.cpp
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "gmemdfx.h"
+#include <unordered_map>
+#include <vector>
+#include <hilog/log.h>
+#include <unistd.h>
+#include "gmemdfxdump.h"
+#include "dfx_dump_catcher.h"
+#include "param_wrapper.h"
+#include "string_ex.h"
+
+#undef LOG_DOMAIN
+#define LOG_DOMAIN 0xD002B00
+
+#define __LOG(func, fmt, args...)                                                       \
+    do {                                                                                      \
+        (void)func(LABEL, "{%{public}s():%{public}d} " fmt, __FUNCTION__, __LINE__, ##args);  \
+    } while (0)
+
+#define LOGE(fmt, ...) __LOG(::OHOS::HiviewDFX::HiLog::Error, fmt, ##__VA_ARGS__)
+
+#define POINTER_MASK 0x00FFFFFF
+#define FAKE_POINTER(addr) (POINTER_MASK & reinterpret_cast<uintptr_t>(addr))
+
+struct MemInfo {
+    uint64_t count = 0;
+    uint64_t size = 0;
+    std::string str;
+    intptr_t mem;
+};
+
+struct PoolInfo {
+    uint64_t count = 0;
+    uint64_t size = 0;
+    uint64_t alignment = 0;
+    uint64_t lastTid = 0;
+    intptr_t mem;
+};
+
+namespace {
+    constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "AVGlibMemDfx"};
+    static std::unordered_map<void *, MemInfo> memMap;
+    static std::unordered_map<void *, PoolInfo> poolMap;
+    static uint64_t memCount = 0;
+    static uint64_t poolCount = 0;
+    static std::mutex mutex;
+    static bool enableDump = false;
+    static unsigned int dumpSize = 0;
+    static unsigned int dumpStart = 0;
+    static unsigned int dumpCount = 0;
+    static bool dumpOpen = false;
+}
+
+void GMemPoolAllocDfx(void *mem, unsigned int alignment, unsigned int size)
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    if (!dumpOpen || mem == nullptr) {
+        return;
+    }
+    if (poolMap.find(mem) != poolMap.end()) {
+        LOGE("the mem 0x%{public}06" PRIXPTR " is already allocated", FAKE_POINTER(mem));
+        return;
+    }
+
+    poolMap[mem] = {poolCount++, size, alignment, gettid(), (intptr_t)mem};
+}
+
+void GMemPoolFreeDfx(void *mem)
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    if (!dumpOpen || mem == nullptr) {
+        return;
+    }
+    if (mem != nullptr && poolMap.erase(mem) == 0) {
+        LOGE("the mem 0x%{public}06" PRIXPTR " is already free", FAKE_POINTER(mem));
+    }
+}
+
+void GMemAllocDfx(void *mem, unsigned int size)
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    if (!dumpOpen || mem == nullptr) {
+        return;
+    }
+    if (memMap.find(mem) != memMap.end()) {
+        LOGE("the mem 0x%{public}06" PRIXPTR " is already allocated", FAKE_POINTER(mem));
+        return;
+    }
+    std::string str;
+    if (enableDump && size == dumpSize && (memCount - dumpStart) % dumpCount == 0) {
+        OHOS::HiviewDFX::DfxDumpCatcher dumpLog;
+        bool ret = dumpLog.DumpCatch(getpid(), gettid(), str);
+        if (!ret) {
+            LOGE("dump error");
+        }
+    }
+
+    memMap[mem] = {memCount++, size, str, (intptr_t)mem};
+}
+
+void GChainMemFreeDfx(void *mem_chain, unsigned long next_offset)
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    if (!dumpOpen || mem_chain == nullptr) {
+        return;
+    }
+    void *next = mem_chain;
+    while (next) {
+        uint8_t *current = (uint8_t *)next;
+        next = *(void **)(current + next_offset);
+        if (current != nullptr && memMap.erase(current) == 0) {
+            LOGE("the mem 0x%{public}06" PRIXPTR " is already free", FAKE_POINTER(current));
+        }
+    }
+}
+
+void GMemFreeDfx(void *mem)
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    if (!dumpOpen || mem == nullptr) {
+        return;
+    }
+    if (mem != nullptr && memMap.erase(mem) == 0) {
+        LOGE("the mem 0x%{public}06" PRIXPTR " is already free", FAKE_POINTER(mem));
+    }
+}
+
+void InitParameter()
+{
+    std::string dumpSizeStr;
+    std::string dumpStartStr;
+    std::string dumpCountStr;
+    std::string dumpOpenStr;
+    int32_t size;
+    int32_t start;
+    int32_t count;
+    int32_t res = OHOS::system::GetStringParameter("sys.media.dump.mem.size", dumpSizeStr, "");
+    if (res == 0 && !dumpSizeStr.empty()) {
+        OHOS::StrToInt(dumpSizeStr, size);
+        dumpSize = size;
+        enableDump = dumpSize == 0 ? false :true;
+    } else {
+        enableDump = false;
+    }
+    res = OHOS::system::GetStringParameter("sys.media.dump.mem.start", dumpStartStr, "");
+    if (res == 0 && !dumpStartStr.empty()) {
+        OHOS::StrToInt(dumpStartStr, start);
+        dumpStart = start;
+    } else {
+        dumpStart = 0;
+    }
+    res = OHOS::system::GetStringParameter("sys.media.dump.mem.count", dumpCountStr, "");
+    if (res == 0 && !dumpCountStr.empty()) {
+        OHOS::StrToInt(dumpCountStr, count);
+        dumpCount = count;
+    } else {
+        dumpCount = 1;
+    }
+    res = OHOS::system::GetStringParameter("sys.media.dump.mem.open", dumpOpenStr, "");
+    if (res == 0 && !dumpOpenStr.empty()) {
+        dumpOpen = dumpOpenStr == "TRUE" ? true : false;
+    } else {
+        dumpOpen = false;
+    }
+}
+
+void GetGMemDump(std::string &str)
+{
+    std::unordered_map<void *, MemInfo> memMapCopy;
+    {
+        std::lock_guard<std::mutex> lock(mutex);
+        InitParameter();
+        memMapCopy = memMap;
+    }
+    std::vector<std::pair<void *, MemInfo>> memInfoVec(memMapCopy.begin(), memMapCopy.end());
+    std::sort(memInfoVec.begin(), memInfoVec.end(), [&](auto &left, auto &right) {
+        return left.second.count < right.second.count;
+    });
+    for (auto iter = memInfoVec.begin(); iter != memInfoVec.end(); iter++) {
+        str += "count:";
+        str += std::to_string(iter->second.count) + ";";
+        str += "size:";
+        str += std::to_string(iter->second.size) + "\n";
+        str += iter->second.str + "\n";
+    }
+}
+
+void GetGMemPoolDump(std::string &str)
+{
+    std::unordered_map<void *, PoolInfo> poolMapCopy;
+    {
+        std::lock_guard<std::mutex> lock(mutex);
+        InitParameter();
+        poolMapCopy = poolMap;
+    }
+    std::vector<std::pair<void *, PoolInfo>> poolInfoVec(poolMapCopy.begin(), poolMapCopy.end());
+    std::sort(poolInfoVec.begin(), poolInfoVec.end(), [&](auto &left, auto &right) {
+        return left.second.count < right.second.count;
+    });
+    for (auto iter = poolInfoVec.begin(); iter != poolInfoVec.end(); iter++) {
+        str += "count:";
+        str += std::to_string(iter->second.count) + ";";
+        str += "size:";
+        str += std::to_string(iter->second.size) + "\n";
+        str += "alignment:";
+        str += std::to_string(iter->second.alignment) + "\n";
+        str += "lastTid:";
+        str += std::to_string(iter->second.lastTid) + "\n";
+    }
+}
\ No newline at end of file
diff --git a/glibmemdfx/gmemdfx.h b/glibmemdfx/gmemdfx.h
new file mode 100644
index 0000000..fd0e9df
--- /dev/null
+++ b/glibmemdfx/gmemdfx.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef G_MEM_DFX_H
+#define G_MEM_DFX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void __attribute__((visibility("default"))) GMemAllocDfx(void *mem, unsigned int size);
+void __attribute__((visibility("default"))) GChainMemFreeDfx(void *mem_chain, unsigned long next_offset);
+void __attribute__((visibility("default"))) GMemFreeDfx(void *mem);
+
+void __attribute__((visibility("default"))) GMemPoolAllocDfx(void *mem, unsigned int alignment, unsigned int size);
+void __attribute__((visibility("default"))) GMemPoolFreeDfx(void *mem);
+#ifdef __cplusplus
+}
+#endif
+#endif
\ No newline at end of file
diff --git a/glibmemdfx/gmemdfxdump.h b/glibmemdfx/gmemdfxdump.h
new file mode 100644
index 0000000..edf58e3
--- /dev/null
+++ b/glibmemdfx/gmemdfxdump.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef G_MEM_DFX_DUMP_H
+#define G_MEM_DFX_DUMP_H
+
+#include <memory>
+
+void __attribute__((visibility("default"))) GetGMemDump(std::string &str);
+void __attribute__((visibility("default"))) GetGMemPoolDump(std::string &str);
+
+#endif
\ No newline at end of file
diff --git a/gmodule/gmoduleconf.h b/gmodule/gmoduleconf.h
new file mode 100644
index 0000000..9908fd1
--- /dev/null
+++ b/gmodule/gmoduleconf.h
@@ -0,0 +1,48 @@
+/* GMODULE - GLIB wrapper code for dynamic module loading
+ * Copyright (C) 1998 Tim Janik
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __G_MODULE_CONF_H__
+#define __G_MODULE_CONF_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+#define	G_MODULE_IMPL_NONE	0
+#define	G_MODULE_IMPL_DL	1
+#define	G_MODULE_IMPL_WIN32	3
+#define	G_MODULE_IMPL_AR	7
+
+#define	G_MODULE_IMPL		G_MODULE_IMPL_DL
+#undef	G_MODULE_HAVE_DLERROR
+#if	(1)
+#define	G_MODULE_HAVE_DLERROR
+#endif
+#if	(0)
+#define	G_MODULE_NEED_USCORE
+#endif
+#if	(0)
+#define G_MODULE_BROKEN_RTLD_GLOBAL
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __G_MODULE_CONF_H__ */
diff --git a/gobject/gclosure.c b/gobject/gclosure.c
index 85002a2..701181c 100644
--- a/gobject/gclosure.c
+++ b/gobject/gclosure.c
@@ -1302,7 +1302,11 @@ restart:
       g_value_set_boolean (gvalue, (gboolean) *int_val);
       break;
     case G_TYPE_STRING:
+#ifdef __ILP32__
+      g_value_take_string (gvalue, (gchar*) *int_val);
+#else
       g_value_take_string (gvalue, *(gchar**)value);
+#endif
       break;
     case G_TYPE_CHAR:
       g_value_set_schar (gvalue, (gint8) *int_val);
diff --git a/gobject/glib-enumtypes.c b/gobject/glib-enumtypes.c
new file mode 100644
index 0000000..5d5eaf6
--- /dev/null
+++ b/gobject/glib-enumtypes.c
@@ -0,0 +1,328 @@
+
+/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */
+
+#include "config.h"
+#include "glib-enumtypes.h"
+#include <glib-object.h>
+
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+/* enumerations from "../gobject/../glib/gunicode.h" */
+GType
+g_unicode_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_UNICODE_CONTROL, "G_UNICODE_CONTROL", "control" },
+        { G_UNICODE_FORMAT, "G_UNICODE_FORMAT", "format" },
+        { G_UNICODE_UNASSIGNED, "G_UNICODE_UNASSIGNED", "unassigned" },
+        { G_UNICODE_PRIVATE_USE, "G_UNICODE_PRIVATE_USE", "private-use" },
+        { G_UNICODE_SURROGATE, "G_UNICODE_SURROGATE", "surrogate" },
+        { G_UNICODE_LOWERCASE_LETTER, "G_UNICODE_LOWERCASE_LETTER", "lowercase-letter" },
+        { G_UNICODE_MODIFIER_LETTER, "G_UNICODE_MODIFIER_LETTER", "modifier-letter" },
+        { G_UNICODE_OTHER_LETTER, "G_UNICODE_OTHER_LETTER", "other-letter" },
+        { G_UNICODE_TITLECASE_LETTER, "G_UNICODE_TITLECASE_LETTER", "titlecase-letter" },
+        { G_UNICODE_UPPERCASE_LETTER, "G_UNICODE_UPPERCASE_LETTER", "uppercase-letter" },
+        { G_UNICODE_SPACING_MARK, "G_UNICODE_SPACING_MARK", "spacing-mark" },
+        { G_UNICODE_ENCLOSING_MARK, "G_UNICODE_ENCLOSING_MARK", "enclosing-mark" },
+        { G_UNICODE_NON_SPACING_MARK, "G_UNICODE_NON_SPACING_MARK", "non-spacing-mark" },
+        { G_UNICODE_DECIMAL_NUMBER, "G_UNICODE_DECIMAL_NUMBER", "decimal-number" },
+        { G_UNICODE_LETTER_NUMBER, "G_UNICODE_LETTER_NUMBER", "letter-number" },
+        { G_UNICODE_OTHER_NUMBER, "G_UNICODE_OTHER_NUMBER", "other-number" },
+        { G_UNICODE_CONNECT_PUNCTUATION, "G_UNICODE_CONNECT_PUNCTUATION", "connect-punctuation" },
+        { G_UNICODE_DASH_PUNCTUATION, "G_UNICODE_DASH_PUNCTUATION", "dash-punctuation" },
+        { G_UNICODE_CLOSE_PUNCTUATION, "G_UNICODE_CLOSE_PUNCTUATION", "close-punctuation" },
+        { G_UNICODE_FINAL_PUNCTUATION, "G_UNICODE_FINAL_PUNCTUATION", "final-punctuation" },
+        { G_UNICODE_INITIAL_PUNCTUATION, "G_UNICODE_INITIAL_PUNCTUATION", "initial-punctuation" },
+        { G_UNICODE_OTHER_PUNCTUATION, "G_UNICODE_OTHER_PUNCTUATION", "other-punctuation" },
+        { G_UNICODE_OPEN_PUNCTUATION, "G_UNICODE_OPEN_PUNCTUATION", "open-punctuation" },
+        { G_UNICODE_CURRENCY_SYMBOL, "G_UNICODE_CURRENCY_SYMBOL", "currency-symbol" },
+        { G_UNICODE_MODIFIER_SYMBOL, "G_UNICODE_MODIFIER_SYMBOL", "modifier-symbol" },
+        { G_UNICODE_MATH_SYMBOL, "G_UNICODE_MATH_SYMBOL", "math-symbol" },
+        { G_UNICODE_OTHER_SYMBOL, "G_UNICODE_OTHER_SYMBOL", "other-symbol" },
+        { G_UNICODE_LINE_SEPARATOR, "G_UNICODE_LINE_SEPARATOR", "line-separator" },
+        { G_UNICODE_PARAGRAPH_SEPARATOR, "G_UNICODE_PARAGRAPH_SEPARATOR", "paragraph-separator" },
+        { G_UNICODE_SPACE_SEPARATOR, "G_UNICODE_SPACE_SEPARATOR", "space-separator" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GUnicodeType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_unicode_break_type_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_UNICODE_BREAK_MANDATORY, "G_UNICODE_BREAK_MANDATORY", "mandatory" },
+        { G_UNICODE_BREAK_CARRIAGE_RETURN, "G_UNICODE_BREAK_CARRIAGE_RETURN", "carriage-return" },
+        { G_UNICODE_BREAK_LINE_FEED, "G_UNICODE_BREAK_LINE_FEED", "line-feed" },
+        { G_UNICODE_BREAK_COMBINING_MARK, "G_UNICODE_BREAK_COMBINING_MARK", "combining-mark" },
+        { G_UNICODE_BREAK_SURROGATE, "G_UNICODE_BREAK_SURROGATE", "surrogate" },
+        { G_UNICODE_BREAK_ZERO_WIDTH_SPACE, "G_UNICODE_BREAK_ZERO_WIDTH_SPACE", "zero-width-space" },
+        { G_UNICODE_BREAK_INSEPARABLE, "G_UNICODE_BREAK_INSEPARABLE", "inseparable" },
+        { G_UNICODE_BREAK_NON_BREAKING_GLUE, "G_UNICODE_BREAK_NON_BREAKING_GLUE", "non-breaking-glue" },
+        { G_UNICODE_BREAK_CONTINGENT, "G_UNICODE_BREAK_CONTINGENT", "contingent" },
+        { G_UNICODE_BREAK_SPACE, "G_UNICODE_BREAK_SPACE", "space" },
+        { G_UNICODE_BREAK_AFTER, "G_UNICODE_BREAK_AFTER", "after" },
+        { G_UNICODE_BREAK_BEFORE, "G_UNICODE_BREAK_BEFORE", "before" },
+        { G_UNICODE_BREAK_BEFORE_AND_AFTER, "G_UNICODE_BREAK_BEFORE_AND_AFTER", "before-and-after" },
+        { G_UNICODE_BREAK_HYPHEN, "G_UNICODE_BREAK_HYPHEN", "hyphen" },
+        { G_UNICODE_BREAK_NON_STARTER, "G_UNICODE_BREAK_NON_STARTER", "non-starter" },
+        { G_UNICODE_BREAK_OPEN_PUNCTUATION, "G_UNICODE_BREAK_OPEN_PUNCTUATION", "open-punctuation" },
+        { G_UNICODE_BREAK_CLOSE_PUNCTUATION, "G_UNICODE_BREAK_CLOSE_PUNCTUATION", "close-punctuation" },
+        { G_UNICODE_BREAK_QUOTATION, "G_UNICODE_BREAK_QUOTATION", "quotation" },
+        { G_UNICODE_BREAK_EXCLAMATION, "G_UNICODE_BREAK_EXCLAMATION", "exclamation" },
+        { G_UNICODE_BREAK_IDEOGRAPHIC, "G_UNICODE_BREAK_IDEOGRAPHIC", "ideographic" },
+        { G_UNICODE_BREAK_NUMERIC, "G_UNICODE_BREAK_NUMERIC", "numeric" },
+        { G_UNICODE_BREAK_INFIX_SEPARATOR, "G_UNICODE_BREAK_INFIX_SEPARATOR", "infix-separator" },
+        { G_UNICODE_BREAK_SYMBOL, "G_UNICODE_BREAK_SYMBOL", "symbol" },
+        { G_UNICODE_BREAK_ALPHABETIC, "G_UNICODE_BREAK_ALPHABETIC", "alphabetic" },
+        { G_UNICODE_BREAK_PREFIX, "G_UNICODE_BREAK_PREFIX", "prefix" },
+        { G_UNICODE_BREAK_POSTFIX, "G_UNICODE_BREAK_POSTFIX", "postfix" },
+        { G_UNICODE_BREAK_COMPLEX_CONTEXT, "G_UNICODE_BREAK_COMPLEX_CONTEXT", "complex-context" },
+        { G_UNICODE_BREAK_AMBIGUOUS, "G_UNICODE_BREAK_AMBIGUOUS", "ambiguous" },
+        { G_UNICODE_BREAK_UNKNOWN, "G_UNICODE_BREAK_UNKNOWN", "unknown" },
+        { G_UNICODE_BREAK_NEXT_LINE, "G_UNICODE_BREAK_NEXT_LINE", "next-line" },
+        { G_UNICODE_BREAK_WORD_JOINER, "G_UNICODE_BREAK_WORD_JOINER", "word-joiner" },
+        { G_UNICODE_BREAK_HANGUL_L_JAMO, "G_UNICODE_BREAK_HANGUL_L_JAMO", "hangul-l-jamo" },
+        { G_UNICODE_BREAK_HANGUL_V_JAMO, "G_UNICODE_BREAK_HANGUL_V_JAMO", "hangul-v-jamo" },
+        { G_UNICODE_BREAK_HANGUL_T_JAMO, "G_UNICODE_BREAK_HANGUL_T_JAMO", "hangul-t-jamo" },
+        { G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, "G_UNICODE_BREAK_HANGUL_LV_SYLLABLE", "hangul-lv-syllable" },
+        { G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, "G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE", "hangul-lvt-syllable" },
+        { G_UNICODE_BREAK_CLOSE_PARANTHESIS, "G_UNICODE_BREAK_CLOSE_PARANTHESIS", "close-paranthesis" },
+        { G_UNICODE_BREAK_CLOSE_PARENTHESIS, "G_UNICODE_BREAK_CLOSE_PARENTHESIS", "close-parenthesis" },
+        { G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER, "G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER", "conditional-japanese-starter" },
+        { G_UNICODE_BREAK_HEBREW_LETTER, "G_UNICODE_BREAK_HEBREW_LETTER", "hebrew-letter" },
+        { G_UNICODE_BREAK_REGIONAL_INDICATOR, "G_UNICODE_BREAK_REGIONAL_INDICATOR", "regional-indicator" },
+        { G_UNICODE_BREAK_EMOJI_BASE, "G_UNICODE_BREAK_EMOJI_BASE", "emoji-base" },
+        { G_UNICODE_BREAK_EMOJI_MODIFIER, "G_UNICODE_BREAK_EMOJI_MODIFIER", "emoji-modifier" },
+        { G_UNICODE_BREAK_ZERO_WIDTH_JOINER, "G_UNICODE_BREAK_ZERO_WIDTH_JOINER", "zero-width-joiner" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GUnicodeBreakType"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_unicode_script_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_UNICODE_SCRIPT_INVALID_CODE, "G_UNICODE_SCRIPT_INVALID_CODE", "invalid-code" },
+        { G_UNICODE_SCRIPT_COMMON, "G_UNICODE_SCRIPT_COMMON", "common" },
+        { G_UNICODE_SCRIPT_INHERITED, "G_UNICODE_SCRIPT_INHERITED", "inherited" },
+        { G_UNICODE_SCRIPT_ARABIC, "G_UNICODE_SCRIPT_ARABIC", "arabic" },
+        { G_UNICODE_SCRIPT_ARMENIAN, "G_UNICODE_SCRIPT_ARMENIAN", "armenian" },
+        { G_UNICODE_SCRIPT_BENGALI, "G_UNICODE_SCRIPT_BENGALI", "bengali" },
+        { G_UNICODE_SCRIPT_BOPOMOFO, "G_UNICODE_SCRIPT_BOPOMOFO", "bopomofo" },
+        { G_UNICODE_SCRIPT_CHEROKEE, "G_UNICODE_SCRIPT_CHEROKEE", "cherokee" },
+        { G_UNICODE_SCRIPT_COPTIC, "G_UNICODE_SCRIPT_COPTIC", "coptic" },
+        { G_UNICODE_SCRIPT_CYRILLIC, "G_UNICODE_SCRIPT_CYRILLIC", "cyrillic" },
+        { G_UNICODE_SCRIPT_DESERET, "G_UNICODE_SCRIPT_DESERET", "deseret" },
+        { G_UNICODE_SCRIPT_DEVANAGARI, "G_UNICODE_SCRIPT_DEVANAGARI", "devanagari" },
+        { G_UNICODE_SCRIPT_ETHIOPIC, "G_UNICODE_SCRIPT_ETHIOPIC", "ethiopic" },
+        { G_UNICODE_SCRIPT_GEORGIAN, "G_UNICODE_SCRIPT_GEORGIAN", "georgian" },
+        { G_UNICODE_SCRIPT_GOTHIC, "G_UNICODE_SCRIPT_GOTHIC", "gothic" },
+        { G_UNICODE_SCRIPT_GREEK, "G_UNICODE_SCRIPT_GREEK", "greek" },
+        { G_UNICODE_SCRIPT_GUJARATI, "G_UNICODE_SCRIPT_GUJARATI", "gujarati" },
+        { G_UNICODE_SCRIPT_GURMUKHI, "G_UNICODE_SCRIPT_GURMUKHI", "gurmukhi" },
+        { G_UNICODE_SCRIPT_HAN, "G_UNICODE_SCRIPT_HAN", "han" },
+        { G_UNICODE_SCRIPT_HANGUL, "G_UNICODE_SCRIPT_HANGUL", "hangul" },
+        { G_UNICODE_SCRIPT_HEBREW, "G_UNICODE_SCRIPT_HEBREW", "hebrew" },
+        { G_UNICODE_SCRIPT_HIRAGANA, "G_UNICODE_SCRIPT_HIRAGANA", "hiragana" },
+        { G_UNICODE_SCRIPT_KANNADA, "G_UNICODE_SCRIPT_KANNADA", "kannada" },
+        { G_UNICODE_SCRIPT_KATAKANA, "G_UNICODE_SCRIPT_KATAKANA", "katakana" },
+        { G_UNICODE_SCRIPT_KHMER, "G_UNICODE_SCRIPT_KHMER", "khmer" },
+        { G_UNICODE_SCRIPT_LAO, "G_UNICODE_SCRIPT_LAO", "lao" },
+        { G_UNICODE_SCRIPT_LATIN, "G_UNICODE_SCRIPT_LATIN", "latin" },
+        { G_UNICODE_SCRIPT_MALAYALAM, "G_UNICODE_SCRIPT_MALAYALAM", "malayalam" },
+        { G_UNICODE_SCRIPT_MONGOLIAN, "G_UNICODE_SCRIPT_MONGOLIAN", "mongolian" },
+        { G_UNICODE_SCRIPT_MYANMAR, "G_UNICODE_SCRIPT_MYANMAR", "myanmar" },
+        { G_UNICODE_SCRIPT_OGHAM, "G_UNICODE_SCRIPT_OGHAM", "ogham" },
+        { G_UNICODE_SCRIPT_OLD_ITALIC, "G_UNICODE_SCRIPT_OLD_ITALIC", "old-italic" },
+        { G_UNICODE_SCRIPT_ORIYA, "G_UNICODE_SCRIPT_ORIYA", "oriya" },
+        { G_UNICODE_SCRIPT_RUNIC, "G_UNICODE_SCRIPT_RUNIC", "runic" },
+        { G_UNICODE_SCRIPT_SINHALA, "G_UNICODE_SCRIPT_SINHALA", "sinhala" },
+        { G_UNICODE_SCRIPT_SYRIAC, "G_UNICODE_SCRIPT_SYRIAC", "syriac" },
+        { G_UNICODE_SCRIPT_TAMIL, "G_UNICODE_SCRIPT_TAMIL", "tamil" },
+        { G_UNICODE_SCRIPT_TELUGU, "G_UNICODE_SCRIPT_TELUGU", "telugu" },
+        { G_UNICODE_SCRIPT_THAANA, "G_UNICODE_SCRIPT_THAANA", "thaana" },
+        { G_UNICODE_SCRIPT_THAI, "G_UNICODE_SCRIPT_THAI", "thai" },
+        { G_UNICODE_SCRIPT_TIBETAN, "G_UNICODE_SCRIPT_TIBETAN", "tibetan" },
+        { G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL, "G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL", "canadian-aboriginal" },
+        { G_UNICODE_SCRIPT_YI, "G_UNICODE_SCRIPT_YI", "yi" },
+        { G_UNICODE_SCRIPT_TAGALOG, "G_UNICODE_SCRIPT_TAGALOG", "tagalog" },
+        { G_UNICODE_SCRIPT_HANUNOO, "G_UNICODE_SCRIPT_HANUNOO", "hanunoo" },
+        { G_UNICODE_SCRIPT_BUHID, "G_UNICODE_SCRIPT_BUHID", "buhid" },
+        { G_UNICODE_SCRIPT_TAGBANWA, "G_UNICODE_SCRIPT_TAGBANWA", "tagbanwa" },
+        { G_UNICODE_SCRIPT_BRAILLE, "G_UNICODE_SCRIPT_BRAILLE", "braille" },
+        { G_UNICODE_SCRIPT_CYPRIOT, "G_UNICODE_SCRIPT_CYPRIOT", "cypriot" },
+        { G_UNICODE_SCRIPT_LIMBU, "G_UNICODE_SCRIPT_LIMBU", "limbu" },
+        { G_UNICODE_SCRIPT_OSMANYA, "G_UNICODE_SCRIPT_OSMANYA", "osmanya" },
+        { G_UNICODE_SCRIPT_SHAVIAN, "G_UNICODE_SCRIPT_SHAVIAN", "shavian" },
+        { G_UNICODE_SCRIPT_LINEAR_B, "G_UNICODE_SCRIPT_LINEAR_B", "linear-b" },
+        { G_UNICODE_SCRIPT_TAI_LE, "G_UNICODE_SCRIPT_TAI_LE", "tai-le" },
+        { G_UNICODE_SCRIPT_UGARITIC, "G_UNICODE_SCRIPT_UGARITIC", "ugaritic" },
+        { G_UNICODE_SCRIPT_NEW_TAI_LUE, "G_UNICODE_SCRIPT_NEW_TAI_LUE", "new-tai-lue" },
+        { G_UNICODE_SCRIPT_BUGINESE, "G_UNICODE_SCRIPT_BUGINESE", "buginese" },
+        { G_UNICODE_SCRIPT_GLAGOLITIC, "G_UNICODE_SCRIPT_GLAGOLITIC", "glagolitic" },
+        { G_UNICODE_SCRIPT_TIFINAGH, "G_UNICODE_SCRIPT_TIFINAGH", "tifinagh" },
+        { G_UNICODE_SCRIPT_SYLOTI_NAGRI, "G_UNICODE_SCRIPT_SYLOTI_NAGRI", "syloti-nagri" },
+        { G_UNICODE_SCRIPT_OLD_PERSIAN, "G_UNICODE_SCRIPT_OLD_PERSIAN", "old-persian" },
+        { G_UNICODE_SCRIPT_KHAROSHTHI, "G_UNICODE_SCRIPT_KHAROSHTHI", "kharoshthi" },
+        { G_UNICODE_SCRIPT_UNKNOWN, "G_UNICODE_SCRIPT_UNKNOWN", "unknown" },
+        { G_UNICODE_SCRIPT_BALINESE, "G_UNICODE_SCRIPT_BALINESE", "balinese" },
+        { G_UNICODE_SCRIPT_CUNEIFORM, "G_UNICODE_SCRIPT_CUNEIFORM", "cuneiform" },
+        { G_UNICODE_SCRIPT_PHOENICIAN, "G_UNICODE_SCRIPT_PHOENICIAN", "phoenician" },
+        { G_UNICODE_SCRIPT_PHAGS_PA, "G_UNICODE_SCRIPT_PHAGS_PA", "phags-pa" },
+        { G_UNICODE_SCRIPT_NKO, "G_UNICODE_SCRIPT_NKO", "nko" },
+        { G_UNICODE_SCRIPT_KAYAH_LI, "G_UNICODE_SCRIPT_KAYAH_LI", "kayah-li" },
+        { G_UNICODE_SCRIPT_LEPCHA, "G_UNICODE_SCRIPT_LEPCHA", "lepcha" },
+        { G_UNICODE_SCRIPT_REJANG, "G_UNICODE_SCRIPT_REJANG", "rejang" },
+        { G_UNICODE_SCRIPT_SUNDANESE, "G_UNICODE_SCRIPT_SUNDANESE", "sundanese" },
+        { G_UNICODE_SCRIPT_SAURASHTRA, "G_UNICODE_SCRIPT_SAURASHTRA", "saurashtra" },
+        { G_UNICODE_SCRIPT_CHAM, "G_UNICODE_SCRIPT_CHAM", "cham" },
+        { G_UNICODE_SCRIPT_OL_CHIKI, "G_UNICODE_SCRIPT_OL_CHIKI", "ol-chiki" },
+        { G_UNICODE_SCRIPT_VAI, "G_UNICODE_SCRIPT_VAI", "vai" },
+        { G_UNICODE_SCRIPT_CARIAN, "G_UNICODE_SCRIPT_CARIAN", "carian" },
+        { G_UNICODE_SCRIPT_LYCIAN, "G_UNICODE_SCRIPT_LYCIAN", "lycian" },
+        { G_UNICODE_SCRIPT_LYDIAN, "G_UNICODE_SCRIPT_LYDIAN", "lydian" },
+        { G_UNICODE_SCRIPT_AVESTAN, "G_UNICODE_SCRIPT_AVESTAN", "avestan" },
+        { G_UNICODE_SCRIPT_BAMUM, "G_UNICODE_SCRIPT_BAMUM", "bamum" },
+        { G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS, "G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS", "egyptian-hieroglyphs" },
+        { G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC, "G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC", "imperial-aramaic" },
+        { G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI, "G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI", "inscriptional-pahlavi" },
+        { G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN, "G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN", "inscriptional-parthian" },
+        { G_UNICODE_SCRIPT_JAVANESE, "G_UNICODE_SCRIPT_JAVANESE", "javanese" },
+        { G_UNICODE_SCRIPT_KAITHI, "G_UNICODE_SCRIPT_KAITHI", "kaithi" },
+        { G_UNICODE_SCRIPT_LISU, "G_UNICODE_SCRIPT_LISU", "lisu" },
+        { G_UNICODE_SCRIPT_MEETEI_MAYEK, "G_UNICODE_SCRIPT_MEETEI_MAYEK", "meetei-mayek" },
+        { G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN, "G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN", "old-south-arabian" },
+        { G_UNICODE_SCRIPT_OLD_TURKIC, "G_UNICODE_SCRIPT_OLD_TURKIC", "old-turkic" },
+        { G_UNICODE_SCRIPT_SAMARITAN, "G_UNICODE_SCRIPT_SAMARITAN", "samaritan" },
+        { G_UNICODE_SCRIPT_TAI_THAM, "G_UNICODE_SCRIPT_TAI_THAM", "tai-tham" },
+        { G_UNICODE_SCRIPT_TAI_VIET, "G_UNICODE_SCRIPT_TAI_VIET", "tai-viet" },
+        { G_UNICODE_SCRIPT_BATAK, "G_UNICODE_SCRIPT_BATAK", "batak" },
+        { G_UNICODE_SCRIPT_BRAHMI, "G_UNICODE_SCRIPT_BRAHMI", "brahmi" },
+        { G_UNICODE_SCRIPT_MANDAIC, "G_UNICODE_SCRIPT_MANDAIC", "mandaic" },
+        { G_UNICODE_SCRIPT_CHAKMA, "G_UNICODE_SCRIPT_CHAKMA", "chakma" },
+        { G_UNICODE_SCRIPT_MEROITIC_CURSIVE, "G_UNICODE_SCRIPT_MEROITIC_CURSIVE", "meroitic-cursive" },
+        { G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS, "G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS", "meroitic-hieroglyphs" },
+        { G_UNICODE_SCRIPT_MIAO, "G_UNICODE_SCRIPT_MIAO", "miao" },
+        { G_UNICODE_SCRIPT_SHARADA, "G_UNICODE_SCRIPT_SHARADA", "sharada" },
+        { G_UNICODE_SCRIPT_SORA_SOMPENG, "G_UNICODE_SCRIPT_SORA_SOMPENG", "sora-sompeng" },
+        { G_UNICODE_SCRIPT_TAKRI, "G_UNICODE_SCRIPT_TAKRI", "takri" },
+        { G_UNICODE_SCRIPT_BASSA_VAH, "G_UNICODE_SCRIPT_BASSA_VAH", "bassa-vah" },
+        { G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN, "G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN", "caucasian-albanian" },
+        { G_UNICODE_SCRIPT_DUPLOYAN, "G_UNICODE_SCRIPT_DUPLOYAN", "duployan" },
+        { G_UNICODE_SCRIPT_ELBASAN, "G_UNICODE_SCRIPT_ELBASAN", "elbasan" },
+        { G_UNICODE_SCRIPT_GRANTHA, "G_UNICODE_SCRIPT_GRANTHA", "grantha" },
+        { G_UNICODE_SCRIPT_KHOJKI, "G_UNICODE_SCRIPT_KHOJKI", "khojki" },
+        { G_UNICODE_SCRIPT_KHUDAWADI, "G_UNICODE_SCRIPT_KHUDAWADI", "khudawadi" },
+        { G_UNICODE_SCRIPT_LINEAR_A, "G_UNICODE_SCRIPT_LINEAR_A", "linear-a" },
+        { G_UNICODE_SCRIPT_MAHAJANI, "G_UNICODE_SCRIPT_MAHAJANI", "mahajani" },
+        { G_UNICODE_SCRIPT_MANICHAEAN, "G_UNICODE_SCRIPT_MANICHAEAN", "manichaean" },
+        { G_UNICODE_SCRIPT_MENDE_KIKAKUI, "G_UNICODE_SCRIPT_MENDE_KIKAKUI", "mende-kikakui" },
+        { G_UNICODE_SCRIPT_MODI, "G_UNICODE_SCRIPT_MODI", "modi" },
+        { G_UNICODE_SCRIPT_MRO, "G_UNICODE_SCRIPT_MRO", "mro" },
+        { G_UNICODE_SCRIPT_NABATAEAN, "G_UNICODE_SCRIPT_NABATAEAN", "nabataean" },
+        { G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN, "G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN", "old-north-arabian" },
+        { G_UNICODE_SCRIPT_OLD_PERMIC, "G_UNICODE_SCRIPT_OLD_PERMIC", "old-permic" },
+        { G_UNICODE_SCRIPT_PAHAWH_HMONG, "G_UNICODE_SCRIPT_PAHAWH_HMONG", "pahawh-hmong" },
+        { G_UNICODE_SCRIPT_PALMYRENE, "G_UNICODE_SCRIPT_PALMYRENE", "palmyrene" },
+        { G_UNICODE_SCRIPT_PAU_CIN_HAU, "G_UNICODE_SCRIPT_PAU_CIN_HAU", "pau-cin-hau" },
+        { G_UNICODE_SCRIPT_PSALTER_PAHLAVI, "G_UNICODE_SCRIPT_PSALTER_PAHLAVI", "psalter-pahlavi" },
+        { G_UNICODE_SCRIPT_SIDDHAM, "G_UNICODE_SCRIPT_SIDDHAM", "siddham" },
+        { G_UNICODE_SCRIPT_TIRHUTA, "G_UNICODE_SCRIPT_TIRHUTA", "tirhuta" },
+        { G_UNICODE_SCRIPT_WARANG_CITI, "G_UNICODE_SCRIPT_WARANG_CITI", "warang-citi" },
+        { G_UNICODE_SCRIPT_AHOM, "G_UNICODE_SCRIPT_AHOM", "ahom" },
+        { G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS, "G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS", "anatolian-hieroglyphs" },
+        { G_UNICODE_SCRIPT_HATRAN, "G_UNICODE_SCRIPT_HATRAN", "hatran" },
+        { G_UNICODE_SCRIPT_MULTANI, "G_UNICODE_SCRIPT_MULTANI", "multani" },
+        { G_UNICODE_SCRIPT_OLD_HUNGARIAN, "G_UNICODE_SCRIPT_OLD_HUNGARIAN", "old-hungarian" },
+        { G_UNICODE_SCRIPT_SIGNWRITING, "G_UNICODE_SCRIPT_SIGNWRITING", "signwriting" },
+        { G_UNICODE_SCRIPT_ADLAM, "G_UNICODE_SCRIPT_ADLAM", "adlam" },
+        { G_UNICODE_SCRIPT_BHAIKSUKI, "G_UNICODE_SCRIPT_BHAIKSUKI", "bhaiksuki" },
+        { G_UNICODE_SCRIPT_MARCHEN, "G_UNICODE_SCRIPT_MARCHEN", "marchen" },
+        { G_UNICODE_SCRIPT_NEWA, "G_UNICODE_SCRIPT_NEWA", "newa" },
+        { G_UNICODE_SCRIPT_OSAGE, "G_UNICODE_SCRIPT_OSAGE", "osage" },
+        { G_UNICODE_SCRIPT_TANGUT, "G_UNICODE_SCRIPT_TANGUT", "tangut" },
+        { G_UNICODE_SCRIPT_MASARAM_GONDI, "G_UNICODE_SCRIPT_MASARAM_GONDI", "masaram-gondi" },
+        { G_UNICODE_SCRIPT_NUSHU, "G_UNICODE_SCRIPT_NUSHU", "nushu" },
+        { G_UNICODE_SCRIPT_SOYOMBO, "G_UNICODE_SCRIPT_SOYOMBO", "soyombo" },
+        { G_UNICODE_SCRIPT_ZANABAZAR_SQUARE, "G_UNICODE_SCRIPT_ZANABAZAR_SQUARE", "zanabazar-square" },
+        { G_UNICODE_SCRIPT_DOGRA, "G_UNICODE_SCRIPT_DOGRA", "dogra" },
+        { G_UNICODE_SCRIPT_GUNJALA_GONDI, "G_UNICODE_SCRIPT_GUNJALA_GONDI", "gunjala-gondi" },
+        { G_UNICODE_SCRIPT_HANIFI_ROHINGYA, "G_UNICODE_SCRIPT_HANIFI_ROHINGYA", "hanifi-rohingya" },
+        { G_UNICODE_SCRIPT_MAKASAR, "G_UNICODE_SCRIPT_MAKASAR", "makasar" },
+        { G_UNICODE_SCRIPT_MEDEFAIDRIN, "G_UNICODE_SCRIPT_MEDEFAIDRIN", "medefaidrin" },
+        { G_UNICODE_SCRIPT_OLD_SOGDIAN, "G_UNICODE_SCRIPT_OLD_SOGDIAN", "old-sogdian" },
+        { G_UNICODE_SCRIPT_SOGDIAN, "G_UNICODE_SCRIPT_SOGDIAN", "sogdian" },
+        { G_UNICODE_SCRIPT_ELYMAIC, "G_UNICODE_SCRIPT_ELYMAIC", "elymaic" },
+        { G_UNICODE_SCRIPT_NANDINAGARI, "G_UNICODE_SCRIPT_NANDINAGARI", "nandinagari" },
+        { G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG, "G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG", "nyiakeng-puachue-hmong" },
+        { G_UNICODE_SCRIPT_WANCHO, "G_UNICODE_SCRIPT_WANCHO", "wancho" },
+        { G_UNICODE_SCRIPT_CHORASMIAN, "G_UNICODE_SCRIPT_CHORASMIAN", "chorasmian" },
+        { G_UNICODE_SCRIPT_DIVES_AKURU, "G_UNICODE_SCRIPT_DIVES_AKURU", "dives-akuru" },
+        { G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT, "G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT", "khitan-small-script" },
+        { G_UNICODE_SCRIPT_YEZIDI, "G_UNICODE_SCRIPT_YEZIDI", "yezidi" },
+        { G_UNICODE_SCRIPT_CYPRO_MINOAN, "G_UNICODE_SCRIPT_CYPRO_MINOAN", "cypro-minoan" },
+        { G_UNICODE_SCRIPT_OLD_UYGHUR, "G_UNICODE_SCRIPT_OLD_UYGHUR", "old-uyghur" },
+        { G_UNICODE_SCRIPT_TANGSA, "G_UNICODE_SCRIPT_TANGSA", "tangsa" },
+        { G_UNICODE_SCRIPT_TOTO, "G_UNICODE_SCRIPT_TOTO", "toto" },
+        { G_UNICODE_SCRIPT_VITHKUQI, "G_UNICODE_SCRIPT_VITHKUQI", "vithkuqi" },
+        { G_UNICODE_SCRIPT_MATH, "G_UNICODE_SCRIPT_MATH", "math" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GUnicodeScript"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+GType
+g_normalize_mode_get_type (void)
+{
+  static gsize static_g_define_type_id = 0;
+
+  if (g_once_init_enter (&static_g_define_type_id))
+    {
+      static const GEnumValue values[] = {
+        { G_NORMALIZE_DEFAULT, "G_NORMALIZE_DEFAULT", "default" },
+        { G_NORMALIZE_NFD, "G_NORMALIZE_NFD", "nfd" },
+        { G_NORMALIZE_DEFAULT_COMPOSE, "G_NORMALIZE_DEFAULT_COMPOSE", "default-compose" },
+        { G_NORMALIZE_NFC, "G_NORMALIZE_NFC", "nfc" },
+        { G_NORMALIZE_ALL, "G_NORMALIZE_ALL", "all" },
+        { G_NORMALIZE_NFKD, "G_NORMALIZE_NFKD", "nfkd" },
+        { G_NORMALIZE_ALL_COMPOSE, "G_NORMALIZE_ALL_COMPOSE", "all-compose" },
+        { G_NORMALIZE_NFKC, "G_NORMALIZE_NFKC", "nfkc" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_enum_register_static (g_intern_static_string ("GNormalizeMode"), values);
+      g_once_init_leave (&static_g_define_type_id, g_define_type_id);
+    }
+
+  return static_g_define_type_id;
+}
+
+G_GNUC_END_IGNORE_DEPRECATIONS
+
+/* Generated data ends here */
+
diff --git a/gobject/glib-enumtypes.h b/gobject/glib-enumtypes.h
new file mode 100644
index 0000000..9844954
--- /dev/null
+++ b/gobject/glib-enumtypes.h
@@ -0,0 +1,25 @@
+
+/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */
+
+#ifndef __GOBJECT_ENUM_TYPES_H__
+#define __GOBJECT_ENUM_TYPES_H__
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+/* enumerations from "../gobject/../glib/gunicode.h" */
+GLIB_AVAILABLE_IN_2_60 GType g_unicode_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_UNICODE_TYPE (g_unicode_type_get_type ())
+GLIB_AVAILABLE_IN_2_60 GType g_unicode_break_type_get_type (void) G_GNUC_CONST;
+#define G_TYPE_UNICODE_BREAK_TYPE (g_unicode_break_type_get_type ())
+GLIB_AVAILABLE_IN_2_60 GType g_unicode_script_get_type (void) G_GNUC_CONST;
+#define G_TYPE_UNICODE_SCRIPT (g_unicode_script_get_type ())
+GLIB_AVAILABLE_IN_2_60 GType g_normalize_mode_get_type (void) G_GNUC_CONST;
+#define G_TYPE_NORMALIZE_MODE (g_normalize_mode_get_type ())
+G_END_DECLS
+
+#endif /* __GOBJECT_ENUM_TYPES_H__ */
+
+/* Generated data ends here */
+

diff --git a/glib/garray.c b/glib/garray.c
index 1ab3bee..02d35e7 100644
--- a/glib/garray.c
+++ b/glib/garray.c
@@ -993,6 +993,7 @@ g_array_maybe_expand (GRealArray *array,
   if (want_len > array->elt_capacity)
     {
       gsize want_alloc = g_nearest_pow (g_array_elt_len (array, want_len));
+      g_assert (want_alloc >= g_array_elt_len (array, want_len));
       want_alloc = MAX (want_alloc, MIN_ARRAY_SIZE);
 
       array->data = g_realloc (array->data, want_alloc);
diff --git a/gio/gsocks4aproxy.c b/gio/gsocks4aproxy.c
index 988ddaf..c7c5d5e 100644
--- a/gio/gsocks4aproxy.c
+++ b/gio/gsocks4aproxy.c
@@ -77,9 +77,9 @@ g_socks4a_proxy_init (GSocks4aProxy *proxy)
  * +----+----+----+----+----+----+----+----+----+----+....+----+------+....+------+
  * | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL| HOST |    | NULL |
  * +----+----+----+----+----+----+----+----+----+----+....+----+------+....+------+
- *    1    1      2              4           variable       1    variable
+ *    1    1      2              4           variable       1    variable    1
  */
-#define SOCKS4_CONN_MSG_LEN        (9 + SOCKS4_MAX_LEN * 2)
+#define SOCKS4_CONN_MSG_LEN        (10 + SOCKS4_MAX_LEN * 2)
 static gint
 set_connect_msg (guint8      *msg,
                 const gchar *hostname,